//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.3.0.0 (NJsonSchema v11.2.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface IClient {

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body?: LoginUserSchema | undefined): Promise<void>;

    /**
     * @return Success
     */
    logout(): Promise<void>;

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body?: RegisterUserSchema | undefined): Promise<void>;

    /**
     * @return Success
     */
    externalLogin(provider: string): Promise<void>;

    /**
     * @return Success
     */
    externalLoginCallback(): Promise<void>;

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body?: CreateCategoryCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body?: UpdateCategoryCommand | undefined): Promise<CommandResult>;

    /**
     * @return Success
     */
    category(categoryId: string): Promise<CommandResult>;

    /**
     * @return Success
     */
    list(): Promise<CategoryEntity[]>;

    /**
     * @return Success
     */
    orderInfo(userId: string): Promise<ClientJobInfo>;

    /**
     * @param body (optional) 
     * @return Success
     */
    create2(body?: CreateClientProfileCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    suspend(body?: SuspendClientProfileCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    update2(body?: UpdateClientProfileCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    create3(body?: CreateContestCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    approve(body?: ApproveContestCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    start(body?: StartContestCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    end(body?: EndContestCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body?: DeleteContestCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    selectWinner(body?: SelectContestWinnerCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    submitEntry(body?: SubmitContestEntryCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteEntry(body?: DeleteContestEntryCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    update3(body?: UpdateContestCommand | undefined): Promise<CommandResult>;

    /**
     * @return Success
     */
    contest(id: string): Promise<ContestEntity>;

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    list2(start?: number | undefined, end?: number | undefined): Promise<ContestEntity[]>;

    /**
     * @param body (optional) 
     * @return Success
     */
    create4(body?: CreateContractCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    clientAcceptFinish(body?: ClientAcceptFinishContractCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    clientClose(body?: ClientCloseContractCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    clientRejectCompletion(body?: ClientRejectContractCompletionCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    freelancerAccept(body?: FreelancerAcceptContractCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    freelancerFinish(body?: FreelancerFinishContractCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    acceptDispute(body?: AcceptDisputeCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    initiateDispute(body?: InitiateDisputeCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    resolveDispute(body?: ResolveDisputeCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    forceCancel(body?: ForceContractCancelCommand | undefined): Promise<CommandResult>;

    /**
     * @return Success
     */
    contract(id: string): Promise<ContractEntity>;

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    list3(start?: number | undefined, end?: number | undefined): Promise<ContractEntity[]>;

    /**
     * @param file (optional) 
     * @return Success
     */
    upload(file?: FileParameter | undefined): Promise<FileEntity>;

    /**
     * @return Success
     */
    download(fileId: string): Promise<void>;

    /**
     * @param body (optional) 
     * @return Success
     */
    create5(body?: CreateFreelancerProfileCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    update4(body?: UpdateFreelancerProfileCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    hide(body?: HideFreelancerProfileCommand | undefined): Promise<CommandResult>;

    /**
     * @return Success
     */
    freelancerProfile(userId: string): Promise<FreelancerProfileEntity>;

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @param skills (optional) 
     * @param minCost (optional) 
     * @param maxCost (optional) 
     * @param minReviews (optional) 
     * @param maxReviews (optional) 
     * @return Success
     */
    list4(start?: number | undefined, end?: number | undefined, skills?: string[] | undefined, minCost?: number | undefined, maxCost?: number | undefined, minReviews?: number | undefined, maxReviews?: number | undefined): Promise<FreelancerProfileEntity[]>;

    /**
     * @param body (optional) 
     * @return Success
     */
    create6(body?: CreateFreelancerTeamCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    update5(body?: UpdateFreelancerTeamCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    delete2(body?: DeleteFreelancerTeamCommand | undefined): Promise<CommandResult>;

    /**
     * @return Success
     */
    list5(): Promise<FreelancerTeamEntity[]>;

    /**
     * @param body (optional) 
     * @return Success
     */
    create7(body?: CreateJobCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    update6(body?: UpdateJobCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    delete3(body?: DeleteJobCommand | undefined): Promise<CommandResult>;

    /**
     * @return Success
     */
    job(id: string): Promise<Job>;

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    list6(start?: number | undefined, end?: number | undefined): Promise<Job[]>;

    /**
     * @param body (optional) 
     * @return Success
     */
    bookmark(body?: BookmarkJobCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    hide2(body?: HideJobCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    submitProposal(body?: SubmitProposalCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProposal(body?: UpdateProposalCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    withdrawProposal(body?: WithdrawProposalCommand | undefined): Promise<CommandResult>;

    /**
     * @return Success
     */
    bookmarks(): Promise<JobEntity[]>;

    /**
     * @param start (optional) 
     * @param ends (optional) 
     * @return Success
     */
    userAll(userId: string, start?: number | undefined, ends?: number | undefined): Promise<NotificationEntity[]>;

    /**
     * @param body (optional) 
     * @return Success
     */
    notification(body?: CreateNotificationCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    create8(body?: AddPortfolioProjectCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    update7(body?: UpdatePortfolioProjectCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    delete4(body?: DeletePortfolioProjectCommand | undefined): Promise<CommandResult>;

    /**
     * @return Success
     */
    list7(): Promise<PortfolioProjectEntity[]>;

    /**
     * @param body (optional) 
     * @return Success
     */
    create9(body?: CreateSkillsCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    update8(body?: UpdateSkillsCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    delete5(body?: DeleteSkillsCommand | undefined): Promise<CommandResult>;

    /**
     * @return Success
     */
    list8(): Promise<SkillEntity[]>;

    /**
     * @return Success
     */
    block(userId: string): Promise<boolean>;

    /**
     * @param body (optional) 
     * @return Success
     */
    warn(userId: string, body?: WarnUserScheme | undefined): Promise<boolean>;

    /**
     * @param body (optional) 
     * @return Success
     */
    ticketPOST(body?: CreateTicketDto | undefined): Promise<TicketEntity>;

    /**
     * @param body (optional) 
     * @return Success
     */
    ticketAll(body?: GetTicketsDto | undefined): Promise<TicketEntity[]>;

    /**
     * @return Success
     */
    ticketGET(ticketId: string): Promise<TicketEntity>;

    /**
     * @param body (optional) 
     * @return Success
     */
    create10(body?: CreateTaskCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    complete(body?: CompleteTaskCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    react(body?: ReactToTaskCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    update9(body?: UpdateTaskCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    delete6(body?: DeleteTaskCommand | undefined): Promise<CommandResult>;

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    list9(contractId: string, start?: number | undefined, end?: number | undefined): Promise<TransactionEntity[]>;

    /**
     * @param body (optional) 
     * @return Success
     */
    handle(body?: HandleTransactionCommand | undefined): Promise<CommandResult>;

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    list10(start?: number | undefined, end?: number | undefined): Promise<TransactionEntity[]>;

    /**
     * @return Success
     */
    providers(): Promise<TransactionProviderEntity[]>;

    /**
     * @param body (optional) 
     * @return Success
     */
    depositResult(body?: GatewayResultCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    refund(body?: RefundTransactionCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    withdrawalResult(body?: GatewayResultCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    start2(body?: StartPaymentFlowCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    userPATCH(userId: string, body?: UpdateUserCommand | undefined): Promise<boolean>;

    /**
     * @return Success
     */
    userGET(userId: string): Promise<UserEntity>;

    /**
     * @param body (optional) 
     * @return Success
     */
    mePATCH(body?: UpdateUserCommand | undefined): Promise<boolean>;

    /**
     * @return Success
     */
    meGET(): Promise<UserEntity>;

    /**
     * @param body (optional) 
     * @return Success
     */
    balanceOperation(body?: BalanceOperationCommand | undefined): Promise<CommandResult>;

    /**
     * @return Success
     */
    wallet(walletId: string): Promise<WalletEntity>;

    /**
     * @param body (optional) 
     * @return Success
     */
    block2(body?: BlockWalletCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    start3(body?: StartWorkSessionCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    submit(body?: SubmitWorkSessionCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    end2(body?: EndWorkSessionCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    approve2(body?: ApproveWorkSessionCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    react2(body?: ReactToWorkSessionCommand | undefined): Promise<CommandResult>;

    /**
     * @return Success
     */
    workSession(id: string): Promise<WorkSessionEntity>;

    /**
     * @param contractId (optional) 
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    list11(contractId?: string | undefined, start?: number | undefined, end?: number | undefined): Promise<WorkSessionEntity[]>;
}

export class Client implements IClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body?: LoginUserSchema | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    logout(): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body?: RegisterUserSchema | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    externalLogin(provider: string): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/external-login/{provider}";
        if (provider === undefined || provider === null)
            throw new Error("The parameter 'provider' must be defined.");
        url_ = url_.replace("{provider}", encodeURIComponent("" + provider));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExternalLogin(_response);
        });
    }

    protected processExternalLogin(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    externalLoginCallback(): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/external-login-callback";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExternalLoginCallback(_response);
        });
    }

    protected processExternalLoginCallback(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body?: CreateCategoryCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/category/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body?: UpdateCategoryCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/category/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return Success
     */
    category(categoryId: string): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/category/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategory(_response);
        });
    }

    protected processCategory(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return Success
     */
    list(): Promise<CategoryEntity[]> {
        let url_ = this.baseUrl + "/api/category/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<CategoryEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CategoryEntity[]>(null as any);
    }

    /**
     * @return Success
     */
    orderInfo(userId: string): Promise<ClientJobInfo> {
        let url_ = this.baseUrl + "/api/client-profile/order-info/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrderInfo(_response);
        });
    }

    protected processOrderInfo(response: Response): Promise<ClientJobInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientJobInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientJobInfo>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create2(body?: CreateClientProfileCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/client-profile/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate2(_response);
        });
    }

    protected processCreate2(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    suspend(body?: SuspendClientProfileCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/client-profile/suspend";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSuspend(_response);
        });
    }

    protected processSuspend(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update2(body?: UpdateClientProfileCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/client-profile/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate2(_response);
        });
    }

    protected processUpdate2(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create3(body?: CreateContestCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate3(_response);
        });
    }

    protected processCreate3(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approve(body?: ApproveContestCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApprove(_response);
        });
    }

    protected processApprove(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    start(body?: StartContestCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/start";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStart(_response);
        });
    }

    protected processStart(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    end(body?: EndContestCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/end";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnd(_response);
        });
    }

    protected processEnd(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body?: DeleteContestCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    selectWinner(body?: SelectContestWinnerCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/select-winner";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSelectWinner(_response);
        });
    }

    protected processSelectWinner(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submitEntry(body?: SubmitContestEntryCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/submit-entry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubmitEntry(_response);
        });
    }

    protected processSubmitEntry(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteEntry(body?: DeleteContestEntryCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/delete-entry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntry(_response);
        });
    }

    protected processDeleteEntry(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update3(body?: UpdateContestCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate3(_response);
        });
    }

    protected processUpdate3(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return Success
     */
    contest(id: string): Promise<ContestEntity> {
        let url_ = this.baseUrl + "/api/contest/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContest(_response);
        });
    }

    protected processContest(response: Response): Promise<ContestEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContestEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContestEntity>(null as any);
    }

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    list2(start?: number | undefined, end?: number | undefined): Promise<ContestEntity[]> {
        let url_ = this.baseUrl + "/api/contest/list?";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent("" + end) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList2(_response);
        });
    }

    protected processList2(response: Response): Promise<ContestEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContestEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContestEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create4(body?: CreateContractCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate4(_response);
        });
    }

    protected processCreate4(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clientAcceptFinish(body?: ClientAcceptFinishContractCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/client-accept-finish";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClientAcceptFinish(_response);
        });
    }

    protected processClientAcceptFinish(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clientClose(body?: ClientCloseContractCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/client-close";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClientClose(_response);
        });
    }

    protected processClientClose(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clientRejectCompletion(body?: ClientRejectContractCompletionCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/client-reject-completion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClientRejectCompletion(_response);
        });
    }

    protected processClientRejectCompletion(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    freelancerAccept(body?: FreelancerAcceptContractCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/freelancer-accept";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFreelancerAccept(_response);
        });
    }

    protected processFreelancerAccept(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    freelancerFinish(body?: FreelancerFinishContractCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/freelancer-finish";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFreelancerFinish(_response);
        });
    }

    protected processFreelancerFinish(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    acceptDispute(body?: AcceptDisputeCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/accept-dispute";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAcceptDispute(_response);
        });
    }

    protected processAcceptDispute(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    initiateDispute(body?: InitiateDisputeCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/initiate-dispute";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInitiateDispute(_response);
        });
    }

    protected processInitiateDispute(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resolveDispute(body?: ResolveDisputeCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/resolve-dispute";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResolveDispute(_response);
        });
    }

    protected processResolveDispute(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    forceCancel(body?: ForceContractCancelCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/force-cancel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForceCancel(_response);
        });
    }

    protected processForceCancel(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return Success
     */
    contract(id: string): Promise<ContractEntity> {
        let url_ = this.baseUrl + "/api/contract/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContract(_response);
        });
    }

    protected processContract(response: Response): Promise<ContractEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractEntity>(null as any);
    }

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    list3(start?: number | undefined, end?: number | undefined): Promise<ContractEntity[]> {
        let url_ = this.baseUrl + "/api/contract/list?";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent("" + end) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList3(_response);
        });
    }

    protected processList3(response: Response): Promise<ContractEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContractEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractEntity[]>(null as any);
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    upload(file?: FileParameter | undefined): Promise<FileEntity> {
        let url_ = this.baseUrl + "/api/files/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileEntity>(null as any);
    }

    /**
     * @return Success
     */
    download(fileId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/files/download/{fileId}";
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownload(_response);
        });
    }

    protected processDownload(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create5(body?: CreateFreelancerProfileCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/freelancer-profile/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate5(_response);
        });
    }

    protected processCreate5(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update4(body?: UpdateFreelancerProfileCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/freelancer-profile/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate4(_response);
        });
    }

    protected processUpdate4(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hide(body?: HideFreelancerProfileCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/freelancer-profile/hide";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHide(_response);
        });
    }

    protected processHide(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return Success
     */
    freelancerProfile(userId: string): Promise<FreelancerProfileEntity> {
        let url_ = this.baseUrl + "/api/freelancer-profile/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFreelancerProfile(_response);
        });
    }

    protected processFreelancerProfile(response: Response): Promise<FreelancerProfileEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FreelancerProfileEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FreelancerProfileEntity>(null as any);
    }

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @param skills (optional) 
     * @param minCost (optional) 
     * @param maxCost (optional) 
     * @param minReviews (optional) 
     * @param maxReviews (optional) 
     * @return Success
     */
    list4(start?: number | undefined, end?: number | undefined, skills?: string[] | undefined, minCost?: number | undefined, maxCost?: number | undefined, minReviews?: number | undefined, maxReviews?: number | undefined): Promise<FreelancerProfileEntity[]> {
        let url_ = this.baseUrl + "/api/freelancer-profile/list?";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent("" + end) + "&";
        if (skills === null)
            throw new Error("The parameter 'skills' cannot be null.");
        else if (skills !== undefined)
            skills && skills.forEach(item => { url_ += "skills=" + encodeURIComponent("" + item) + "&"; });
        if (minCost === null)
            throw new Error("The parameter 'minCost' cannot be null.");
        else if (minCost !== undefined)
            url_ += "minCost=" + encodeURIComponent("" + minCost) + "&";
        if (maxCost === null)
            throw new Error("The parameter 'maxCost' cannot be null.");
        else if (maxCost !== undefined)
            url_ += "maxCost=" + encodeURIComponent("" + maxCost) + "&";
        if (minReviews === null)
            throw new Error("The parameter 'minReviews' cannot be null.");
        else if (minReviews !== undefined)
            url_ += "minReviews=" + encodeURIComponent("" + minReviews) + "&";
        if (maxReviews === null)
            throw new Error("The parameter 'maxReviews' cannot be null.");
        else if (maxReviews !== undefined)
            url_ += "maxReviews=" + encodeURIComponent("" + maxReviews) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList4(_response);
        });
    }

    protected processList4(response: Response): Promise<FreelancerProfileEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FreelancerProfileEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FreelancerProfileEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create6(body?: CreateFreelancerTeamCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/freelancer-team/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate6(_response);
        });
    }

    protected processCreate6(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update5(body?: UpdateFreelancerTeamCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/freelancer-team/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate5(_response);
        });
    }

    protected processUpdate5(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete2(body?: DeleteFreelancerTeamCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/freelancer-team/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete2(_response);
        });
    }

    protected processDelete2(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return Success
     */
    list5(): Promise<FreelancerTeamEntity[]> {
        let url_ = this.baseUrl + "/api/freelancer-team/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList5(_response);
        });
    }

    protected processList5(response: Response): Promise<FreelancerTeamEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FreelancerTeamEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FreelancerTeamEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create7(body?: CreateJobCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate7(_response);
        });
    }

    protected processCreate7(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update6(body?: UpdateJobCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate6(_response);
        });
    }

    protected processUpdate6(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete3(body?: DeleteJobCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete3(_response);
        });
    }

    protected processDelete3(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return Success
     */
    job(id: string): Promise<Job> {
        let url_ = this.baseUrl + "/api/job/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processJob(_response);
        });
    }

    protected processJob(response: Response): Promise<Job> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Job.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Job>(null as any);
    }

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    list6(start?: number | undefined, end?: number | undefined): Promise<Job[]> {
        let url_ = this.baseUrl + "/api/job/list?";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent("" + end) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList6(_response);
        });
    }

    protected processList6(response: Response): Promise<Job[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Job.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Job[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bookmark(body?: BookmarkJobCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/bookmark";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBookmark(_response);
        });
    }

    protected processBookmark(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hide2(body?: HideJobCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/hide";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHide2(_response);
        });
    }

    protected processHide2(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submitProposal(body?: SubmitProposalCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/submit-proposal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubmitProposal(_response);
        });
    }

    protected processSubmitProposal(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProposal(body?: UpdateProposalCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/update-proposal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProposal(_response);
        });
    }

    protected processUpdateProposal(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    withdrawProposal(body?: WithdrawProposalCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/withdraw-proposal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWithdrawProposal(_response);
        });
    }

    protected processWithdrawProposal(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return Success
     */
    bookmarks(): Promise<JobEntity[]> {
        let url_ = this.baseUrl + "/api/job/bookmarks";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBookmarks(_response);
        });
    }

    protected processBookmarks(response: Response): Promise<JobEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JobEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JobEntity[]>(null as any);
    }

    /**
     * @param start (optional) 
     * @param ends (optional) 
     * @return Success
     */
    userAll(userId: string, start?: number | undefined, ends?: number | undefined): Promise<NotificationEntity[]> {
        let url_ = this.baseUrl + "/api/notification/user/{userId}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "Start=" + encodeURIComponent("" + start) + "&";
        if (ends === null)
            throw new Error("The parameter 'ends' cannot be null.");
        else if (ends !== undefined)
            url_ += "Ends=" + encodeURIComponent("" + ends) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserAll(_response);
        });
    }

    protected processUserAll(response: Response): Promise<NotificationEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NotificationEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    notification(body?: CreateNotificationCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/notification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotification(_response);
        });
    }

    protected processNotification(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create8(body?: AddPortfolioProjectCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/portfolio-project/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate8(_response);
        });
    }

    protected processCreate8(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update7(body?: UpdatePortfolioProjectCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/portfolio-project/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate7(_response);
        });
    }

    protected processUpdate7(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete4(body?: DeletePortfolioProjectCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/portfolio-project/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete4(_response);
        });
    }

    protected processDelete4(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return Success
     */
    list7(): Promise<PortfolioProjectEntity[]> {
        let url_ = this.baseUrl + "/api/portfolio-project/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList7(_response);
        });
    }

    protected processList7(response: Response): Promise<PortfolioProjectEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PortfolioProjectEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PortfolioProjectEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create9(body?: CreateSkillsCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/skill/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate9(_response);
        });
    }

    protected processCreate9(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update8(body?: UpdateSkillsCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/skill/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate8(_response);
        });
    }

    protected processUpdate8(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete5(body?: DeleteSkillsCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/skill/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete5(_response);
        });
    }

    protected processDelete5(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return Success
     */
    list8(): Promise<SkillEntity[]> {
        let url_ = this.baseUrl + "/api/skill/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList8(_response);
        });
    }

    protected processList8(response: Response): Promise<SkillEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SkillEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SkillEntity[]>(null as any);
    }

    /**
     * @return Success
     */
    block(userId: string): Promise<boolean> {
        let url_ = this.baseUrl + "/api/stuff/user/{userId}/block";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBlock(_response);
        });
    }

    protected processBlock(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    warn(userId: string, body?: WarnUserScheme | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/stuff/user/{userId}/warn";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWarn(_response);
        });
    }

    protected processWarn(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    ticketPOST(body?: CreateTicketDto | undefined): Promise<TicketEntity> {
        let url_ = this.baseUrl + "/api/stuff/ticket";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTicketPOST(_response);
        });
    }

    protected processTicketPOST(response: Response): Promise<TicketEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TicketEntity>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    ticketAll(body?: GetTicketsDto | undefined): Promise<TicketEntity[]> {
        let url_ = this.baseUrl + "/api/stuff/ticket";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTicketAll(_response);
        });
    }

    protected processTicketAll(response: Response): Promise<TicketEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TicketEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TicketEntity[]>(null as any);
    }

    /**
     * @return Success
     */
    ticketGET(ticketId: string): Promise<TicketEntity> {
        let url_ = this.baseUrl + "/api/stuff/ticket/{ticketId}";
        if (ticketId === undefined || ticketId === null)
            throw new Error("The parameter 'ticketId' must be defined.");
        url_ = url_.replace("{ticketId}", encodeURIComponent("" + ticketId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTicketGET(_response);
        });
    }

    protected processTicketGET(response: Response): Promise<TicketEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TicketEntity>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create10(body?: CreateTaskCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/task/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate10(_response);
        });
    }

    protected processCreate10(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    complete(body?: CompleteTaskCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/task/complete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComplete(_response);
        });
    }

    protected processComplete(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    react(body?: ReactToTaskCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/task/react";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReact(_response);
        });
    }

    protected processReact(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update9(body?: UpdateTaskCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/task/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate9(_response);
        });
    }

    protected processUpdate9(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete6(body?: DeleteTaskCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/task/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete6(_response);
        });
    }

    protected processDelete6(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    list9(contractId: string, start?: number | undefined, end?: number | undefined): Promise<TransactionEntity[]> {
        let url_ = this.baseUrl + "/api/task/list/{contractId}?";
        if (contractId === undefined || contractId === null)
            throw new Error("The parameter 'contractId' must be defined.");
        url_ = url_.replace("{contractId}", encodeURIComponent("" + contractId));
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent("" + end) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList9(_response);
        });
    }

    protected processList9(response: Response): Promise<TransactionEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TransactionEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransactionEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    handle(body?: HandleTransactionCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/transaction/handle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHandle(_response);
        });
    }

    protected processHandle(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    list10(start?: number | undefined, end?: number | undefined): Promise<TransactionEntity[]> {
        let url_ = this.baseUrl + "/api/transaction/list?";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent("" + end) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList10(_response);
        });
    }

    protected processList10(response: Response): Promise<TransactionEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TransactionEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransactionEntity[]>(null as any);
    }

    /**
     * @return Success
     */
    providers(): Promise<TransactionProviderEntity[]> {
        let url_ = this.baseUrl + "/api/transaction/providers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProviders(_response);
        });
    }

    protected processProviders(response: Response): Promise<TransactionProviderEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TransactionProviderEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransactionProviderEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    depositResult(body?: GatewayResultCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/transaction/deposit-result";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDepositResult(_response);
        });
    }

    protected processDepositResult(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    refund(body?: RefundTransactionCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/transaction/refund";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefund(_response);
        });
    }

    protected processRefund(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    withdrawalResult(body?: GatewayResultCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/transaction/withdrawal-result";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWithdrawalResult(_response);
        });
    }

    protected processWithdrawalResult(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    start2(body?: StartPaymentFlowCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/transaction/start";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStart2(_response);
        });
    }

    protected processStart2(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    userPATCH(userId: string, body?: UpdateUserCommand | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/user/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserPATCH(_response);
        });
    }

    protected processUserPATCH(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    userGET(userId: string): Promise<UserEntity> {
        let url_ = this.baseUrl + "/api/user/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserGET(_response);
        });
    }

    protected processUserGET(response: Response): Promise<UserEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserEntity>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mePATCH(body?: UpdateUserCommand | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/user/me";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMePATCH(_response);
        });
    }

    protected processMePATCH(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    meGET(): Promise<UserEntity> {
        let url_ = this.baseUrl + "/api/user/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMeGET(_response);
        });
    }

    protected processMeGET(response: Response): Promise<UserEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserEntity>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    balanceOperation(body?: BalanceOperationCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/wallet/balance-operation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBalanceOperation(_response);
        });
    }

    protected processBalanceOperation(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return Success
     */
    wallet(walletId: string): Promise<WalletEntity> {
        let url_ = this.baseUrl + "/api/wallet/{walletId}";
        if (walletId === undefined || walletId === null)
            throw new Error("The parameter 'walletId' must be defined.");
        url_ = url_.replace("{walletId}", encodeURIComponent("" + walletId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWallet(_response);
        });
    }

    protected processWallet(response: Response): Promise<WalletEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WalletEntity>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    block2(body?: BlockWalletCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/wallet/block";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBlock2(_response);
        });
    }

    protected processBlock2(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    start3(body?: StartWorkSessionCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/work-session/start";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStart3(_response);
        });
    }

    protected processStart3(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submit(body?: SubmitWorkSessionCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/work-session/submit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubmit(_response);
        });
    }

    protected processSubmit(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    end2(body?: EndWorkSessionCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/work-session/end";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnd2(_response);
        });
    }

    protected processEnd2(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approve2(body?: ApproveWorkSessionCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/work-session/approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApprove2(_response);
        });
    }

    protected processApprove2(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    react2(body?: ReactToWorkSessionCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/work-session/react";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReact2(_response);
        });
    }

    protected processReact2(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return Success
     */
    workSession(id: string): Promise<WorkSessionEntity> {
        let url_ = this.baseUrl + "/api/work-session/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWorkSession(_response);
        });
    }

    protected processWorkSession(response: Response): Promise<WorkSessionEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkSessionEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkSessionEntity>(null as any);
    }

    /**
     * @param contractId (optional) 
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    list11(contractId?: string | undefined, start?: number | undefined, end?: number | undefined): Promise<WorkSessionEntity[]> {
        let url_ = this.baseUrl + "/api/work-session/list?";
        if (contractId === null)
            throw new Error("The parameter 'contractId' cannot be null.");
        else if (contractId !== undefined)
            url_ += "contractId=" + encodeURIComponent("" + contractId) + "&";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent("" + end) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList11(_response);
        });
    }

    protected processList11(response: Response): Promise<WorkSessionEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkSessionEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkSessionEntity[]>(null as any);
    }
}

export class AcceptDisputeCommand implements IAcceptDisputeCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    disputeId?: string;

    constructor(data?: IAcceptDisputeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.disputeId = _data["disputeId"];
        }
    }

    static fromJS(data: any): AcceptDisputeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptDisputeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["disputeId"] = this.disputeId;
        return data;
    }
}

export interface IAcceptDisputeCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    disputeId?: string;
}

export class AddPortfolioProjectCommand implements IAddPortfolioProjectCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    name?: string | undefined;
    userRole?: string | undefined;
    skills?: string[] | undefined;
    description?: string | undefined;
    files?: CreateFileDto[] | undefined;

    constructor(data?: IAddPortfolioProjectCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.userRole = _data["userRole"];
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(item);
            }
            this.description = _data["description"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(CreateFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddPortfolioProjectCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddPortfolioProjectCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["userRole"] = this.userRole;
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item);
        }
        data["description"] = this.description;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAddPortfolioProjectCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    name?: string | undefined;
    userRole?: string | undefined;
    skills?: string[] | undefined;
    description?: string | undefined;
    files?: CreateFileDto[] | undefined;
}

export class ApproveContestCommand implements IApproveContestCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contestId?: string;

    constructor(data?: IApproveContestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contestId = _data["contestId"];
        }
    }

    static fromJS(data: any): ApproveContestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveContestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contestId"] = this.contestId;
        return data;
    }
}

export interface IApproveContestCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contestId?: string;
}

export class ApproveWorkSessionCommand implements IApproveWorkSessionCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    sessionId?: string;

    constructor(data?: IApproveWorkSessionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.sessionId = _data["sessionId"];
        }
    }

    static fromJS(data: any): ApproveWorkSessionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveWorkSessionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["sessionId"] = this.sessionId;
        return data;
    }
}

export interface IApproveWorkSessionCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    sessionId?: string;
}

export class Assembly implements IAssembly {
    readonly definedTypes?: TypeInfo[] | undefined;
    readonly exportedTypes?: Type[] | undefined;
    readonly codeBase?: string | undefined;
    entryPoint?: MethodInfo;
    readonly fullName?: string | undefined;
    readonly imageRuntimeVersion?: string | undefined;
    readonly isDynamic?: boolean;
    readonly location?: string | undefined;
    readonly reflectionOnly?: boolean;
    readonly isCollectible?: boolean;
    readonly isFullyTrusted?: boolean;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly escapedCodeBase?: string | undefined;
    manifestModule?: Module;
    readonly modules?: Module[] | undefined;
    readonly globalAssemblyCache?: boolean;
    readonly hostContext?: number;
    readonly securityRuleSet?: AssemblySecurityRuleSet;

    constructor(data?: IAssembly) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["definedTypes"])) {
                (<any>this).definedTypes = [] as any;
                for (let item of _data["definedTypes"])
                    (<any>this).definedTypes!.push(TypeInfo.fromJS(item));
            }
            if (Array.isArray(_data["exportedTypes"])) {
                (<any>this).exportedTypes = [] as any;
                for (let item of _data["exportedTypes"])
                    (<any>this).exportedTypes!.push(Type.fromJS(item));
            }
            (<any>this).codeBase = _data["codeBase"];
            this.entryPoint = _data["entryPoint"] ? MethodInfo.fromJS(_data["entryPoint"]) : <any>undefined;
            (<any>this).fullName = _data["fullName"];
            (<any>this).imageRuntimeVersion = _data["imageRuntimeVersion"];
            (<any>this).isDynamic = _data["isDynamic"];
            (<any>this).location = _data["location"];
            (<any>this).reflectionOnly = _data["reflectionOnly"];
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).isFullyTrusted = _data["isFullyTrusted"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).escapedCodeBase = _data["escapedCodeBase"];
            this.manifestModule = _data["manifestModule"] ? Module.fromJS(_data["manifestModule"]) : <any>undefined;
            if (Array.isArray(_data["modules"])) {
                (<any>this).modules = [] as any;
                for (let item of _data["modules"])
                    (<any>this).modules!.push(Module.fromJS(item));
            }
            (<any>this).globalAssemblyCache = _data["globalAssemblyCache"];
            (<any>this).hostContext = _data["hostContext"];
            (<any>this).securityRuleSet = _data["securityRuleSet"];
        }
    }

    static fromJS(data: any): Assembly {
        data = typeof data === 'object' ? data : {};
        let result = new Assembly();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.definedTypes)) {
            data["definedTypes"] = [];
            for (let item of this.definedTypes)
                data["definedTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.exportedTypes)) {
            data["exportedTypes"] = [];
            for (let item of this.exportedTypes)
                data["exportedTypes"].push(item.toJSON());
        }
        data["codeBase"] = this.codeBase;
        data["entryPoint"] = this.entryPoint ? this.entryPoint.toJSON() : <any>undefined;
        data["fullName"] = this.fullName;
        data["imageRuntimeVersion"] = this.imageRuntimeVersion;
        data["isDynamic"] = this.isDynamic;
        data["location"] = this.location;
        data["reflectionOnly"] = this.reflectionOnly;
        data["isCollectible"] = this.isCollectible;
        data["isFullyTrusted"] = this.isFullyTrusted;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["escapedCodeBase"] = this.escapedCodeBase;
        data["manifestModule"] = this.manifestModule ? this.manifestModule.toJSON() : <any>undefined;
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        data["globalAssemblyCache"] = this.globalAssemblyCache;
        data["hostContext"] = this.hostContext;
        data["securityRuleSet"] = this.securityRuleSet;
        return data;
    }
}

export interface IAssembly {
    definedTypes?: TypeInfo[] | undefined;
    exportedTypes?: Type[] | undefined;
    codeBase?: string | undefined;
    entryPoint?: MethodInfo;
    fullName?: string | undefined;
    imageRuntimeVersion?: string | undefined;
    isDynamic?: boolean;
    location?: string | undefined;
    reflectionOnly?: boolean;
    isCollectible?: boolean;
    isFullyTrusted?: boolean;
    customAttributes?: CustomAttributeData[] | undefined;
    escapedCodeBase?: string | undefined;
    manifestModule?: Module;
    modules?: Module[] | undefined;
    globalAssemblyCache?: boolean;
    hostContext?: number;
    securityRuleSet?: AssemblySecurityRuleSet;
}

export class BalanceOperationCommand implements IBalanceOperationCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    readonly walletId!: string;
    balance!: Money;
    readonly balanceOperationType?: BalanceOperationCommandBalanceOperationType;

    constructor(data?: IBalanceOperationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.balance = new Money();
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            (<any>this).walletId = _data["walletId"];
            this.balance = _data["balance"] ? Money.fromJS(_data["balance"]) : new Money();
            (<any>this).balanceOperationType = _data["balanceOperationType"];
        }
    }

    static fromJS(data: any): BalanceOperationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceOperationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["walletId"] = this.walletId;
        data["balance"] = this.balance ? this.balance.toJSON() : <any>undefined;
        data["balanceOperationType"] = this.balanceOperationType;
        return data;
    }
}

export interface IBalanceOperationCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    walletId: string;
    balance: Money;
    balanceOperationType?: BalanceOperationCommandBalanceOperationType;
}

export class BlockWalletCommand implements IBlockWalletCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    walletId!: string;
    reason!: BlockWalletCommandReason;

    constructor(data?: IBlockWalletCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.walletId = _data["walletId"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): BlockWalletCommand {
        data = typeof data === 'object' ? data : {};
        let result = new BlockWalletCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["walletId"] = this.walletId;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IBlockWalletCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    walletId: string;
    reason: BlockWalletCommandReason;
}

export class BookmarkJobCommand implements IBookmarkJobCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    jobId?: string;

    constructor(data?: IBookmarkJobCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.jobId = _data["jobId"];
        }
    }

    static fromJS(data: any): BookmarkJobCommand {
        data = typeof data === 'object' ? data : {};
        let result = new BookmarkJobCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["jobId"] = this.jobId;
        return data;
    }
}

export interface IBookmarkJobCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    jobId?: string;
}

export class CategoryEntity implements ICategoryEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name?: string | undefined;
    slug?: string | undefined;
    parentCategoryId?: string | undefined;
    parentCategory?: CategoryEntity;
    subCategories?: CategoryEntity[] | undefined;

    constructor(data?: ICategoryEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.parentCategory = _data["parentCategory"] ? CategoryEntity.fromJS(_data["parentCategory"]) : <any>undefined;
            if (Array.isArray(_data["subCategories"])) {
                this.subCategories = [] as any;
                for (let item of _data["subCategories"])
                    this.subCategories!.push(CategoryEntity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategoryEntity {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["parentCategoryId"] = this.parentCategoryId;
        data["parentCategory"] = this.parentCategory ? this.parentCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.subCategories)) {
            data["subCategories"] = [];
            for (let item of this.subCategories)
                data["subCategories"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICategoryEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name?: string | undefined;
    slug?: string | undefined;
    parentCategoryId?: string | undefined;
    parentCategory?: CategoryEntity;
    subCategories?: CategoryEntity[] | undefined;
}

export class ClientAcceptFinishContractCommand implements IClientAcceptFinishContractCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    readonly contractId?: string;

    constructor(data?: IClientAcceptFinishContractCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            (<any>this).contractId = _data["contractId"];
        }
    }

    static fromJS(data: any): ClientAcceptFinishContractCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ClientAcceptFinishContractCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contractId"] = this.contractId;
        return data;
    }
}

export interface IClientAcceptFinishContractCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contractId?: string;
}

export class ClientCloseContractCommand implements IClientCloseContractCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contractId?: string;
    reason?: string | undefined;

    constructor(data?: IClientCloseContractCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contractId = _data["contractId"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): ClientCloseContractCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ClientCloseContractCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contractId"] = this.contractId;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IClientCloseContractCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contractId?: string;
    reason?: string | undefined;
}

export class ClientJobInfo implements IClientJobInfo {
    userId?: string;
    name?: string | undefined;
    avatar?: FileEntity;
    isVerified?: boolean;
    activeJobs?: number;
    closedJobs?: number;
    arbitrationJobs?: number;
    activeContracts?: number;
    completedContracts?: number;
    arbitrationContracts?: number;
    registeredAt?: string | undefined;
    lastActiveAt?: string | undefined;
    isPhoneVerified?: boolean;
    hasPremium?: boolean;

    constructor(data?: IClientJobInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.avatar = _data["avatar"] ? FileEntity.fromJS(_data["avatar"]) : <any>undefined;
            this.isVerified = _data["isVerified"];
            this.activeJobs = _data["activeJobs"];
            this.closedJobs = _data["closedJobs"];
            this.arbitrationJobs = _data["arbitrationJobs"];
            this.activeContracts = _data["activeContracts"];
            this.completedContracts = _data["completedContracts"];
            this.arbitrationContracts = _data["arbitrationContracts"];
            this.registeredAt = _data["registeredAt"];
            this.lastActiveAt = _data["lastActiveAt"];
            this.isPhoneVerified = _data["isPhoneVerified"];
            this.hasPremium = _data["hasPremium"];
        }
    }

    static fromJS(data: any): ClientJobInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ClientJobInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["avatar"] = this.avatar ? this.avatar.toJSON() : <any>undefined;
        data["isVerified"] = this.isVerified;
        data["activeJobs"] = this.activeJobs;
        data["closedJobs"] = this.closedJobs;
        data["arbitrationJobs"] = this.arbitrationJobs;
        data["activeContracts"] = this.activeContracts;
        data["completedContracts"] = this.completedContracts;
        data["arbitrationContracts"] = this.arbitrationContracts;
        data["registeredAt"] = this.registeredAt;
        data["lastActiveAt"] = this.lastActiveAt;
        data["isPhoneVerified"] = this.isPhoneVerified;
        data["hasPremium"] = this.hasPremium;
        return data;
    }
}

export interface IClientJobInfo {
    userId?: string;
    name?: string | undefined;
    avatar?: FileEntity;
    isVerified?: boolean;
    activeJobs?: number;
    closedJobs?: number;
    arbitrationJobs?: number;
    activeContracts?: number;
    completedContracts?: number;
    arbitrationContracts?: number;
    registeredAt?: string | undefined;
    lastActiveAt?: string | undefined;
    isPhoneVerified?: boolean;
    hasPremium?: boolean;
}

export class ClientRejectContractCompletionCommand implements IClientRejectContractCompletionCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contractId?: string;
    reason?: string | undefined;

    constructor(data?: IClientRejectContractCompletionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contractId = _data["contractId"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): ClientRejectContractCompletionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ClientRejectContractCompletionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contractId"] = this.contractId;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IClientRejectContractCompletionCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contractId?: string;
    reason?: string | undefined;
}

export class CommandResult implements ICommandResult {
    readonly message?: string | undefined;
    readonly id?: string | undefined;
    readonly ids?: string[] | undefined;
    readonly status?: CommandResultStatus;
    readonly isSuccess?: boolean;

    constructor(data?: ICommandResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).message = _data["message"];
            (<any>this).id = _data["id"];
            if (Array.isArray(_data["ids"])) {
                (<any>this).ids = [] as any;
                for (let item of _data["ids"])
                    (<any>this).ids!.push(item);
            }
            (<any>this).status = _data["status"];
            (<any>this).isSuccess = _data["isSuccess"];
        }
    }

    static fromJS(data: any): CommandResult {
        data = typeof data === 'object' ? data : {};
        let result = new CommandResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["id"] = this.id;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["status"] = this.status;
        data["isSuccess"] = this.isSuccess;
        return data;
    }
}

export interface ICommandResult {
    message?: string | undefined;
    id?: string | undefined;
    ids?: string[] | undefined;
    status?: CommandResultStatus;
    isSuccess?: boolean;
}

export class CompleteTaskCommand implements ICompleteTaskCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    taskId?: string;

    constructor(data?: ICompleteTaskCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.taskId = _data["taskId"];
        }
    }

    static fromJS(data: any): CompleteTaskCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteTaskCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["taskId"] = this.taskId;
        return data;
    }
}

export interface ICompleteTaskCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    taskId?: string;
}

export class ConstructorInfo implements IConstructorInfo {
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    readonly attributes?: ConstructorInfoAttributes;
    readonly methodImplementationFlags?: ConstructorInfoMethodImplementationFlags;
    readonly callingConvention?: ConstructorInfoCallingConvention;
    readonly isAbstract?: boolean;
    readonly isConstructor?: boolean;
    readonly isFinal?: boolean;
    readonly isHideBySig?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isVirtual?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isConstructedGenericMethod?: boolean;
    readonly isGenericMethod?: boolean;
    readonly isGenericMethodDefinition?: boolean;
    readonly containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    readonly memberType?: ConstructorInfoMemberType;

    constructor(data?: IConstructorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
            (<any>this).attributes = _data["attributes"];
            (<any>this).methodImplementationFlags = _data["methodImplementationFlags"];
            (<any>this).callingConvention = _data["callingConvention"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isConstructor = _data["isConstructor"];
            (<any>this).isFinal = _data["isFinal"];
            (<any>this).isHideBySig = _data["isHideBySig"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isVirtual = _data["isVirtual"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isConstructedGenericMethod = _data["isConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["isGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["isGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            this.methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            (<any>this).memberType = _data["memberType"];
        }
    }

    static fromJS(data: any): ConstructorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ConstructorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        data["attributes"] = this.attributes;
        data["methodImplementationFlags"] = this.methodImplementationFlags;
        data["callingConvention"] = this.callingConvention;
        data["isAbstract"] = this.isAbstract;
        data["isConstructor"] = this.isConstructor;
        data["isFinal"] = this.isFinal;
        data["isHideBySig"] = this.isHideBySig;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isVirtual"] = this.isVirtual;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["isGenericMethod"] = this.isGenericMethod;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["memberType"] = this.memberType;
        return data;
    }
}

export interface IConstructorInfo {
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
    attributes?: ConstructorInfoAttributes;
    methodImplementationFlags?: ConstructorInfoMethodImplementationFlags;
    callingConvention?: ConstructorInfoCallingConvention;
    isAbstract?: boolean;
    isConstructor?: boolean;
    isFinal?: boolean;
    isHideBySig?: boolean;
    isSpecialName?: boolean;
    isStatic?: boolean;
    isVirtual?: boolean;
    isAssembly?: boolean;
    isFamily?: boolean;
    isFamilyAndAssembly?: boolean;
    isFamilyOrAssembly?: boolean;
    isPrivate?: boolean;
    isPublic?: boolean;
    isConstructedGenericMethod?: boolean;
    isGenericMethod?: boolean;
    isGenericMethodDefinition?: boolean;
    containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    memberType?: ConstructorInfoMemberType;
}

export class ContestEntity implements IContestEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    employerId?: string;
    employer?: UserEntity;
    title?: string | undefined;
    description?: string | undefined;
    prizePool?: Money;
    startDate?: Date;
    endDate?: Date | undefined;
    status?: ContestEntityStatus;
    winnerEntryId?: string | undefined;
    isResultPublic?: boolean;
    isEntriesPublic?: boolean;
    files?: FileEntity[] | undefined;

    constructor(data?: IContestEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.employerId = _data["employerId"];
            this.employer = _data["employer"] ? UserEntity.fromJS(_data["employer"]) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            this.prizePool = _data["prizePool"] ? Money.fromJS(_data["prizePool"]) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.winnerEntryId = _data["winnerEntryId"];
            this.isResultPublic = _data["isResultPublic"];
            this.isEntriesPublic = _data["isEntriesPublic"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(FileEntity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContestEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ContestEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["employerId"] = this.employerId;
        data["employer"] = this.employer ? this.employer.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["prizePool"] = this.prizePool ? this.prizePool.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["winnerEntryId"] = this.winnerEntryId;
        data["isResultPublic"] = this.isResultPublic;
        data["isEntriesPublic"] = this.isEntriesPublic;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContestEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    employerId?: string;
    employer?: UserEntity;
    title?: string | undefined;
    description?: string | undefined;
    prizePool?: Money;
    startDate?: Date;
    endDate?: Date | undefined;
    status?: ContestEntityStatus;
    winnerEntryId?: string | undefined;
    isResultPublic?: boolean;
    isEntriesPublic?: boolean;
    files?: FileEntity[] | undefined;
}

export class ContractEntity implements IContractEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    freelancerId?: string;
    freelancer?: UserEntity;
    employerId?: string;
    employer?: UserEntity;
    startDate?: Date;
    endDate?: Date | undefined;
    budget?: Money;
    status?: ContractEntityStatus;
    costPerHour?: Money;
    budgetType?: ContractEntityBudgetType;
    tasks?: TaskEntity[] | undefined;
    workSessions?: WorkSessionEntity[] | undefined;
    readonly totalWorkSessions?: number;
    readonly totalHoursWorked?: number;
    remainingBudget?: Money;
    paymentSchedule?: ContractEntityPaymentSchedule;
    isPaused?: boolean;
    pauseReason?: string | undefined;
    contractTerms?: string | undefined;
    bonus?: number | undefined;
    disputeId?: string | undefined;

    constructor(data?: IContractEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.freelancerId = _data["freelancerId"];
            this.freelancer = _data["freelancer"] ? UserEntity.fromJS(_data["freelancer"]) : <any>undefined;
            this.employerId = _data["employerId"];
            this.employer = _data["employer"] ? UserEntity.fromJS(_data["employer"]) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.budget = _data["budget"] ? Money.fromJS(_data["budget"]) : <any>undefined;
            this.status = _data["status"];
            this.costPerHour = _data["costPerHour"] ? Money.fromJS(_data["costPerHour"]) : <any>undefined;
            this.budgetType = _data["budgetType"];
            if (Array.isArray(_data["tasks"])) {
                this.tasks = [] as any;
                for (let item of _data["tasks"])
                    this.tasks!.push(TaskEntity.fromJS(item));
            }
            if (Array.isArray(_data["workSessions"])) {
                this.workSessions = [] as any;
                for (let item of _data["workSessions"])
                    this.workSessions!.push(WorkSessionEntity.fromJS(item));
            }
            (<any>this).totalWorkSessions = _data["totalWorkSessions"];
            (<any>this).totalHoursWorked = _data["totalHoursWorked"];
            this.remainingBudget = _data["remainingBudget"] ? Money.fromJS(_data["remainingBudget"]) : <any>undefined;
            this.paymentSchedule = _data["paymentSchedule"];
            this.isPaused = _data["isPaused"];
            this.pauseReason = _data["pauseReason"];
            this.contractTerms = _data["contractTerms"];
            this.bonus = _data["bonus"];
            this.disputeId = _data["disputeId"];
        }
    }

    static fromJS(data: any): ContractEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ContractEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["freelancerId"] = this.freelancerId;
        data["freelancer"] = this.freelancer ? this.freelancer.toJSON() : <any>undefined;
        data["employerId"] = this.employerId;
        data["employer"] = this.employer ? this.employer.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["budget"] = this.budget ? this.budget.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["costPerHour"] = this.costPerHour ? this.costPerHour.toJSON() : <any>undefined;
        data["budgetType"] = this.budgetType;
        if (Array.isArray(this.tasks)) {
            data["tasks"] = [];
            for (let item of this.tasks)
                data["tasks"].push(item.toJSON());
        }
        if (Array.isArray(this.workSessions)) {
            data["workSessions"] = [];
            for (let item of this.workSessions)
                data["workSessions"].push(item.toJSON());
        }
        data["totalWorkSessions"] = this.totalWorkSessions;
        data["totalHoursWorked"] = this.totalHoursWorked;
        data["remainingBudget"] = this.remainingBudget ? this.remainingBudget.toJSON() : <any>undefined;
        data["paymentSchedule"] = this.paymentSchedule;
        data["isPaused"] = this.isPaused;
        data["pauseReason"] = this.pauseReason;
        data["contractTerms"] = this.contractTerms;
        data["bonus"] = this.bonus;
        data["disputeId"] = this.disputeId;
        return data;
    }
}

export interface IContractEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    freelancerId?: string;
    freelancer?: UserEntity;
    employerId?: string;
    employer?: UserEntity;
    startDate?: Date;
    endDate?: Date | undefined;
    budget?: Money;
    status?: ContractEntityStatus;
    costPerHour?: Money;
    budgetType?: ContractEntityBudgetType;
    tasks?: TaskEntity[] | undefined;
    workSessions?: WorkSessionEntity[] | undefined;
    totalWorkSessions?: number;
    totalHoursWorked?: number;
    remainingBudget?: Money;
    paymentSchedule?: ContractEntityPaymentSchedule;
    isPaused?: boolean;
    pauseReason?: string | undefined;
    contractTerms?: string | undefined;
    bonus?: number | undefined;
    disputeId?: string | undefined;
}

export class CreateCategoryCommand implements ICreateCategoryCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    name?: string | undefined;
    slug?: string | undefined;
    tags?: string | undefined;
    parentCategoryId?: string | undefined;

    constructor(data?: ICreateCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.tags = _data["tags"];
            this.parentCategoryId = _data["parentCategoryId"];
        }
    }

    static fromJS(data: any): CreateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["tags"] = this.tags;
        data["parentCategoryId"] = this.parentCategoryId;
        return data;
    }
}

export interface ICreateCategoryCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    name?: string | undefined;
    slug?: string | undefined;
    tags?: string | undefined;
    parentCategoryId?: string | undefined;
}

export class CreateClientProfileCommand implements ICreateClientProfileCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    companyName?: string | undefined;
    companyDescription?: string | undefined;
    companyWebsite?: string | undefined;
    location?: string | undefined;
    companyLogo?: CreateFileDto;
    employerType?: CreateClientProfileCommandEmployerType;
    phoneNumber?: string | undefined;

    constructor(data?: ICreateClientProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.companyName = _data["companyName"];
            this.companyDescription = _data["companyDescription"];
            this.companyWebsite = _data["companyWebsite"];
            this.location = _data["location"];
            this.companyLogo = _data["companyLogo"] ? CreateFileDto.fromJS(_data["companyLogo"]) : <any>undefined;
            this.employerType = _data["employerType"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): CreateClientProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClientProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["companyName"] = this.companyName;
        data["companyDescription"] = this.companyDescription;
        data["companyWebsite"] = this.companyWebsite;
        data["location"] = this.location;
        data["companyLogo"] = this.companyLogo ? this.companyLogo.toJSON() : <any>undefined;
        data["employerType"] = this.employerType;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface ICreateClientProfileCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    companyName?: string | undefined;
    companyDescription?: string | undefined;
    companyWebsite?: string | undefined;
    location?: string | undefined;
    companyLogo?: CreateFileDto;
    employerType?: CreateClientProfileCommandEmployerType;
    phoneNumber?: string | undefined;
}

export class CreateContestCommand implements ICreateContestCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    title!: string;
    description!: string;
    prizePool!: number;
    isResultPublic?: boolean;

    constructor(data?: ICreateContestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            this.prizePool = _data["prizePool"];
            this.isResultPublic = _data["isResultPublic"];
        }
    }

    static fromJS(data: any): CreateContestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["prizePool"] = this.prizePool;
        data["isResultPublic"] = this.isResultPublic;
        return data;
    }
}

export interface ICreateContestCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    title: string;
    description: string;
    prizePool: number;
    isResultPublic?: boolean;
}

export class CreateContractCommand implements ICreateContractCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    freelancerId?: string;
    jobId?: string;
    budget?: number | undefined;
    costPerHour?: number | undefined;
    budgetType?: CreateContractCommandBudgetType;
    paymentSchedule?: CreateContractCommandPaymentSchedule;
    contractTerms?: string | undefined;
    endDate?: Date | undefined;

    constructor(data?: ICreateContractCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.freelancerId = _data["freelancerId"];
            this.jobId = _data["jobId"];
            this.budget = _data["budget"];
            this.costPerHour = _data["costPerHour"];
            this.budgetType = _data["budgetType"];
            this.paymentSchedule = _data["paymentSchedule"];
            this.contractTerms = _data["contractTerms"];
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateContractCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContractCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["freelancerId"] = this.freelancerId;
        data["jobId"] = this.jobId;
        data["budget"] = this.budget;
        data["costPerHour"] = this.costPerHour;
        data["budgetType"] = this.budgetType;
        data["paymentSchedule"] = this.paymentSchedule;
        data["contractTerms"] = this.contractTerms;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICreateContractCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    freelancerId?: string;
    jobId?: string;
    budget?: number | undefined;
    costPerHour?: number | undefined;
    budgetType?: CreateContractCommandBudgetType;
    paymentSchedule?: CreateContractCommandPaymentSchedule;
    contractTerms?: string | undefined;
    endDate?: Date | undefined;
}

export class CreateFileDto implements ICreateFileDto {
    downloadUrl?: string | undefined;
    fileId?: string | undefined;
    name?: string | undefined;
    mimeType?: string | undefined;
    stream?: string;

    constructor(data?: ICreateFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.downloadUrl = _data["downloadUrl"];
            this.fileId = _data["fileId"];
            this.name = _data["name"];
            this.mimeType = _data["mimeType"];
            this.stream = _data["stream"];
        }
    }

    static fromJS(data: any): CreateFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["downloadUrl"] = this.downloadUrl;
        data["fileId"] = this.fileId;
        data["name"] = this.name;
        data["mimeType"] = this.mimeType;
        data["stream"] = this.stream;
        return data;
    }
}

export interface ICreateFileDto {
    downloadUrl?: string | undefined;
    fileId?: string | undefined;
    name?: string | undefined;
    mimeType?: string | undefined;
    stream?: string;
}

export class CreateFreelancerProfileCommand implements ICreateFreelancerProfileCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    experience?: string | undefined;
    hourlyRate?: number;
    resume?: string | undefined;

    constructor(data?: ICreateFreelancerProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.experience = _data["experience"];
            this.hourlyRate = _data["hourlyRate"];
            this.resume = _data["resume"];
        }
    }

    static fromJS(data: any): CreateFreelancerProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFreelancerProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["experience"] = this.experience;
        data["hourlyRate"] = this.hourlyRate;
        data["resume"] = this.resume;
        return data;
    }
}

export interface ICreateFreelancerProfileCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    experience?: string | undefined;
    hourlyRate?: number;
    resume?: string | undefined;
}

export class CreateFreelancerTeamCommand implements ICreateFreelancerTeamCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICreateFreelancerTeamCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateFreelancerTeamCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFreelancerTeamCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreateFreelancerTeamCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    name?: string | undefined;
    description?: string | undefined;
}

export class CreateJobCommand implements ICreateJobCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    title?: string | undefined;
    description?: string | undefined;
    requiredSkillIds?: string[] | undefined;
    categoryId?: string;
    budget?: number | undefined;
    hourlyRate?: number | undefined;
    duration?: number | undefined;
    budgetType?: CreateJobCommandBudgetType;
    level?: CreateJobCommandLevel;
    expirationDate?: Date | undefined;
    files?: CreateFileDto[] | undefined;

    constructor(data?: ICreateJobCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["requiredSkillIds"])) {
                this.requiredSkillIds = [] as any;
                for (let item of _data["requiredSkillIds"])
                    this.requiredSkillIds!.push(item);
            }
            this.categoryId = _data["categoryId"];
            this.budget = _data["budget"];
            this.hourlyRate = _data["hourlyRate"];
            this.duration = _data["duration"];
            this.budgetType = _data["budgetType"];
            this.level = _data["level"];
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(CreateFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateJobCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateJobCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.requiredSkillIds)) {
            data["requiredSkillIds"] = [];
            for (let item of this.requiredSkillIds)
                data["requiredSkillIds"].push(item);
        }
        data["categoryId"] = this.categoryId;
        data["budget"] = this.budget;
        data["hourlyRate"] = this.hourlyRate;
        data["duration"] = this.duration;
        data["budgetType"] = this.budgetType;
        data["level"] = this.level;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateJobCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    title?: string | undefined;
    description?: string | undefined;
    requiredSkillIds?: string[] | undefined;
    categoryId?: string;
    budget?: number | undefined;
    hourlyRate?: number | undefined;
    duration?: number | undefined;
    budgetType?: CreateJobCommandBudgetType;
    level?: CreateJobCommandLevel;
    expirationDate?: Date | undefined;
    files?: CreateFileDto[] | undefined;
}

export class CreateNotificationCommand implements ICreateNotificationCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    title!: string;
    text!: string;
    data!: { [key: string]: string; };
    userId?: string | undefined;
    role?: CreateNotificationCommandRole | undefined;
    type?: CreateNotificationCommandType | undefined;

    constructor(data?: ICreateNotificationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.text = _data["text"];
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
            this.userId = _data["userId"];
            this.role = _data["role"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CreateNotificationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNotificationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["text"] = this.text;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        data["userId"] = this.userId;
        data["role"] = this.role;
        data["type"] = this.type;
        return data;
    }
}

export interface ICreateNotificationCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    title: string;
    text: string;
    data: { [key: string]: string; };
    userId?: string | undefined;
    role?: CreateNotificationCommandRole | undefined;
    type?: CreateNotificationCommandType | undefined;
}

export class CreateSkillsCommand implements ICreateSkillsCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    skillNames?: string[] | undefined;

    constructor(data?: ICreateSkillsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            if (Array.isArray(_data["skillNames"])) {
                this.skillNames = [] as any;
                for (let item of _data["skillNames"])
                    this.skillNames!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateSkillsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSkillsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        if (Array.isArray(this.skillNames)) {
            data["skillNames"] = [];
            for (let item of this.skillNames)
                data["skillNames"].push(item);
        }
        return data;
    }
}

export interface ICreateSkillsCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    skillNames?: string[] | undefined;
}

export class CreateTaskCommand implements ICreateTaskCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contractId?: string;
    title?: string | undefined;
    description?: string | undefined;
    priority?: number;

    constructor(data?: ICreateTaskCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contractId = _data["contractId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.priority = _data["priority"];
        }
    }

    static fromJS(data: any): CreateTaskCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTaskCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contractId"] = this.contractId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["priority"] = this.priority;
        return data;
    }
}

export interface ICreateTaskCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contractId?: string;
    title?: string | undefined;
    description?: string | undefined;
    priority?: number;
}

export class CreateTicketDto implements ICreateTicketDto {
    subject!: string;
    text!: string;
    files?: CreateFileDto[] | undefined;
    priorityScore?: number;
    linkedDisputeId?: string | undefined;
    title?: string | undefined;

    constructor(data?: ICreateTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subject = _data["subject"];
            this.text = _data["text"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(CreateFileDto.fromJS(item));
            }
            this.priorityScore = _data["priorityScore"];
            this.linkedDisputeId = _data["linkedDisputeId"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["text"] = this.text;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["priorityScore"] = this.priorityScore;
        data["linkedDisputeId"] = this.linkedDisputeId;
        data["title"] = this.title;
        return data;
    }
}

export interface ICreateTicketDto {
    subject: string;
    text: string;
    files?: CreateFileDto[] | undefined;
    priorityScore?: number;
    linkedDisputeId?: string | undefined;
    title?: string | undefined;
}

export class CustomAttributeData implements ICustomAttributeData {
    attributeType?: Type;
    constructor_?: ConstructorInfo;
    readonly constructorArguments?: CustomAttributeTypedArgument[] | undefined;
    readonly namedArguments?: CustomAttributeNamedArgument[] | undefined;

    constructor(data?: ICustomAttributeData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributeType = _data["attributeType"] ? Type.fromJS(_data["attributeType"]) : <any>undefined;
            this.constructor_ = _data["constructor"] ? ConstructorInfo.fromJS(_data["constructor"]) : <any>undefined;
            if (Array.isArray(_data["constructorArguments"])) {
                (<any>this).constructorArguments = [] as any;
                for (let item of _data["constructorArguments"])
                    (<any>this).constructorArguments!.push(CustomAttributeTypedArgument.fromJS(item));
            }
            if (Array.isArray(_data["namedArguments"])) {
                (<any>this).namedArguments = [] as any;
                for (let item of _data["namedArguments"])
                    (<any>this).namedArguments!.push(CustomAttributeNamedArgument.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomAttributeData {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeType"] = this.attributeType ? this.attributeType.toJSON() : <any>undefined;
        data["constructor"] = this.constructor_ ? this.constructor_.toJSON() : <any>undefined;
        if (Array.isArray(this.constructorArguments)) {
            data["constructorArguments"] = [];
            for (let item of this.constructorArguments)
                data["constructorArguments"].push(item.toJSON());
        }
        if (Array.isArray(this.namedArguments)) {
            data["namedArguments"] = [];
            for (let item of this.namedArguments)
                data["namedArguments"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICustomAttributeData {
    attributeType?: Type;
    constructor_?: ConstructorInfo;
    constructorArguments?: CustomAttributeTypedArgument[] | undefined;
    namedArguments?: CustomAttributeNamedArgument[] | undefined;
}

export class CustomAttributeNamedArgument implements ICustomAttributeNamedArgument {
    memberInfo?: MemberInfo;
    typedValue?: CustomAttributeTypedArgument;
    readonly memberName?: string | undefined;
    readonly isField?: boolean;

    constructor(data?: ICustomAttributeNamedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberInfo = _data["memberInfo"] ? MemberInfo.fromJS(_data["memberInfo"]) : <any>undefined;
            this.typedValue = _data["typedValue"] ? CustomAttributeTypedArgument.fromJS(_data["typedValue"]) : <any>undefined;
            (<any>this).memberName = _data["memberName"];
            (<any>this).isField = _data["isField"];
        }
    }

    static fromJS(data: any): CustomAttributeNamedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeNamedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberInfo"] = this.memberInfo ? this.memberInfo.toJSON() : <any>undefined;
        data["typedValue"] = this.typedValue ? this.typedValue.toJSON() : <any>undefined;
        data["memberName"] = this.memberName;
        data["isField"] = this.isField;
        return data;
    }
}

export interface ICustomAttributeNamedArgument {
    memberInfo?: MemberInfo;
    typedValue?: CustomAttributeTypedArgument;
    memberName?: string | undefined;
    isField?: boolean;
}

export class CustomAttributeTypedArgument implements ICustomAttributeTypedArgument {
    argumentType?: Type;
    value?: any | undefined;

    constructor(data?: ICustomAttributeTypedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.argumentType = _data["argumentType"] ? Type.fromJS(_data["argumentType"]) : <any>undefined;
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CustomAttributeTypedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeTypedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["argumentType"] = this.argumentType ? this.argumentType.toJSON() : <any>undefined;
        data["value"] = this.value;
        return data;
    }
}

export interface ICustomAttributeTypedArgument {
    argumentType?: Type;
    value?: any | undefined;
}

export class DeleteContestCommand implements IDeleteContestCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contestId?: string;

    constructor(data?: IDeleteContestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contestId = _data["contestId"];
        }
    }

    static fromJS(data: any): DeleteContestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteContestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contestId"] = this.contestId;
        return data;
    }
}

export interface IDeleteContestCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contestId?: string;
}

export class DeleteContestEntryCommand implements IDeleteContestEntryCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contestEntryId?: string;

    constructor(data?: IDeleteContestEntryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contestEntryId = _data["contestEntryId"];
        }
    }

    static fromJS(data: any): DeleteContestEntryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteContestEntryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contestEntryId"] = this.contestEntryId;
        return data;
    }
}

export interface IDeleteContestEntryCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contestEntryId?: string;
}

export class DeleteFreelancerTeamCommand implements IDeleteFreelancerTeamCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    teamId?: string;

    constructor(data?: IDeleteFreelancerTeamCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.teamId = _data["teamId"];
        }
    }

    static fromJS(data: any): DeleteFreelancerTeamCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteFreelancerTeamCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["teamId"] = this.teamId;
        return data;
    }
}

export interface IDeleteFreelancerTeamCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    teamId?: string;
}

export class DeleteJobCommand implements IDeleteJobCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    jobId?: string;

    constructor(data?: IDeleteJobCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.jobId = _data["jobId"];
        }
    }

    static fromJS(data: any): DeleteJobCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteJobCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["jobId"] = this.jobId;
        return data;
    }
}

export interface IDeleteJobCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    jobId?: string;
}

export class DeletePortfolioProjectCommand implements IDeletePortfolioProjectCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    projectId?: string;

    constructor(data?: IDeletePortfolioProjectCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): DeletePortfolioProjectCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeletePortfolioProjectCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["projectId"] = this.projectId;
        return data;
    }
}

export interface IDeletePortfolioProjectCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    projectId?: string;
}

export class DeleteSkillsCommand implements IDeleteSkillsCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    skillIds?: string[] | undefined;
    skillNames?: string[] | undefined;

    constructor(data?: IDeleteSkillsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            if (Array.isArray(_data["skillIds"])) {
                this.skillIds = [] as any;
                for (let item of _data["skillIds"])
                    this.skillIds!.push(item);
            }
            if (Array.isArray(_data["skillNames"])) {
                this.skillNames = [] as any;
                for (let item of _data["skillNames"])
                    this.skillNames!.push(item);
            }
        }
    }

    static fromJS(data: any): DeleteSkillsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteSkillsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        if (Array.isArray(this.skillIds)) {
            data["skillIds"] = [];
            for (let item of this.skillIds)
                data["skillIds"].push(item);
        }
        if (Array.isArray(this.skillNames)) {
            data["skillNames"] = [];
            for (let item of this.skillNames)
                data["skillNames"].push(item);
        }
        return data;
    }
}

export interface IDeleteSkillsCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    skillIds?: string[] | undefined;
    skillNames?: string[] | undefined;
}

export class DeleteTaskCommand implements IDeleteTaskCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    taskId?: string;

    constructor(data?: IDeleteTaskCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.taskId = _data["taskId"];
        }
    }

    static fromJS(data: any): DeleteTaskCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteTaskCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["taskId"] = this.taskId;
        return data;
    }
}

export interface IDeleteTaskCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    taskId?: string;
}

export class EndContestCommand implements IEndContestCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contestId?: string;

    constructor(data?: IEndContestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contestId = _data["contestId"];
        }
    }

    static fromJS(data: any): EndContestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EndContestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contestId"] = this.contestId;
        return data;
    }
}

export interface IEndContestCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contestId?: string;
}

export class EndWorkSessionCommand implements IEndWorkSessionCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    sessionId?: string;
    selectedFiles?: CreateFileDto[] | undefined;

    constructor(data?: IEndWorkSessionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.sessionId = _data["sessionId"];
            if (Array.isArray(_data["selectedFiles"])) {
                this.selectedFiles = [] as any;
                for (let item of _data["selectedFiles"])
                    this.selectedFiles!.push(CreateFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EndWorkSessionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EndWorkSessionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["sessionId"] = this.sessionId;
        if (Array.isArray(this.selectedFiles)) {
            data["selectedFiles"] = [];
            for (let item of this.selectedFiles)
                data["selectedFiles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEndWorkSessionCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    sessionId?: string;
    selectedFiles?: CreateFileDto[] | undefined;
}

export class EventInfo implements IEventInfo {
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    readonly memberType?: EventInfoMemberType;
    readonly attributes?: EventInfoAttributes;
    readonly isSpecialName?: boolean;
    addMethod?: MethodInfo;
    removeMethod?: MethodInfo;
    raiseMethod?: MethodInfo;
    readonly isMulticast?: boolean;
    eventHandlerType?: Type;

    constructor(data?: IEventInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
            (<any>this).memberType = _data["memberType"];
            (<any>this).attributes = _data["attributes"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            this.addMethod = _data["addMethod"] ? MethodInfo.fromJS(_data["addMethod"]) : <any>undefined;
            this.removeMethod = _data["removeMethod"] ? MethodInfo.fromJS(_data["removeMethod"]) : <any>undefined;
            this.raiseMethod = _data["raiseMethod"] ? MethodInfo.fromJS(_data["raiseMethod"]) : <any>undefined;
            (<any>this).isMulticast = _data["isMulticast"];
            this.eventHandlerType = _data["eventHandlerType"] ? Type.fromJS(_data["eventHandlerType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EventInfo {
        data = typeof data === 'object' ? data : {};
        let result = new EventInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        data["memberType"] = this.memberType;
        data["attributes"] = this.attributes;
        data["isSpecialName"] = this.isSpecialName;
        data["addMethod"] = this.addMethod ? this.addMethod.toJSON() : <any>undefined;
        data["removeMethod"] = this.removeMethod ? this.removeMethod.toJSON() : <any>undefined;
        data["raiseMethod"] = this.raiseMethod ? this.raiseMethod.toJSON() : <any>undefined;
        data["isMulticast"] = this.isMulticast;
        data["eventHandlerType"] = this.eventHandlerType ? this.eventHandlerType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEventInfo {
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
    memberType?: EventInfoMemberType;
    attributes?: EventInfoAttributes;
    isSpecialName?: boolean;
    addMethod?: MethodInfo;
    removeMethod?: MethodInfo;
    raiseMethod?: MethodInfo;
    isMulticast?: boolean;
    eventHandlerType?: Type;
}

export class FeeContext implements IFeeContext {
    readonly isContractCancellation?: boolean;
    readonly isAdminOverride?: boolean;

    constructor(data?: IFeeContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isContractCancellation = _data["isContractCancellation"];
            (<any>this).isAdminOverride = _data["isAdminOverride"];
        }
    }

    static fromJS(data: any): FeeContext {
        data = typeof data === 'object' ? data : {};
        let result = new FeeContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isContractCancellation"] = this.isContractCancellation;
        data["isAdminOverride"] = this.isAdminOverride;
        return data;
    }
}

export interface IFeeContext {
    isContractCancellation?: boolean;
    isAdminOverride?: boolean;
}

export class FieldInfo implements IFieldInfo {
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    readonly memberType?: FieldInfoMemberType;
    readonly attributes?: FieldInfoAttributes;
    fieldType?: Type;
    readonly isInitOnly?: boolean;
    readonly isLiteral?: boolean;
    readonly isNotSerialized?: boolean;
    readonly isPinvokeImpl?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    fieldHandle?: RuntimeFieldHandle;

    constructor(data?: IFieldInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
            (<any>this).memberType = _data["memberType"];
            (<any>this).attributes = _data["attributes"];
            this.fieldType = _data["fieldType"] ? Type.fromJS(_data["fieldType"]) : <any>undefined;
            (<any>this).isInitOnly = _data["isInitOnly"];
            (<any>this).isLiteral = _data["isLiteral"];
            (<any>this).isNotSerialized = _data["isNotSerialized"];
            (<any>this).isPinvokeImpl = _data["isPinvokeImpl"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.fieldHandle = _data["fieldHandle"] ? RuntimeFieldHandle.fromJS(_data["fieldHandle"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FieldInfo {
        data = typeof data === 'object' ? data : {};
        let result = new FieldInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        data["memberType"] = this.memberType;
        data["attributes"] = this.attributes;
        data["fieldType"] = this.fieldType ? this.fieldType.toJSON() : <any>undefined;
        data["isInitOnly"] = this.isInitOnly;
        data["isLiteral"] = this.isLiteral;
        data["isNotSerialized"] = this.isNotSerialized;
        data["isPinvokeImpl"] = this.isPinvokeImpl;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["fieldHandle"] = this.fieldHandle ? this.fieldHandle.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFieldInfo {
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
    memberType?: FieldInfoMemberType;
    attributes?: FieldInfoAttributes;
    fieldType?: Type;
    isInitOnly?: boolean;
    isLiteral?: boolean;
    isNotSerialized?: boolean;
    isPinvokeImpl?: boolean;
    isSpecialName?: boolean;
    isStatic?: boolean;
    isAssembly?: boolean;
    isFamily?: boolean;
    isFamilyAndAssembly?: boolean;
    isFamilyOrAssembly?: boolean;
    isPrivate?: boolean;
    isPublic?: boolean;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    fieldHandle?: RuntimeFieldHandle;
}

export class FileEntity implements IFileEntity {
    id!: string;
    fileName!: string;
    filePath!: string;
    mimeType!: string;
    size?: number;

    constructor(data?: IFileEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileName = _data["fileName"];
            this.filePath = _data["filePath"];
            this.mimeType = _data["mimeType"];
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): FileEntity {
        data = typeof data === 'object' ? data : {};
        let result = new FileEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileName"] = this.fileName;
        data["filePath"] = this.filePath;
        data["mimeType"] = this.mimeType;
        data["size"] = this.size;
        return data;
    }
}

export interface IFileEntity {
    id: string;
    fileName: string;
    filePath: string;
    mimeType: string;
    size?: number;
}

export class ForceContractCancelCommand implements IForceContractCancelCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contractId?: string;
    reason?: string | undefined;

    constructor(data?: IForceContractCancelCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contractId = _data["contractId"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): ForceContractCancelCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ForceContractCancelCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contractId"] = this.contractId;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IForceContractCancelCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contractId?: string;
    reason?: string | undefined;
}

export class FreelancerAcceptContractCommand implements IFreelancerAcceptContractCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contractId?: string;

    constructor(data?: IFreelancerAcceptContractCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contractId = _data["contractId"];
        }
    }

    static fromJS(data: any): FreelancerAcceptContractCommand {
        data = typeof data === 'object' ? data : {};
        let result = new FreelancerAcceptContractCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contractId"] = this.contractId;
        return data;
    }
}

export interface IFreelancerAcceptContractCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contractId?: string;
}

export class FreelancerFinishContractCommand implements IFreelancerFinishContractCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contractId?: string;

    constructor(data?: IFreelancerFinishContractCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contractId = _data["contractId"];
        }
    }

    static fromJS(data: any): FreelancerFinishContractCommand {
        data = typeof data === 'object' ? data : {};
        let result = new FreelancerFinishContractCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contractId"] = this.contractId;
        return data;
    }
}

export interface IFreelancerFinishContractCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contractId?: string;
}

export class FreelancerProfileEntity implements IFreelancerProfileEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    userId?: string;
    user?: UserEntity;
    skills?: SkillEntity[] | undefined;
    experience?: string | undefined;
    portfolioProjects?: PortfolioProjectEntity[] | undefined;
    resume?: string | undefined;
    costPerHour?: number;
    availability?: FreelancerProfileEntityAvailability;
    rating?: number;
    isHidden?: boolean;
    reviews?: JobReviewEntity[] | undefined;

    constructor(data?: IFreelancerProfileEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserEntity.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(SkillEntity.fromJS(item));
            }
            this.experience = _data["experience"];
            if (Array.isArray(_data["portfolioProjects"])) {
                this.portfolioProjects = [] as any;
                for (let item of _data["portfolioProjects"])
                    this.portfolioProjects!.push(PortfolioProjectEntity.fromJS(item));
            }
            this.resume = _data["resume"];
            this.costPerHour = _data["costPerHour"];
            this.availability = _data["availability"];
            this.rating = _data["rating"];
            this.isHidden = _data["isHidden"];
            if (Array.isArray(_data["reviews"])) {
                this.reviews = [] as any;
                for (let item of _data["reviews"])
                    this.reviews!.push(JobReviewEntity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FreelancerProfileEntity {
        data = typeof data === 'object' ? data : {};
        let result = new FreelancerProfileEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item.toJSON());
        }
        data["experience"] = this.experience;
        if (Array.isArray(this.portfolioProjects)) {
            data["portfolioProjects"] = [];
            for (let item of this.portfolioProjects)
                data["portfolioProjects"].push(item.toJSON());
        }
        data["resume"] = this.resume;
        data["costPerHour"] = this.costPerHour;
        data["availability"] = this.availability;
        data["rating"] = this.rating;
        data["isHidden"] = this.isHidden;
        if (Array.isArray(this.reviews)) {
            data["reviews"] = [];
            for (let item of this.reviews)
                data["reviews"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFreelancerProfileEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    userId?: string;
    user?: UserEntity;
    skills?: SkillEntity[] | undefined;
    experience?: string | undefined;
    portfolioProjects?: PortfolioProjectEntity[] | undefined;
    resume?: string | undefined;
    costPerHour?: number;
    availability?: FreelancerProfileEntityAvailability;
    rating?: number;
    isHidden?: boolean;
    reviews?: JobReviewEntity[] | undefined;
}

export class FreelancerTeamEntity implements IFreelancerTeamEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name?: string | undefined;
    participants?: UserEntity[] | undefined;
    readonly closed?: boolean;
    readonly closedReason?: string | undefined;
    avatarId?: string;
    avatar?: FileEntity;
    owner?: UserEntity;
    ownerId?: string;

    constructor(data?: IFreelancerTeamEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            if (Array.isArray(_data["participants"])) {
                this.participants = [] as any;
                for (let item of _data["participants"])
                    this.participants!.push(UserEntity.fromJS(item));
            }
            (<any>this).closed = _data["closed"];
            (<any>this).closedReason = _data["closedReason"];
            this.avatarId = _data["avatarId"];
            this.avatar = _data["avatar"] ? FileEntity.fromJS(_data["avatar"]) : <any>undefined;
            this.owner = _data["owner"] ? UserEntity.fromJS(_data["owner"]) : <any>undefined;
            this.ownerId = _data["ownerId"];
        }
    }

    static fromJS(data: any): FreelancerTeamEntity {
        data = typeof data === 'object' ? data : {};
        let result = new FreelancerTeamEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        if (Array.isArray(this.participants)) {
            data["participants"] = [];
            for (let item of this.participants)
                data["participants"].push(item.toJSON());
        }
        data["closed"] = this.closed;
        data["closedReason"] = this.closedReason;
        data["avatarId"] = this.avatarId;
        data["avatar"] = this.avatar ? this.avatar.toJSON() : <any>undefined;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["ownerId"] = this.ownerId;
        return data;
    }
}

export interface IFreelancerTeamEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name?: string | undefined;
    participants?: UserEntity[] | undefined;
    closed?: boolean;
    closedReason?: string | undefined;
    avatarId?: string;
    avatar?: FileEntity;
    owner?: UserEntity;
    ownerId?: string;
}

export class GatewayResultCommand implements IGatewayResultCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    success!: boolean;
    gatewayTransactionId!: string;
    internalTransactionId!: string;
    customId?: string | undefined;
    amount!: number;
    fee!: number;
    currency!: GatewayResultCommandCurrency;
    status?: string | undefined;
    failureReason?: string | undefined;
    metadata?: { [key: string]: string; } | undefined;

    constructor(data?: IGatewayResultCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.success = _data["success"];
            this.gatewayTransactionId = _data["gatewayTransactionId"];
            this.internalTransactionId = _data["internalTransactionId"];
            this.customId = _data["customId"];
            this.amount = _data["amount"];
            this.fee = _data["fee"];
            this.currency = _data["currency"];
            this.status = _data["status"];
            this.failureReason = _data["failureReason"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
        }
    }

    static fromJS(data: any): GatewayResultCommand {
        data = typeof data === 'object' ? data : {};
        let result = new GatewayResultCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["success"] = this.success;
        data["gatewayTransactionId"] = this.gatewayTransactionId;
        data["internalTransactionId"] = this.internalTransactionId;
        data["customId"] = this.customId;
        data["amount"] = this.amount;
        data["fee"] = this.fee;
        data["currency"] = this.currency;
        data["status"] = this.status;
        data["failureReason"] = this.failureReason;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        return data;
    }
}

export interface IGatewayResultCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    success: boolean;
    gatewayTransactionId: string;
    internalTransactionId: string;
    customId?: string | undefined;
    amount: number;
    fee: number;
    currency: GatewayResultCommandCurrency;
    status?: string | undefined;
    failureReason?: string | undefined;
    metadata?: { [key: string]: string; } | undefined;
}

export class GetTicketsDto implements IGetTicketsDto {
    start?: number;
    ends?: number;
    userId?: string | undefined;
    subject?: string | undefined;
    isAssignedToMe?: boolean | undefined;

    constructor(data?: IGetTicketsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start = _data["start"];
            this.ends = _data["ends"];
            this.userId = _data["userId"];
            this.subject = _data["subject"];
            this.isAssignedToMe = _data["isAssignedToMe"];
        }
    }

    static fromJS(data: any): GetTicketsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start;
        data["ends"] = this.ends;
        data["userId"] = this.userId;
        data["subject"] = this.subject;
        data["isAssignedToMe"] = this.isAssignedToMe;
        return data;
    }
}

export interface IGetTicketsDto {
    start?: number;
    ends?: number;
    userId?: string | undefined;
    subject?: string | undefined;
    isAssignedToMe?: boolean | undefined;
}

export class HandleTransactionCommand implements IHandleTransactionCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    transactionId!: string;

    constructor(data?: IHandleTransactionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.transactionId = _data["transactionId"];
        }
    }

    static fromJS(data: any): HandleTransactionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new HandleTransactionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["transactionId"] = this.transactionId;
        return data;
    }
}

export interface IHandleTransactionCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    transactionId: string;
}

export class HideFreelancerProfileCommand implements IHideFreelancerProfileCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    userId?: string;

    constructor(data?: IHideFreelancerProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): HideFreelancerProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new HideFreelancerProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IHideFreelancerProfileCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    userId?: string;
}

export class HideJobCommand implements IHideJobCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    jobId?: string;

    constructor(data?: IHideJobCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.jobId = _data["jobId"];
        }
    }

    static fromJS(data: any): HideJobCommand {
        data = typeof data === 'object' ? data : {};
        let result = new HideJobCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["jobId"] = this.jobId;
        return data;
    }
}

export interface IHideJobCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    jobId?: string;
}

export class ICustomAttributeProvider implements IICustomAttributeProvider {

    constructor(data?: IICustomAttributeProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ICustomAttributeProvider {
        data = typeof data === 'object' ? data : {};
        let result = new ICustomAttributeProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IICustomAttributeProvider {
}

export class InitiateDisputeCommand implements IInitiateDisputeCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contractId?: string;
    reason?: string | undefined;

    constructor(data?: IInitiateDisputeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contractId = _data["contractId"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): InitiateDisputeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new InitiateDisputeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contractId"] = this.contractId;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IInitiateDisputeCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contractId?: string;
    reason?: string | undefined;
}

export class IntPtr implements IIntPtr {

    constructor(data?: IIntPtr) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IntPtr {
        data = typeof data === 'object' ? data : {};
        let result = new IntPtr();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IIntPtr {
}

export class Job implements IJob {
    type?: Type;
    method?: MethodInfo;
    readonly args?: any[] | undefined;
    readonly queue?: string | undefined;
    readonly arguments?: string[] | undefined;

    constructor(data?: IJob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"] ? Type.fromJS(_data["type"]) : <any>undefined;
            this.method = _data["method"] ? MethodInfo.fromJS(_data["method"]) : <any>undefined;
            if (Array.isArray(_data["args"])) {
                (<any>this).args = [] as any;
                for (let item of _data["args"])
                    (<any>this).args!.push(item);
            }
            (<any>this).queue = _data["queue"];
            if (Array.isArray(_data["arguments"])) {
                (<any>this).arguments = [] as any;
                for (let item of _data["arguments"])
                    (<any>this).arguments!.push(item);
            }
        }
    }

    static fromJS(data: any): Job {
        data = typeof data === 'object' ? data : {};
        let result = new Job();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        data["method"] = this.method ? this.method.toJSON() : <any>undefined;
        if (Array.isArray(this.args)) {
            data["args"] = [];
            for (let item of this.args)
                data["args"].push(item);
        }
        data["queue"] = this.queue;
        if (Array.isArray(this.arguments)) {
            data["arguments"] = [];
            for (let item of this.arguments)
                data["arguments"].push(item);
        }
        return data;
    }
}

export interface IJob {
    type?: Type;
    method?: MethodInfo;
    args?: any[] | undefined;
    queue?: string | undefined;
    arguments?: string[] | undefined;
}

export class JobEntity implements IJobEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    employerId?: string;
    employer?: UserEntity;
    title?: string | undefined;
    description?: string | undefined;
    requiredSkills?: SkillEntity[] | undefined;
    category?: CategoryEntity;
    categoryId?: string;
    payout?: Money;
    expirationDate?: Date | undefined;
    duration?: number | undefined;
    status?: JobEntityStatus;
    proposals?: ProposalEntity[] | undefined;
    level?: JobEntityLevel;
    budgetType?: JobEntityBudgetType;
    publicationDate?: Date | undefined;
    paymentVerified?: boolean;
    readonly files?: FileEntity[] | undefined;
    isHidden?: boolean;

    constructor(data?: IJobEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.employerId = _data["employerId"];
            this.employer = _data["employer"] ? UserEntity.fromJS(_data["employer"]) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["requiredSkills"])) {
                this.requiredSkills = [] as any;
                for (let item of _data["requiredSkills"])
                    this.requiredSkills!.push(SkillEntity.fromJS(item));
            }
            this.category = _data["category"] ? CategoryEntity.fromJS(_data["category"]) : <any>undefined;
            this.categoryId = _data["categoryId"];
            this.payout = _data["payout"] ? Money.fromJS(_data["payout"]) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            this.status = _data["status"];
            if (Array.isArray(_data["proposals"])) {
                this.proposals = [] as any;
                for (let item of _data["proposals"])
                    this.proposals!.push(ProposalEntity.fromJS(item));
            }
            this.level = _data["level"];
            this.budgetType = _data["budgetType"];
            this.publicationDate = _data["publicationDate"] ? new Date(_data["publicationDate"].toString()) : <any>undefined;
            this.paymentVerified = _data["paymentVerified"];
            if (Array.isArray(_data["files"])) {
                (<any>this).files = [] as any;
                for (let item of _data["files"])
                    (<any>this).files!.push(FileEntity.fromJS(item));
            }
            this.isHidden = _data["isHidden"];
        }
    }

    static fromJS(data: any): JobEntity {
        data = typeof data === 'object' ? data : {};
        let result = new JobEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["employerId"] = this.employerId;
        data["employer"] = this.employer ? this.employer.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.requiredSkills)) {
            data["requiredSkills"] = [];
            for (let item of this.requiredSkills)
                data["requiredSkills"].push(item.toJSON());
        }
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["payout"] = this.payout ? this.payout.toJSON() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["duration"] = this.duration;
        data["status"] = this.status;
        if (Array.isArray(this.proposals)) {
            data["proposals"] = [];
            for (let item of this.proposals)
                data["proposals"].push(item.toJSON());
        }
        data["level"] = this.level;
        data["budgetType"] = this.budgetType;
        data["publicationDate"] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
        data["paymentVerified"] = this.paymentVerified;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["isHidden"] = this.isHidden;
        return data;
    }
}

export interface IJobEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    employerId?: string;
    employer?: UserEntity;
    title?: string | undefined;
    description?: string | undefined;
    requiredSkills?: SkillEntity[] | undefined;
    category?: CategoryEntity;
    categoryId?: string;
    payout?: Money;
    expirationDate?: Date | undefined;
    duration?: number | undefined;
    status?: JobEntityStatus;
    proposals?: ProposalEntity[] | undefined;
    level?: JobEntityLevel;
    budgetType?: JobEntityBudgetType;
    publicationDate?: Date | undefined;
    paymentVerified?: boolean;
    files?: FileEntity[] | undefined;
    isHidden?: boolean;
}

export class JobReviewEntity implements IJobReviewEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    reviewerId!: string;
    reviewer!: UserEntity;
    targetId!: string;
    target!: UserEntity;
    jobId!: string;
    job!: JobEntity;
    readonly rating!: number;
    comment!: string;
    reviewDate!: Date;

    constructor(data?: IJobReviewEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.reviewer = new UserEntity();
            this.target = new UserEntity();
            this.job = new JobEntity();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.reviewerId = _data["reviewerId"];
            this.reviewer = _data["reviewer"] ? UserEntity.fromJS(_data["reviewer"]) : new UserEntity();
            this.targetId = _data["targetId"];
            this.target = _data["target"] ? UserEntity.fromJS(_data["target"]) : new UserEntity();
            this.jobId = _data["jobId"];
            this.job = _data["job"] ? JobEntity.fromJS(_data["job"]) : new JobEntity();
            (<any>this).rating = _data["rating"];
            this.comment = _data["comment"];
            this.reviewDate = _data["reviewDate"] ? new Date(_data["reviewDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): JobReviewEntity {
        data = typeof data === 'object' ? data : {};
        let result = new JobReviewEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["reviewerId"] = this.reviewerId;
        data["reviewer"] = this.reviewer ? this.reviewer.toJSON() : <any>undefined;
        data["targetId"] = this.targetId;
        data["target"] = this.target ? this.target.toJSON() : <any>undefined;
        data["jobId"] = this.jobId;
        data["job"] = this.job ? this.job.toJSON() : <any>undefined;
        data["rating"] = this.rating;
        data["comment"] = this.comment;
        data["reviewDate"] = this.reviewDate ? this.reviewDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IJobReviewEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    reviewerId: string;
    reviewer: UserEntity;
    targetId: string;
    target: UserEntity;
    jobId: string;
    job: JobEntity;
    rating: number;
    comment: string;
    reviewDate: Date;
}

export class LoginUserSchema implements ILoginUserSchema {
    email!: string;
    password!: string;
    rememberMe?: boolean;

    constructor(data?: ILoginUserSchema) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.rememberMe = _data["rememberMe"];
        }
    }

    static fromJS(data: any): LoginUserSchema {
        data = typeof data === 'object' ? data : {};
        let result = new LoginUserSchema();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        return data;
    }
}

export interface ILoginUserSchema {
    email: string;
    password: string;
    rememberMe?: boolean;
}

export class MemberInfo implements IMemberInfo {
    readonly memberType?: MemberInfoMemberType;
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;

    constructor(data?: IMemberInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).memberType = _data["memberType"];
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): MemberInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MemberInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IMemberInfo {
    memberType?: MemberInfoMemberType;
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
}

export class MethodBase implements IMethodBase {
    readonly memberType?: MethodBaseMemberType;
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    readonly attributes?: MethodBaseAttributes;
    readonly methodImplementationFlags?: MethodBaseMethodImplementationFlags;
    readonly callingConvention?: MethodBaseCallingConvention;
    readonly isAbstract?: boolean;
    readonly isConstructor?: boolean;
    readonly isFinal?: boolean;
    readonly isHideBySig?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isVirtual?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isConstructedGenericMethod?: boolean;
    readonly isGenericMethod?: boolean;
    readonly isGenericMethodDefinition?: boolean;
    readonly containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;

    constructor(data?: IMethodBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).memberType = _data["memberType"];
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
            (<any>this).attributes = _data["attributes"];
            (<any>this).methodImplementationFlags = _data["methodImplementationFlags"];
            (<any>this).callingConvention = _data["callingConvention"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isConstructor = _data["isConstructor"];
            (<any>this).isFinal = _data["isFinal"];
            (<any>this).isHideBySig = _data["isHideBySig"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isVirtual = _data["isVirtual"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isConstructedGenericMethod = _data["isConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["isGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["isGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            this.methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
        }
    }

    static fromJS(data: any): MethodBase {
        data = typeof data === 'object' ? data : {};
        let result = new MethodBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        data["attributes"] = this.attributes;
        data["methodImplementationFlags"] = this.methodImplementationFlags;
        data["callingConvention"] = this.callingConvention;
        data["isAbstract"] = this.isAbstract;
        data["isConstructor"] = this.isConstructor;
        data["isFinal"] = this.isFinal;
        data["isHideBySig"] = this.isHideBySig;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isVirtual"] = this.isVirtual;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["isGenericMethod"] = this.isGenericMethod;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        return data;
    }
}

export interface IMethodBase {
    memberType?: MethodBaseMemberType;
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
    attributes?: MethodBaseAttributes;
    methodImplementationFlags?: MethodBaseMethodImplementationFlags;
    callingConvention?: MethodBaseCallingConvention;
    isAbstract?: boolean;
    isConstructor?: boolean;
    isFinal?: boolean;
    isHideBySig?: boolean;
    isSpecialName?: boolean;
    isStatic?: boolean;
    isVirtual?: boolean;
    isAssembly?: boolean;
    isFamily?: boolean;
    isFamilyAndAssembly?: boolean;
    isFamilyOrAssembly?: boolean;
    isPrivate?: boolean;
    isPublic?: boolean;
    isConstructedGenericMethod?: boolean;
    isGenericMethod?: boolean;
    isGenericMethodDefinition?: boolean;
    containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
}

export class MethodInfo implements IMethodInfo {
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    readonly attributes?: MethodInfoAttributes;
    readonly methodImplementationFlags?: MethodInfoMethodImplementationFlags;
    readonly callingConvention?: MethodInfoCallingConvention;
    readonly isAbstract?: boolean;
    readonly isConstructor?: boolean;
    readonly isFinal?: boolean;
    readonly isHideBySig?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isVirtual?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isConstructedGenericMethod?: boolean;
    readonly isGenericMethod?: boolean;
    readonly isGenericMethodDefinition?: boolean;
    readonly containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    readonly memberType?: MethodInfoMemberType;
    returnParameter?: ParameterInfo;
    returnType?: Type;
    returnTypeCustomAttributes?: ICustomAttributeProvider;

    constructor(data?: IMethodInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
            (<any>this).attributes = _data["attributes"];
            (<any>this).methodImplementationFlags = _data["methodImplementationFlags"];
            (<any>this).callingConvention = _data["callingConvention"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isConstructor = _data["isConstructor"];
            (<any>this).isFinal = _data["isFinal"];
            (<any>this).isHideBySig = _data["isHideBySig"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isVirtual = _data["isVirtual"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isConstructedGenericMethod = _data["isConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["isGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["isGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            this.methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            (<any>this).memberType = _data["memberType"];
            this.returnParameter = _data["returnParameter"] ? ParameterInfo.fromJS(_data["returnParameter"]) : <any>undefined;
            this.returnType = _data["returnType"] ? Type.fromJS(_data["returnType"]) : <any>undefined;
            this.returnTypeCustomAttributes = _data["returnTypeCustomAttributes"] ? ICustomAttributeProvider.fromJS(_data["returnTypeCustomAttributes"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MethodInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MethodInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        data["attributes"] = this.attributes;
        data["methodImplementationFlags"] = this.methodImplementationFlags;
        data["callingConvention"] = this.callingConvention;
        data["isAbstract"] = this.isAbstract;
        data["isConstructor"] = this.isConstructor;
        data["isFinal"] = this.isFinal;
        data["isHideBySig"] = this.isHideBySig;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isVirtual"] = this.isVirtual;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["isGenericMethod"] = this.isGenericMethod;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["memberType"] = this.memberType;
        data["returnParameter"] = this.returnParameter ? this.returnParameter.toJSON() : <any>undefined;
        data["returnType"] = this.returnType ? this.returnType.toJSON() : <any>undefined;
        data["returnTypeCustomAttributes"] = this.returnTypeCustomAttributes ? this.returnTypeCustomAttributes.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMethodInfo {
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
    attributes?: MethodInfoAttributes;
    methodImplementationFlags?: MethodInfoMethodImplementationFlags;
    callingConvention?: MethodInfoCallingConvention;
    isAbstract?: boolean;
    isConstructor?: boolean;
    isFinal?: boolean;
    isHideBySig?: boolean;
    isSpecialName?: boolean;
    isStatic?: boolean;
    isVirtual?: boolean;
    isAssembly?: boolean;
    isFamily?: boolean;
    isFamilyAndAssembly?: boolean;
    isFamilyOrAssembly?: boolean;
    isPrivate?: boolean;
    isPublic?: boolean;
    isConstructedGenericMethod?: boolean;
    isGenericMethod?: boolean;
    isGenericMethodDefinition?: boolean;
    containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    memberType?: MethodInfoMemberType;
    returnParameter?: ParameterInfo;
    returnType?: Type;
    returnTypeCustomAttributes?: ICustomAttributeProvider;
}

export class Module implements IModule {
    assembly?: Assembly;
    readonly fullyQualifiedName?: string | undefined;
    readonly name?: string | undefined;
    readonly mdStreamVersion?: number;
    readonly moduleVersionId?: string;
    readonly scopeName?: string | undefined;
    moduleHandle?: ModuleHandle;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly metadataToken?: number;

    constructor(data?: IModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assembly = _data["assembly"] ? Assembly.fromJS(_data["assembly"]) : <any>undefined;
            (<any>this).fullyQualifiedName = _data["fullyQualifiedName"];
            (<any>this).name = _data["name"];
            (<any>this).mdStreamVersion = _data["mdStreamVersion"];
            (<any>this).moduleVersionId = _data["moduleVersionId"];
            (<any>this).scopeName = _data["scopeName"];
            this.moduleHandle = _data["moduleHandle"] ? ModuleHandle.fromJS(_data["moduleHandle"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): Module {
        data = typeof data === 'object' ? data : {};
        let result = new Module();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["fullyQualifiedName"] = this.fullyQualifiedName;
        data["name"] = this.name;
        data["mdStreamVersion"] = this.mdStreamVersion;
        data["moduleVersionId"] = this.moduleVersionId;
        data["scopeName"] = this.scopeName;
        data["moduleHandle"] = this.moduleHandle ? this.moduleHandle.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IModule {
    assembly?: Assembly;
    fullyQualifiedName?: string | undefined;
    name?: string | undefined;
    mdStreamVersion?: number;
    moduleVersionId?: string;
    scopeName?: string | undefined;
    moduleHandle?: ModuleHandle;
    customAttributes?: CustomAttributeData[] | undefined;
    metadataToken?: number;
}

export class ModuleHandle implements IModuleHandle {
    readonly mdStreamVersion?: number;

    constructor(data?: IModuleHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).mdStreamVersion = _data["mdStreamVersion"];
        }
    }

    static fromJS(data: any): ModuleHandle {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mdStreamVersion"] = this.mdStreamVersion;
        return data;
    }
}

export interface IModuleHandle {
    mdStreamVersion?: number;
}

export class Money implements IMoney {
    amount!: number;
    currency!: MoneyCurrency;

    constructor(data?: IMoney) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.currency = _data["currency"];
        }
    }

    static fromJS(data: any): Money {
        data = typeof data === 'object' ? data : {};
        let result = new Money();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["currency"] = this.currency;
        return data;
    }
}

export interface IMoney {
    amount: number;
    currency: MoneyCurrency;
}

export class NotificationEntity implements INotificationEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    title!: string;
    text!: string;
    fromUserId?: string | undefined;
    toUserId!: string;
    type?: NotificationEntityType;
    data?: string | undefined;
    icon?: FileEntity;

    constructor(data?: INotificationEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.text = _data["text"];
            this.fromUserId = _data["fromUserId"];
            this.toUserId = _data["toUserId"];
            this.type = _data["type"];
            this.data = _data["data"];
            this.icon = _data["icon"] ? FileEntity.fromJS(_data["icon"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NotificationEntity {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["text"] = this.text;
        data["fromUserId"] = this.fromUserId;
        data["toUserId"] = this.toUserId;
        data["type"] = this.type;
        data["data"] = this.data;
        data["icon"] = this.icon ? this.icon.toJSON() : <any>undefined;
        return data;
    }
}

export interface INotificationEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    title: string;
    text: string;
    fromUserId?: string | undefined;
    toUserId: string;
    type?: NotificationEntityType;
    data?: string | undefined;
    icon?: FileEntity;
}

export class ParameterInfo implements IParameterInfo {
    readonly attributes?: ParameterInfoAttributes;
    member?: MemberInfo;
    readonly name?: string | undefined;
    parameterType?: Type;
    readonly position?: number;
    readonly isIn?: boolean;
    readonly isLcid?: boolean;
    readonly isOptional?: boolean;
    readonly isOut?: boolean;
    readonly isRetval?: boolean;
    readonly defaultValue?: any | undefined;
    readonly rawDefaultValue?: any | undefined;
    readonly hasDefaultValue?: boolean;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly metadataToken?: number;

    constructor(data?: IParameterInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).attributes = _data["attributes"];
            this.member = _data["member"] ? MemberInfo.fromJS(_data["member"]) : <any>undefined;
            (<any>this).name = _data["name"];
            this.parameterType = _data["parameterType"] ? Type.fromJS(_data["parameterType"]) : <any>undefined;
            (<any>this).position = _data["position"];
            (<any>this).isIn = _data["isIn"];
            (<any>this).isLcid = _data["isLcid"];
            (<any>this).isOptional = _data["isOptional"];
            (<any>this).isOut = _data["isOut"];
            (<any>this).isRetval = _data["isRetval"];
            (<any>this).defaultValue = _data["defaultValue"];
            (<any>this).rawDefaultValue = _data["rawDefaultValue"];
            (<any>this).hasDefaultValue = _data["hasDefaultValue"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): ParameterInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributes"] = this.attributes;
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["parameterType"] = this.parameterType ? this.parameterType.toJSON() : <any>undefined;
        data["position"] = this.position;
        data["isIn"] = this.isIn;
        data["isLcid"] = this.isLcid;
        data["isOptional"] = this.isOptional;
        data["isOut"] = this.isOut;
        data["isRetval"] = this.isRetval;
        data["defaultValue"] = this.defaultValue;
        data["rawDefaultValue"] = this.rawDefaultValue;
        data["hasDefaultValue"] = this.hasDefaultValue;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IParameterInfo {
    attributes?: ParameterInfoAttributes;
    member?: MemberInfo;
    name?: string | undefined;
    parameterType?: Type;
    position?: number;
    isIn?: boolean;
    isLcid?: boolean;
    isOptional?: boolean;
    isOut?: boolean;
    isRetval?: boolean;
    defaultValue?: any | undefined;
    rawDefaultValue?: any | undefined;
    hasDefaultValue?: boolean;
    customAttributes?: CustomAttributeData[] | undefined;
    metadataToken?: number;
}

export class PaymentSystemEntity implements IPaymentSystemEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name!: string;
    isActive?: boolean;

    constructor(data?: IPaymentSystemEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PaymentSystemEntity {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentSystemEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IPaymentSystemEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name: string;
    isActive?: boolean;
}

export class PortfolioProjectEntity implements IPortfolioProjectEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name?: string | undefined;
    userRole?: string | undefined;
    skills?: SkillEntity[] | undefined;
    description?: string | undefined;
    images?: FileEntity[] | undefined;
    hidden?: boolean;
    userId?: string;
    user?: UserEntity;

    constructor(data?: IPortfolioProjectEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.userRole = _data["userRole"];
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(SkillEntity.fromJS(item));
            }
            this.description = _data["description"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(FileEntity.fromJS(item));
            }
            this.hidden = _data["hidden"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserEntity.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PortfolioProjectEntity {
        data = typeof data === 'object' ? data : {};
        let result = new PortfolioProjectEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["userRole"] = this.userRole;
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item.toJSON());
        }
        data["description"] = this.description;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["hidden"] = this.hidden;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPortfolioProjectEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name?: string | undefined;
    userRole?: string | undefined;
    skills?: SkillEntity[] | undefined;
    description?: string | undefined;
    images?: FileEntity[] | undefined;
    hidden?: boolean;
    userId?: string;
    user?: UserEntity;
}

export class PropertyInfo implements IPropertyInfo {
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    readonly memberType?: PropertyInfoMemberType;
    propertyType?: Type;
    readonly attributes?: PropertyInfoAttributes;
    readonly isSpecialName?: boolean;
    readonly canRead?: boolean;
    readonly canWrite?: boolean;
    getMethod?: MethodInfo;
    setMethod?: MethodInfo;

    constructor(data?: IPropertyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
            (<any>this).memberType = _data["memberType"];
            this.propertyType = _data["propertyType"] ? Type.fromJS(_data["propertyType"]) : <any>undefined;
            (<any>this).attributes = _data["attributes"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).canRead = _data["canRead"];
            (<any>this).canWrite = _data["canWrite"];
            this.getMethod = _data["getMethod"] ? MethodInfo.fromJS(_data["getMethod"]) : <any>undefined;
            this.setMethod = _data["setMethod"] ? MethodInfo.fromJS(_data["setMethod"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PropertyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        data["memberType"] = this.memberType;
        data["propertyType"] = this.propertyType ? this.propertyType.toJSON() : <any>undefined;
        data["attributes"] = this.attributes;
        data["isSpecialName"] = this.isSpecialName;
        data["canRead"] = this.canRead;
        data["canWrite"] = this.canWrite;
        data["getMethod"] = this.getMethod ? this.getMethod.toJSON() : <any>undefined;
        data["setMethod"] = this.setMethod ? this.setMethod.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPropertyInfo {
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
    memberType?: PropertyInfoMemberType;
    propertyType?: Type;
    attributes?: PropertyInfoAttributes;
    isSpecialName?: boolean;
    canRead?: boolean;
    canWrite?: boolean;
    getMethod?: MethodInfo;
    setMethod?: MethodInfo;
}

export class ProposalEntity implements IProposalEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    jobId?: string;
    job?: JobEntity;
    freelancerId?: string;
    freelancer?: UserEntity;
    proposedRate?: number;
    coverLetter?: string | undefined;
    status?: ProposalEntityStatus;
    files?: FileEntity[] | undefined;

    constructor(data?: IProposalEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.jobId = _data["jobId"];
            this.job = _data["job"] ? JobEntity.fromJS(_data["job"]) : <any>undefined;
            this.freelancerId = _data["freelancerId"];
            this.freelancer = _data["freelancer"] ? UserEntity.fromJS(_data["freelancer"]) : <any>undefined;
            this.proposedRate = _data["proposedRate"];
            this.coverLetter = _data["coverLetter"];
            this.status = _data["status"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(FileEntity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProposalEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ProposalEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["jobId"] = this.jobId;
        data["job"] = this.job ? this.job.toJSON() : <any>undefined;
        data["freelancerId"] = this.freelancerId;
        data["freelancer"] = this.freelancer ? this.freelancer.toJSON() : <any>undefined;
        data["proposedRate"] = this.proposedRate;
        data["coverLetter"] = this.coverLetter;
        data["status"] = this.status;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProposalEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    jobId?: string;
    job?: JobEntity;
    freelancerId?: string;
    freelancer?: UserEntity;
    proposedRate?: number;
    coverLetter?: string | undefined;
    status?: ProposalEntityStatus;
    files?: FileEntity[] | undefined;
}

export class ReactToTaskCommand implements IReactToTaskCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    taskId?: string;
    approve?: boolean;
    newTitle?: string | undefined;
    newDescription?: string | undefined;

    constructor(data?: IReactToTaskCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.taskId = _data["taskId"];
            this.approve = _data["approve"];
            this.newTitle = _data["newTitle"];
            this.newDescription = _data["newDescription"];
        }
    }

    static fromJS(data: any): ReactToTaskCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ReactToTaskCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["taskId"] = this.taskId;
        data["approve"] = this.approve;
        data["newTitle"] = this.newTitle;
        data["newDescription"] = this.newDescription;
        return data;
    }
}

export interface IReactToTaskCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    taskId?: string;
    approve?: boolean;
    newTitle?: string | undefined;
    newDescription?: string | undefined;
}

export class ReactToWorkSessionCommand implements IReactToWorkSessionCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    workSessionId?: string;
    isApproved?: boolean;
    clientComment?: string | undefined;

    constructor(data?: IReactToWorkSessionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.workSessionId = _data["workSessionId"];
            this.isApproved = _data["isApproved"];
            this.clientComment = _data["clientComment"];
        }
    }

    static fromJS(data: any): ReactToWorkSessionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ReactToWorkSessionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["workSessionId"] = this.workSessionId;
        data["isApproved"] = this.isApproved;
        data["clientComment"] = this.clientComment;
        return data;
    }
}

export interface IReactToWorkSessionCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    workSessionId?: string;
    isApproved?: boolean;
    clientComment?: string | undefined;
}

export class RefundTransactionCommand implements IRefundTransactionCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    transactionId!: string;
    isContractCancellation?: boolean;

    constructor(data?: IRefundTransactionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.transactionId = _data["transactionId"];
            this.isContractCancellation = _data["isContractCancellation"];
        }
    }

    static fromJS(data: any): RefundTransactionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RefundTransactionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["transactionId"] = this.transactionId;
        data["isContractCancellation"] = this.isContractCancellation;
        return data;
    }
}

export interface IRefundTransactionCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    transactionId: string;
    isContractCancellation?: boolean;
}

export class RegisterUserSchema implements IRegisterUserSchema {
    name!: string;
    surname!: string;
    phone?: string | undefined;
    password!: string;
    email!: string;

    constructor(data?: IRegisterUserSchema) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.phone = _data["phone"];
            this.password = _data["password"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): RegisterUserSchema {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserSchema();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["phone"] = this.phone;
        data["password"] = this.password;
        data["email"] = this.email;
        return data;
    }
}

export interface IRegisterUserSchema {
    name: string;
    surname: string;
    phone?: string | undefined;
    password: string;
    email: string;
}

export class ResolveDisputeCommand implements IResolveDisputeCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    disputeId?: string;
    strategy?: ResolveDisputeCommandStrategy;
    moderatorComment?: string | undefined;
    blockFreelancerWallet?: boolean;
    blockClientWallet?: boolean;
    blockFreelancerOrders?: boolean;
    blockUntil?: Date | undefined;

    constructor(data?: IResolveDisputeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.disputeId = _data["disputeId"];
            this.strategy = _data["strategy"];
            this.moderatorComment = _data["moderatorComment"];
            this.blockFreelancerWallet = _data["blockFreelancerWallet"];
            this.blockClientWallet = _data["blockClientWallet"];
            this.blockFreelancerOrders = _data["blockFreelancerOrders"];
            this.blockUntil = _data["blockUntil"] ? new Date(_data["blockUntil"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ResolveDisputeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveDisputeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["disputeId"] = this.disputeId;
        data["strategy"] = this.strategy;
        data["moderatorComment"] = this.moderatorComment;
        data["blockFreelancerWallet"] = this.blockFreelancerWallet;
        data["blockClientWallet"] = this.blockClientWallet;
        data["blockFreelancerOrders"] = this.blockFreelancerOrders;
        data["blockUntil"] = this.blockUntil ? this.blockUntil.toISOString() : <any>undefined;
        return data;
    }
}

export interface IResolveDisputeCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    disputeId?: string;
    strategy?: ResolveDisputeCommandStrategy;
    moderatorComment?: string | undefined;
    blockFreelancerWallet?: boolean;
    blockClientWallet?: boolean;
    blockFreelancerOrders?: boolean;
    blockUntil?: Date | undefined;
}

export class RuntimeFieldHandle implements IRuntimeFieldHandle {
    value?: IntPtr;

    constructor(data?: IRuntimeFieldHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? IntPtr.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuntimeFieldHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeFieldHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRuntimeFieldHandle {
    value?: IntPtr;
}

export class RuntimeMethodHandle implements IRuntimeMethodHandle {
    value?: IntPtr;

    constructor(data?: IRuntimeMethodHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? IntPtr.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuntimeMethodHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeMethodHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRuntimeMethodHandle {
    value?: IntPtr;
}

export class RuntimeTypeHandle implements IRuntimeTypeHandle {
    value?: IntPtr;

    constructor(data?: IRuntimeTypeHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? IntPtr.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuntimeTypeHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeTypeHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRuntimeTypeHandle {
    value?: IntPtr;
}

export class SelectContestWinnerCommand implements ISelectContestWinnerCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contestId!: string;
    entryId!: string;

    constructor(data?: ISelectContestWinnerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contestId = _data["contestId"];
            this.entryId = _data["entryId"];
        }
    }

    static fromJS(data: any): SelectContestWinnerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SelectContestWinnerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contestId"] = this.contestId;
        data["entryId"] = this.entryId;
        return data;
    }
}

export interface ISelectContestWinnerCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contestId: string;
    entryId: string;
}

export class SkillEntity implements ISkillEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name?: string | undefined;

    constructor(data?: ISkillEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SkillEntity {
        data = typeof data === 'object' ? data : {};
        let result = new SkillEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        return data;
    }
}

export interface ISkillEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name?: string | undefined;
}

export class StartContestCommand implements IStartContestCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contestId?: string;

    constructor(data?: IStartContestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contestId = _data["contestId"];
        }
    }

    static fromJS(data: any): StartContestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new StartContestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contestId"] = this.contestId;
        return data;
    }
}

export interface IStartContestCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contestId?: string;
}

export class StartPaymentFlowCommand implements IStartPaymentFlowCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    amount?: Money;
    flow?: StartPaymentFlowCommandFlow;
    type?: StartPaymentFlowCommandType;
    providerId?: string;

    constructor(data?: IStartPaymentFlowCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.amount = _data["amount"] ? Money.fromJS(_data["amount"]) : <any>undefined;
            this.flow = _data["flow"];
            this.type = _data["type"];
            this.providerId = _data["providerId"];
        }
    }

    static fromJS(data: any): StartPaymentFlowCommand {
        data = typeof data === 'object' ? data : {};
        let result = new StartPaymentFlowCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["amount"] = this.amount ? this.amount.toJSON() : <any>undefined;
        data["flow"] = this.flow;
        data["type"] = this.type;
        data["providerId"] = this.providerId;
        return data;
    }
}

export interface IStartPaymentFlowCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    amount?: Money;
    flow?: StartPaymentFlowCommandFlow;
    type?: StartPaymentFlowCommandType;
    providerId?: string;
}

export class StartWorkSessionCommand implements IStartWorkSessionCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contractId?: string;

    constructor(data?: IStartWorkSessionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contractId = _data["contractId"];
        }
    }

    static fromJS(data: any): StartWorkSessionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new StartWorkSessionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contractId"] = this.contractId;
        return data;
    }
}

export interface IStartWorkSessionCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contractId?: string;
}

export class StructLayoutAttribute implements IStructLayoutAttribute {
    readonly typeId?: any | undefined;
    readonly value?: StructLayoutAttributeValue;

    constructor(data?: IStructLayoutAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).typeId = _data["typeId"];
            (<any>this).value = _data["value"];
        }
    }

    static fromJS(data: any): StructLayoutAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new StructLayoutAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["value"] = this.value;
        return data;
    }
}

export interface IStructLayoutAttribute {
    typeId?: any | undefined;
    value?: StructLayoutAttributeValue;
}

export class SubmitContestEntryCommand implements ISubmitContestEntryCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contestId?: string;
    description?: string | undefined;
    submissionFiles?: CreateFileDto[] | undefined;

    constructor(data?: ISubmitContestEntryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contestId = _data["contestId"];
            this.description = _data["description"];
            if (Array.isArray(_data["submissionFiles"])) {
                this.submissionFiles = [] as any;
                for (let item of _data["submissionFiles"])
                    this.submissionFiles!.push(CreateFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubmitContestEntryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitContestEntryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contestId"] = this.contestId;
        data["description"] = this.description;
        if (Array.isArray(this.submissionFiles)) {
            data["submissionFiles"] = [];
            for (let item of this.submissionFiles)
                data["submissionFiles"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISubmitContestEntryCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contestId?: string;
    description?: string | undefined;
    submissionFiles?: CreateFileDto[] | undefined;
}

export class SubmitProposalCommand implements ISubmitProposalCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    jobId?: string;
    coverLetter?: string | undefined;
    proposedRate?: number | undefined;

    constructor(data?: ISubmitProposalCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.jobId = _data["jobId"];
            this.coverLetter = _data["coverLetter"];
            this.proposedRate = _data["proposedRate"];
        }
    }

    static fromJS(data: any): SubmitProposalCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitProposalCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["jobId"] = this.jobId;
        data["coverLetter"] = this.coverLetter;
        data["proposedRate"] = this.proposedRate;
        return data;
    }
}

export interface ISubmitProposalCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    jobId?: string;
    coverLetter?: string | undefined;
    proposedRate?: number | undefined;
}

export class SubmitWorkSessionCommand implements ISubmitWorkSessionCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    sessionId?: string;

    constructor(data?: ISubmitWorkSessionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.sessionId = _data["sessionId"];
        }
    }

    static fromJS(data: any): SubmitWorkSessionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitWorkSessionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["sessionId"] = this.sessionId;
        return data;
    }
}

export interface ISubmitWorkSessionCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    sessionId?: string;
}

export class SuspendClientProfileCommand implements ISuspendClientProfileCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    clientId?: string;
    reason?: string | undefined;

    constructor(data?: ISuspendClientProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.clientId = _data["clientId"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): SuspendClientProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SuspendClientProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["clientId"] = this.clientId;
        data["reason"] = this.reason;
        return data;
    }
}

export interface ISuspendClientProfileCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    clientId?: string;
    reason?: string | undefined;
}

export class TaskEntity implements ITaskEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    contractId?: string;
    contract?: ContractEntity;
    readonly taskTitle?: string | undefined;
    readonly taskDescription?: string | undefined;
    readonly status?: string | undefined;
    readonly priority?: number;
    readonly creationDate?: Date;
    readonly completionDate?: Date | undefined;
    readonly isCompleted?: boolean;
    readonly isApproved?: boolean;
    readonly isInRevision?: boolean;

    constructor(data?: ITaskEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.contractId = _data["contractId"];
            this.contract = _data["contract"] ? ContractEntity.fromJS(_data["contract"]) : <any>undefined;
            (<any>this).taskTitle = _data["taskTitle"];
            (<any>this).taskDescription = _data["taskDescription"];
            (<any>this).status = _data["status"];
            (<any>this).priority = _data["priority"];
            (<any>this).creationDate = _data["creationDate"] ? new Date(_data["creationDate"].toString()) : <any>undefined;
            (<any>this).completionDate = _data["completionDate"] ? new Date(_data["completionDate"].toString()) : <any>undefined;
            (<any>this).isCompleted = _data["isCompleted"];
            (<any>this).isApproved = _data["isApproved"];
            (<any>this).isInRevision = _data["isInRevision"];
        }
    }

    static fromJS(data: any): TaskEntity {
        data = typeof data === 'object' ? data : {};
        let result = new TaskEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["contractId"] = this.contractId;
        data["contract"] = this.contract ? this.contract.toJSON() : <any>undefined;
        data["taskTitle"] = this.taskTitle;
        data["taskDescription"] = this.taskDescription;
        data["status"] = this.status;
        data["priority"] = this.priority;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["completionDate"] = this.completionDate ? this.completionDate.toISOString() : <any>undefined;
        data["isCompleted"] = this.isCompleted;
        data["isApproved"] = this.isApproved;
        data["isInRevision"] = this.isInRevision;
        return data;
    }
}

export interface ITaskEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    contractId?: string;
    contract?: ContractEntity;
    taskTitle?: string | undefined;
    taskDescription?: string | undefined;
    status?: string | undefined;
    priority?: number;
    creationDate?: Date;
    completionDate?: Date | undefined;
    isCompleted?: boolean;
    isApproved?: boolean;
    isInRevision?: boolean;
}

export class TicketCommentEntity implements ITicketCommentEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    createdBy!: UserEntity;
    text!: string;
    parentCommentId?: string | undefined;
    isDeleted!: boolean;
    ticketId!: string;
    files!: FileEntity[];

    constructor(data?: ITicketCommentEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new UserEntity();
            this.files = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"] ? UserEntity.fromJS(_data["createdBy"]) : new UserEntity();
            this.text = _data["text"];
            this.parentCommentId = _data["parentCommentId"];
            this.isDeleted = _data["isDeleted"];
            this.ticketId = _data["ticketId"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(FileEntity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TicketCommentEntity {
        data = typeof data === 'object' ? data : {};
        let result = new TicketCommentEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["text"] = this.text;
        data["parentCommentId"] = this.parentCommentId;
        data["isDeleted"] = this.isDeleted;
        data["ticketId"] = this.ticketId;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITicketCommentEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    createdBy: UserEntity;
    text: string;
    parentCommentId?: string | undefined;
    isDeleted: boolean;
    ticketId: string;
    files: FileEntity[];
}

export class TicketEntity implements ITicketEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    text!: string;
    subject!: string;
    files?: FileEntity[] | undefined;
    answeredCommentId?: string | undefined;
    readonly status!: TicketEntityStatus;
    assignedUser?: UserEntity;
    readonly assignedUserId?: string | undefined;
    readonly comments?: TicketCommentEntity[] | undefined;
    readonly closedById?: string | undefined;
    createdBy?: UserEntity;

    constructor(data?: ITicketEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.text = _data["text"];
            this.subject = _data["subject"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(FileEntity.fromJS(item));
            }
            this.answeredCommentId = _data["answeredCommentId"];
            (<any>this).status = _data["status"];
            this.assignedUser = _data["assignedUser"] ? UserEntity.fromJS(_data["assignedUser"]) : <any>undefined;
            (<any>this).assignedUserId = _data["assignedUserId"];
            if (Array.isArray(_data["comments"])) {
                (<any>this).comments = [] as any;
                for (let item of _data["comments"])
                    (<any>this).comments!.push(TicketCommentEntity.fromJS(item));
            }
            (<any>this).closedById = _data["closedById"];
            this.createdBy = _data["createdBy"] ? UserEntity.fromJS(_data["createdBy"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TicketEntity {
        data = typeof data === 'object' ? data : {};
        let result = new TicketEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["text"] = this.text;
        data["subject"] = this.subject;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["answeredCommentId"] = this.answeredCommentId;
        data["status"] = this.status;
        data["assignedUser"] = this.assignedUser ? this.assignedUser.toJSON() : <any>undefined;
        data["assignedUserId"] = this.assignedUserId;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        data["closedById"] = this.closedById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITicketEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    text: string;
    subject: string;
    files?: FileEntity[] | undefined;
    answeredCommentId?: string | undefined;
    status: TicketEntityStatus;
    assignedUser?: UserEntity;
    assignedUserId?: string | undefined;
    comments?: TicketCommentEntity[] | undefined;
    closedById?: string | undefined;
    createdBy?: UserEntity;
}

export class TransactionEntity implements ITransactionEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    readonly walletId?: string;
    antoganistTransactionId?: string | undefined;
    rawAmount?: Money;
    netAmount?: Money;
    appliedFee?: Money;
    readonly status?: TransactionEntityStatus;
    readonly type?: TransactionEntityType;
    readonly flow?: TransactionEntityFlow;
    props?: TransactionPropsEntity;
    readonly frozenUntil?: Date | undefined;
    readonly comment?: string | undefined;
    completedAt?: Date | undefined;
    provider?: TransactionProviderEntity;

    constructor(data?: ITransactionEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            (<any>this).walletId = _data["walletId"];
            this.antoganistTransactionId = _data["antoganistTransactionId"];
            this.rawAmount = _data["rawAmount"] ? Money.fromJS(_data["rawAmount"]) : <any>undefined;
            this.netAmount = _data["netAmount"] ? Money.fromJS(_data["netAmount"]) : <any>undefined;
            this.appliedFee = _data["appliedFee"] ? Money.fromJS(_data["appliedFee"]) : <any>undefined;
            (<any>this).status = _data["status"];
            (<any>this).type = _data["type"];
            (<any>this).flow = _data["flow"];
            this.props = _data["props"] ? TransactionPropsEntity.fromJS(_data["props"]) : <any>undefined;
            (<any>this).frozenUntil = _data["frozenUntil"] ? new Date(_data["frozenUntil"].toString()) : <any>undefined;
            (<any>this).comment = _data["comment"];
            this.completedAt = _data["completedAt"] ? new Date(_data["completedAt"].toString()) : <any>undefined;
            this.provider = _data["provider"] ? TransactionProviderEntity.fromJS(_data["provider"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TransactionEntity {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["walletId"] = this.walletId;
        data["antoganistTransactionId"] = this.antoganistTransactionId;
        data["rawAmount"] = this.rawAmount ? this.rawAmount.toJSON() : <any>undefined;
        data["netAmount"] = this.netAmount ? this.netAmount.toJSON() : <any>undefined;
        data["appliedFee"] = this.appliedFee ? this.appliedFee.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["type"] = this.type;
        data["flow"] = this.flow;
        data["props"] = this.props ? this.props.toJSON() : <any>undefined;
        data["frozenUntil"] = this.frozenUntil ? this.frozenUntil.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["completedAt"] = this.completedAt ? this.completedAt.toISOString() : <any>undefined;
        data["provider"] = this.provider ? this.provider.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITransactionEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    walletId?: string;
    antoganistTransactionId?: string | undefined;
    rawAmount?: Money;
    netAmount?: Money;
    appliedFee?: Money;
    status?: TransactionEntityStatus;
    type?: TransactionEntityType;
    flow?: TransactionEntityFlow;
    props?: TransactionPropsEntity;
    frozenUntil?: Date | undefined;
    comment?: string | undefined;
    completedAt?: Date | undefined;
    provider?: TransactionProviderEntity;
}

export class TransactionPropsEntity implements ITransactionPropsEntity {
    readonly paymentUrl?: string | undefined;
    readonly successUrl?: string | undefined;
    readonly paymentGateway?: string | undefined;
    feeContext?: FeeContext;

    constructor(data?: ITransactionPropsEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).paymentUrl = _data["paymentUrl"];
            (<any>this).successUrl = _data["successUrl"];
            (<any>this).paymentGateway = _data["paymentGateway"];
            this.feeContext = _data["feeContext"] ? FeeContext.fromJS(_data["feeContext"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TransactionPropsEntity {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionPropsEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentUrl"] = this.paymentUrl;
        data["successUrl"] = this.successUrl;
        data["paymentGateway"] = this.paymentGateway;
        data["feeContext"] = this.feeContext ? this.feeContext.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITransactionPropsEntity {
    paymentUrl?: string | undefined;
    successUrl?: string | undefined;
    paymentGateway?: string | undefined;
    feeContext?: FeeContext;
}

export class TransactionProviderEntity implements ITransactionProviderEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name!: string;
    feePercent!: number;
    systems!: PaymentSystemEntity[];
    logo!: FileEntity;

    constructor(data?: ITransactionProviderEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.systems = [];
            this.logo = new FileEntity();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.feePercent = _data["feePercent"];
            if (Array.isArray(_data["systems"])) {
                this.systems = [] as any;
                for (let item of _data["systems"])
                    this.systems!.push(PaymentSystemEntity.fromJS(item));
            }
            this.logo = _data["logo"] ? FileEntity.fromJS(_data["logo"]) : new FileEntity();
        }
    }

    static fromJS(data: any): TransactionProviderEntity {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionProviderEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["feePercent"] = this.feePercent;
        if (Array.isArray(this.systems)) {
            data["systems"] = [];
            for (let item of this.systems)
                data["systems"].push(item.toJSON());
        }
        data["logo"] = this.logo ? this.logo.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITransactionProviderEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name: string;
    feePercent: number;
    systems: PaymentSystemEntity[];
    logo: FileEntity;
}

export class Type implements IType {
    readonly name?: string | undefined;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    readonly isInterface?: boolean;
    readonly memberType?: TypeMemberType;
    readonly namespace?: string | undefined;
    readonly assemblyQualifiedName?: string | undefined;
    readonly fullName?: string | undefined;
    assembly?: Assembly;
    module?: Module;
    readonly isNested?: boolean;
    declaringType?: Type;
    declaringMethod?: MethodBase;
    reflectedType?: Type;
    underlyingSystemType?: Type;
    readonly isTypeDefinition?: boolean;
    readonly isArray?: boolean;
    readonly isByRef?: boolean;
    readonly isPointer?: boolean;
    readonly isConstructedGenericType?: boolean;
    readonly isGenericParameter?: boolean;
    readonly isGenericTypeParameter?: boolean;
    readonly isGenericMethodParameter?: boolean;
    readonly isGenericType?: boolean;
    readonly isGenericTypeDefinition?: boolean;
    readonly isSZArray?: boolean;
    readonly isVariableBoundArray?: boolean;
    readonly isByRefLike?: boolean;
    readonly isFunctionPointer?: boolean;
    readonly isUnmanagedFunctionPointer?: boolean;
    readonly hasElementType?: boolean;
    readonly genericTypeArguments?: Type[] | undefined;
    readonly genericParameterPosition?: number;
    readonly genericParameterAttributes?: TypeGenericParameterAttributes;
    readonly attributes?: TypeAttributes;
    readonly isAbstract?: boolean;
    readonly isImport?: boolean;
    readonly isSealed?: boolean;
    readonly isSpecialName?: boolean;
    readonly isClass?: boolean;
    readonly isNestedAssembly?: boolean;
    readonly isNestedFamANDAssem?: boolean;
    readonly isNestedFamily?: boolean;
    readonly isNestedFamORAssem?: boolean;
    readonly isNestedPrivate?: boolean;
    readonly isNestedPublic?: boolean;
    readonly isNotPublic?: boolean;
    readonly isPublic?: boolean;
    readonly isAutoLayout?: boolean;
    readonly isExplicitLayout?: boolean;
    readonly isLayoutSequential?: boolean;
    readonly isAnsiClass?: boolean;
    readonly isAutoClass?: boolean;
    readonly isUnicodeClass?: boolean;
    readonly isCOMObject?: boolean;
    readonly isContextful?: boolean;
    readonly isEnum?: boolean;
    readonly isMarshalByRef?: boolean;
    readonly isPrimitive?: boolean;
    readonly isValueType?: boolean;
    readonly isSignatureType?: boolean;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    structLayoutAttribute?: StructLayoutAttribute;
    typeInitializer?: ConstructorInfo;
    typeHandle?: RuntimeTypeHandle;
    readonly guid?: string;
    baseType?: Type;
    readonly isSerializable?: boolean;
    readonly containsGenericParameters?: boolean;
    readonly isVisible?: boolean;

    constructor(data?: IType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
            (<any>this).isInterface = _data["isInterface"];
            (<any>this).memberType = _data["memberType"];
            (<any>this).namespace = _data["namespace"];
            (<any>this).assemblyQualifiedName = _data["assemblyQualifiedName"];
            (<any>this).fullName = _data["fullName"];
            this.assembly = _data["assembly"] ? Assembly.fromJS(_data["assembly"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            (<any>this).isNested = _data["isNested"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.declaringMethod = _data["declaringMethod"] ? MethodBase.fromJS(_data["declaringMethod"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.underlyingSystemType = _data["underlyingSystemType"] ? Type.fromJS(_data["underlyingSystemType"]) : <any>undefined;
            (<any>this).isTypeDefinition = _data["isTypeDefinition"];
            (<any>this).isArray = _data["isArray"];
            (<any>this).isByRef = _data["isByRef"];
            (<any>this).isPointer = _data["isPointer"];
            (<any>this).isConstructedGenericType = _data["isConstructedGenericType"];
            (<any>this).isGenericParameter = _data["isGenericParameter"];
            (<any>this).isGenericTypeParameter = _data["isGenericTypeParameter"];
            (<any>this).isGenericMethodParameter = _data["isGenericMethodParameter"];
            (<any>this).isGenericType = _data["isGenericType"];
            (<any>this).isGenericTypeDefinition = _data["isGenericTypeDefinition"];
            (<any>this).isSZArray = _data["isSZArray"];
            (<any>this).isVariableBoundArray = _data["isVariableBoundArray"];
            (<any>this).isByRefLike = _data["isByRefLike"];
            (<any>this).isFunctionPointer = _data["isFunctionPointer"];
            (<any>this).isUnmanagedFunctionPointer = _data["isUnmanagedFunctionPointer"];
            (<any>this).hasElementType = _data["hasElementType"];
            if (Array.isArray(_data["genericTypeArguments"])) {
                (<any>this).genericTypeArguments = [] as any;
                for (let item of _data["genericTypeArguments"])
                    (<any>this).genericTypeArguments!.push(Type.fromJS(item));
            }
            (<any>this).genericParameterPosition = _data["genericParameterPosition"];
            (<any>this).genericParameterAttributes = _data["genericParameterAttributes"];
            (<any>this).attributes = _data["attributes"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isImport = _data["isImport"];
            (<any>this).isSealed = _data["isSealed"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isClass = _data["isClass"];
            (<any>this).isNestedAssembly = _data["isNestedAssembly"];
            (<any>this).isNestedFamANDAssem = _data["isNestedFamANDAssem"];
            (<any>this).isNestedFamily = _data["isNestedFamily"];
            (<any>this).isNestedFamORAssem = _data["isNestedFamORAssem"];
            (<any>this).isNestedPrivate = _data["isNestedPrivate"];
            (<any>this).isNestedPublic = _data["isNestedPublic"];
            (<any>this).isNotPublic = _data["isNotPublic"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isAutoLayout = _data["isAutoLayout"];
            (<any>this).isExplicitLayout = _data["isExplicitLayout"];
            (<any>this).isLayoutSequential = _data["isLayoutSequential"];
            (<any>this).isAnsiClass = _data["isAnsiClass"];
            (<any>this).isAutoClass = _data["isAutoClass"];
            (<any>this).isUnicodeClass = _data["isUnicodeClass"];
            (<any>this).isCOMObject = _data["isCOMObject"];
            (<any>this).isContextful = _data["isContextful"];
            (<any>this).isEnum = _data["isEnum"];
            (<any>this).isMarshalByRef = _data["isMarshalByRef"];
            (<any>this).isPrimitive = _data["isPrimitive"];
            (<any>this).isValueType = _data["isValueType"];
            (<any>this).isSignatureType = _data["isSignatureType"];
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.structLayoutAttribute = _data["structLayoutAttribute"] ? StructLayoutAttribute.fromJS(_data["structLayoutAttribute"]) : <any>undefined;
            this.typeInitializer = _data["typeInitializer"] ? ConstructorInfo.fromJS(_data["typeInitializer"]) : <any>undefined;
            this.typeHandle = _data["typeHandle"] ? RuntimeTypeHandle.fromJS(_data["typeHandle"]) : <any>undefined;
            (<any>this).guid = _data["guid"];
            this.baseType = _data["baseType"] ? Type.fromJS(_data["baseType"]) : <any>undefined;
            (<any>this).isSerializable = _data["isSerializable"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            (<any>this).isVisible = _data["isVisible"];
        }
    }

    static fromJS(data: any): Type {
        data = typeof data === 'object' ? data : {};
        let result = new Type();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        data["isInterface"] = this.isInterface;
        data["memberType"] = this.memberType;
        data["namespace"] = this.namespace;
        data["assemblyQualifiedName"] = this.assemblyQualifiedName;
        data["fullName"] = this.fullName;
        data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        data["isNested"] = this.isNested;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["declaringMethod"] = this.declaringMethod ? this.declaringMethod.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["underlyingSystemType"] = this.underlyingSystemType ? this.underlyingSystemType.toJSON() : <any>undefined;
        data["isTypeDefinition"] = this.isTypeDefinition;
        data["isArray"] = this.isArray;
        data["isByRef"] = this.isByRef;
        data["isPointer"] = this.isPointer;
        data["isConstructedGenericType"] = this.isConstructedGenericType;
        data["isGenericParameter"] = this.isGenericParameter;
        data["isGenericTypeParameter"] = this.isGenericTypeParameter;
        data["isGenericMethodParameter"] = this.isGenericMethodParameter;
        data["isGenericType"] = this.isGenericType;
        data["isGenericTypeDefinition"] = this.isGenericTypeDefinition;
        data["isSZArray"] = this.isSZArray;
        data["isVariableBoundArray"] = this.isVariableBoundArray;
        data["isByRefLike"] = this.isByRefLike;
        data["isFunctionPointer"] = this.isFunctionPointer;
        data["isUnmanagedFunctionPointer"] = this.isUnmanagedFunctionPointer;
        data["hasElementType"] = this.hasElementType;
        if (Array.isArray(this.genericTypeArguments)) {
            data["genericTypeArguments"] = [];
            for (let item of this.genericTypeArguments)
                data["genericTypeArguments"].push(item.toJSON());
        }
        data["genericParameterPosition"] = this.genericParameterPosition;
        data["genericParameterAttributes"] = this.genericParameterAttributes;
        data["attributes"] = this.attributes;
        data["isAbstract"] = this.isAbstract;
        data["isImport"] = this.isImport;
        data["isSealed"] = this.isSealed;
        data["isSpecialName"] = this.isSpecialName;
        data["isClass"] = this.isClass;
        data["isNestedAssembly"] = this.isNestedAssembly;
        data["isNestedFamANDAssem"] = this.isNestedFamANDAssem;
        data["isNestedFamily"] = this.isNestedFamily;
        data["isNestedFamORAssem"] = this.isNestedFamORAssem;
        data["isNestedPrivate"] = this.isNestedPrivate;
        data["isNestedPublic"] = this.isNestedPublic;
        data["isNotPublic"] = this.isNotPublic;
        data["isPublic"] = this.isPublic;
        data["isAutoLayout"] = this.isAutoLayout;
        data["isExplicitLayout"] = this.isExplicitLayout;
        data["isLayoutSequential"] = this.isLayoutSequential;
        data["isAnsiClass"] = this.isAnsiClass;
        data["isAutoClass"] = this.isAutoClass;
        data["isUnicodeClass"] = this.isUnicodeClass;
        data["isCOMObject"] = this.isCOMObject;
        data["isContextful"] = this.isContextful;
        data["isEnum"] = this.isEnum;
        data["isMarshalByRef"] = this.isMarshalByRef;
        data["isPrimitive"] = this.isPrimitive;
        data["isValueType"] = this.isValueType;
        data["isSignatureType"] = this.isSignatureType;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["structLayoutAttribute"] = this.structLayoutAttribute ? this.structLayoutAttribute.toJSON() : <any>undefined;
        data["typeInitializer"] = this.typeInitializer ? this.typeInitializer.toJSON() : <any>undefined;
        data["typeHandle"] = this.typeHandle ? this.typeHandle.toJSON() : <any>undefined;
        data["guid"] = this.guid;
        data["baseType"] = this.baseType ? this.baseType.toJSON() : <any>undefined;
        data["isSerializable"] = this.isSerializable;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["isVisible"] = this.isVisible;
        return data;
    }
}

export interface IType {
    name?: string | undefined;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
    isInterface?: boolean;
    memberType?: TypeMemberType;
    namespace?: string | undefined;
    assemblyQualifiedName?: string | undefined;
    fullName?: string | undefined;
    assembly?: Assembly;
    module?: Module;
    isNested?: boolean;
    declaringType?: Type;
    declaringMethod?: MethodBase;
    reflectedType?: Type;
    underlyingSystemType?: Type;
    isTypeDefinition?: boolean;
    isArray?: boolean;
    isByRef?: boolean;
    isPointer?: boolean;
    isConstructedGenericType?: boolean;
    isGenericParameter?: boolean;
    isGenericTypeParameter?: boolean;
    isGenericMethodParameter?: boolean;
    isGenericType?: boolean;
    isGenericTypeDefinition?: boolean;
    isSZArray?: boolean;
    isVariableBoundArray?: boolean;
    isByRefLike?: boolean;
    isFunctionPointer?: boolean;
    isUnmanagedFunctionPointer?: boolean;
    hasElementType?: boolean;
    genericTypeArguments?: Type[] | undefined;
    genericParameterPosition?: number;
    genericParameterAttributes?: TypeGenericParameterAttributes;
    attributes?: TypeAttributes;
    isAbstract?: boolean;
    isImport?: boolean;
    isSealed?: boolean;
    isSpecialName?: boolean;
    isClass?: boolean;
    isNestedAssembly?: boolean;
    isNestedFamANDAssem?: boolean;
    isNestedFamily?: boolean;
    isNestedFamORAssem?: boolean;
    isNestedPrivate?: boolean;
    isNestedPublic?: boolean;
    isNotPublic?: boolean;
    isPublic?: boolean;
    isAutoLayout?: boolean;
    isExplicitLayout?: boolean;
    isLayoutSequential?: boolean;
    isAnsiClass?: boolean;
    isAutoClass?: boolean;
    isUnicodeClass?: boolean;
    isCOMObject?: boolean;
    isContextful?: boolean;
    isEnum?: boolean;
    isMarshalByRef?: boolean;
    isPrimitive?: boolean;
    isValueType?: boolean;
    isSignatureType?: boolean;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    structLayoutAttribute?: StructLayoutAttribute;
    typeInitializer?: ConstructorInfo;
    typeHandle?: RuntimeTypeHandle;
    guid?: string;
    baseType?: Type;
    isSerializable?: boolean;
    containsGenericParameters?: boolean;
    isVisible?: boolean;
}

export class TypeInfo implements ITypeInfo {
    readonly name?: string | undefined;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    readonly isInterface?: boolean;
    readonly memberType?: TypeInfoMemberType;
    readonly namespace?: string | undefined;
    readonly assemblyQualifiedName?: string | undefined;
    readonly fullName?: string | undefined;
    assembly?: Assembly;
    module?: Module;
    readonly isNested?: boolean;
    declaringType?: Type;
    declaringMethod?: MethodBase;
    reflectedType?: Type;
    underlyingSystemType?: Type;
    readonly isTypeDefinition?: boolean;
    readonly isArray?: boolean;
    readonly isByRef?: boolean;
    readonly isPointer?: boolean;
    readonly isConstructedGenericType?: boolean;
    readonly isGenericParameter?: boolean;
    readonly isGenericTypeParameter?: boolean;
    readonly isGenericMethodParameter?: boolean;
    readonly isGenericType?: boolean;
    readonly isGenericTypeDefinition?: boolean;
    readonly isSZArray?: boolean;
    readonly isVariableBoundArray?: boolean;
    readonly isByRefLike?: boolean;
    readonly isFunctionPointer?: boolean;
    readonly isUnmanagedFunctionPointer?: boolean;
    readonly hasElementType?: boolean;
    readonly genericTypeArguments?: Type[] | undefined;
    readonly genericParameterPosition?: number;
    readonly genericParameterAttributes?: TypeInfoGenericParameterAttributes;
    readonly attributes?: TypeInfoAttributes;
    readonly isAbstract?: boolean;
    readonly isImport?: boolean;
    readonly isSealed?: boolean;
    readonly isSpecialName?: boolean;
    readonly isClass?: boolean;
    readonly isNestedAssembly?: boolean;
    readonly isNestedFamANDAssem?: boolean;
    readonly isNestedFamily?: boolean;
    readonly isNestedFamORAssem?: boolean;
    readonly isNestedPrivate?: boolean;
    readonly isNestedPublic?: boolean;
    readonly isNotPublic?: boolean;
    readonly isPublic?: boolean;
    readonly isAutoLayout?: boolean;
    readonly isExplicitLayout?: boolean;
    readonly isLayoutSequential?: boolean;
    readonly isAnsiClass?: boolean;
    readonly isAutoClass?: boolean;
    readonly isUnicodeClass?: boolean;
    readonly isCOMObject?: boolean;
    readonly isContextful?: boolean;
    readonly isEnum?: boolean;
    readonly isMarshalByRef?: boolean;
    readonly isPrimitive?: boolean;
    readonly isValueType?: boolean;
    readonly isSignatureType?: boolean;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    structLayoutAttribute?: StructLayoutAttribute;
    typeInitializer?: ConstructorInfo;
    typeHandle?: RuntimeTypeHandle;
    readonly guid?: string;
    baseType?: Type;
    readonly isSerializable?: boolean;
    readonly containsGenericParameters?: boolean;
    readonly isVisible?: boolean;
    readonly genericTypeParameters?: Type[] | undefined;
    readonly declaredConstructors?: ConstructorInfo[] | undefined;
    readonly declaredEvents?: EventInfo[] | undefined;
    readonly declaredFields?: FieldInfo[] | undefined;
    readonly declaredMembers?: MemberInfo[] | undefined;
    readonly declaredMethods?: MethodInfo[] | undefined;
    readonly declaredNestedTypes?: TypeInfo[] | undefined;
    readonly declaredProperties?: PropertyInfo[] | undefined;
    readonly implementedInterfaces?: Type[] | undefined;

    constructor(data?: ITypeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
            (<any>this).isInterface = _data["isInterface"];
            (<any>this).memberType = _data["memberType"];
            (<any>this).namespace = _data["namespace"];
            (<any>this).assemblyQualifiedName = _data["assemblyQualifiedName"];
            (<any>this).fullName = _data["fullName"];
            this.assembly = _data["assembly"] ? Assembly.fromJS(_data["assembly"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            (<any>this).isNested = _data["isNested"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.declaringMethod = _data["declaringMethod"] ? MethodBase.fromJS(_data["declaringMethod"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.underlyingSystemType = _data["underlyingSystemType"] ? Type.fromJS(_data["underlyingSystemType"]) : <any>undefined;
            (<any>this).isTypeDefinition = _data["isTypeDefinition"];
            (<any>this).isArray = _data["isArray"];
            (<any>this).isByRef = _data["isByRef"];
            (<any>this).isPointer = _data["isPointer"];
            (<any>this).isConstructedGenericType = _data["isConstructedGenericType"];
            (<any>this).isGenericParameter = _data["isGenericParameter"];
            (<any>this).isGenericTypeParameter = _data["isGenericTypeParameter"];
            (<any>this).isGenericMethodParameter = _data["isGenericMethodParameter"];
            (<any>this).isGenericType = _data["isGenericType"];
            (<any>this).isGenericTypeDefinition = _data["isGenericTypeDefinition"];
            (<any>this).isSZArray = _data["isSZArray"];
            (<any>this).isVariableBoundArray = _data["isVariableBoundArray"];
            (<any>this).isByRefLike = _data["isByRefLike"];
            (<any>this).isFunctionPointer = _data["isFunctionPointer"];
            (<any>this).isUnmanagedFunctionPointer = _data["isUnmanagedFunctionPointer"];
            (<any>this).hasElementType = _data["hasElementType"];
            if (Array.isArray(_data["genericTypeArguments"])) {
                (<any>this).genericTypeArguments = [] as any;
                for (let item of _data["genericTypeArguments"])
                    (<any>this).genericTypeArguments!.push(Type.fromJS(item));
            }
            (<any>this).genericParameterPosition = _data["genericParameterPosition"];
            (<any>this).genericParameterAttributes = _data["genericParameterAttributes"];
            (<any>this).attributes = _data["attributes"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isImport = _data["isImport"];
            (<any>this).isSealed = _data["isSealed"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isClass = _data["isClass"];
            (<any>this).isNestedAssembly = _data["isNestedAssembly"];
            (<any>this).isNestedFamANDAssem = _data["isNestedFamANDAssem"];
            (<any>this).isNestedFamily = _data["isNestedFamily"];
            (<any>this).isNestedFamORAssem = _data["isNestedFamORAssem"];
            (<any>this).isNestedPrivate = _data["isNestedPrivate"];
            (<any>this).isNestedPublic = _data["isNestedPublic"];
            (<any>this).isNotPublic = _data["isNotPublic"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isAutoLayout = _data["isAutoLayout"];
            (<any>this).isExplicitLayout = _data["isExplicitLayout"];
            (<any>this).isLayoutSequential = _data["isLayoutSequential"];
            (<any>this).isAnsiClass = _data["isAnsiClass"];
            (<any>this).isAutoClass = _data["isAutoClass"];
            (<any>this).isUnicodeClass = _data["isUnicodeClass"];
            (<any>this).isCOMObject = _data["isCOMObject"];
            (<any>this).isContextful = _data["isContextful"];
            (<any>this).isEnum = _data["isEnum"];
            (<any>this).isMarshalByRef = _data["isMarshalByRef"];
            (<any>this).isPrimitive = _data["isPrimitive"];
            (<any>this).isValueType = _data["isValueType"];
            (<any>this).isSignatureType = _data["isSignatureType"];
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.structLayoutAttribute = _data["structLayoutAttribute"] ? StructLayoutAttribute.fromJS(_data["structLayoutAttribute"]) : <any>undefined;
            this.typeInitializer = _data["typeInitializer"] ? ConstructorInfo.fromJS(_data["typeInitializer"]) : <any>undefined;
            this.typeHandle = _data["typeHandle"] ? RuntimeTypeHandle.fromJS(_data["typeHandle"]) : <any>undefined;
            (<any>this).guid = _data["guid"];
            this.baseType = _data["baseType"] ? Type.fromJS(_data["baseType"]) : <any>undefined;
            (<any>this).isSerializable = _data["isSerializable"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            (<any>this).isVisible = _data["isVisible"];
            if (Array.isArray(_data["genericTypeParameters"])) {
                (<any>this).genericTypeParameters = [] as any;
                for (let item of _data["genericTypeParameters"])
                    (<any>this).genericTypeParameters!.push(Type.fromJS(item));
            }
            if (Array.isArray(_data["declaredConstructors"])) {
                (<any>this).declaredConstructors = [] as any;
                for (let item of _data["declaredConstructors"])
                    (<any>this).declaredConstructors!.push(ConstructorInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredEvents"])) {
                (<any>this).declaredEvents = [] as any;
                for (let item of _data["declaredEvents"])
                    (<any>this).declaredEvents!.push(EventInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredFields"])) {
                (<any>this).declaredFields = [] as any;
                for (let item of _data["declaredFields"])
                    (<any>this).declaredFields!.push(FieldInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredMembers"])) {
                (<any>this).declaredMembers = [] as any;
                for (let item of _data["declaredMembers"])
                    (<any>this).declaredMembers!.push(MemberInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredMethods"])) {
                (<any>this).declaredMethods = [] as any;
                for (let item of _data["declaredMethods"])
                    (<any>this).declaredMethods!.push(MethodInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredNestedTypes"])) {
                (<any>this).declaredNestedTypes = [] as any;
                for (let item of _data["declaredNestedTypes"])
                    (<any>this).declaredNestedTypes!.push(TypeInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredProperties"])) {
                (<any>this).declaredProperties = [] as any;
                for (let item of _data["declaredProperties"])
                    (<any>this).declaredProperties!.push(PropertyInfo.fromJS(item));
            }
            if (Array.isArray(_data["implementedInterfaces"])) {
                (<any>this).implementedInterfaces = [] as any;
                for (let item of _data["implementedInterfaces"])
                    (<any>this).implementedInterfaces!.push(Type.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TypeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        data["isInterface"] = this.isInterface;
        data["memberType"] = this.memberType;
        data["namespace"] = this.namespace;
        data["assemblyQualifiedName"] = this.assemblyQualifiedName;
        data["fullName"] = this.fullName;
        data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        data["isNested"] = this.isNested;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["declaringMethod"] = this.declaringMethod ? this.declaringMethod.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["underlyingSystemType"] = this.underlyingSystemType ? this.underlyingSystemType.toJSON() : <any>undefined;
        data["isTypeDefinition"] = this.isTypeDefinition;
        data["isArray"] = this.isArray;
        data["isByRef"] = this.isByRef;
        data["isPointer"] = this.isPointer;
        data["isConstructedGenericType"] = this.isConstructedGenericType;
        data["isGenericParameter"] = this.isGenericParameter;
        data["isGenericTypeParameter"] = this.isGenericTypeParameter;
        data["isGenericMethodParameter"] = this.isGenericMethodParameter;
        data["isGenericType"] = this.isGenericType;
        data["isGenericTypeDefinition"] = this.isGenericTypeDefinition;
        data["isSZArray"] = this.isSZArray;
        data["isVariableBoundArray"] = this.isVariableBoundArray;
        data["isByRefLike"] = this.isByRefLike;
        data["isFunctionPointer"] = this.isFunctionPointer;
        data["isUnmanagedFunctionPointer"] = this.isUnmanagedFunctionPointer;
        data["hasElementType"] = this.hasElementType;
        if (Array.isArray(this.genericTypeArguments)) {
            data["genericTypeArguments"] = [];
            for (let item of this.genericTypeArguments)
                data["genericTypeArguments"].push(item.toJSON());
        }
        data["genericParameterPosition"] = this.genericParameterPosition;
        data["genericParameterAttributes"] = this.genericParameterAttributes;
        data["attributes"] = this.attributes;
        data["isAbstract"] = this.isAbstract;
        data["isImport"] = this.isImport;
        data["isSealed"] = this.isSealed;
        data["isSpecialName"] = this.isSpecialName;
        data["isClass"] = this.isClass;
        data["isNestedAssembly"] = this.isNestedAssembly;
        data["isNestedFamANDAssem"] = this.isNestedFamANDAssem;
        data["isNestedFamily"] = this.isNestedFamily;
        data["isNestedFamORAssem"] = this.isNestedFamORAssem;
        data["isNestedPrivate"] = this.isNestedPrivate;
        data["isNestedPublic"] = this.isNestedPublic;
        data["isNotPublic"] = this.isNotPublic;
        data["isPublic"] = this.isPublic;
        data["isAutoLayout"] = this.isAutoLayout;
        data["isExplicitLayout"] = this.isExplicitLayout;
        data["isLayoutSequential"] = this.isLayoutSequential;
        data["isAnsiClass"] = this.isAnsiClass;
        data["isAutoClass"] = this.isAutoClass;
        data["isUnicodeClass"] = this.isUnicodeClass;
        data["isCOMObject"] = this.isCOMObject;
        data["isContextful"] = this.isContextful;
        data["isEnum"] = this.isEnum;
        data["isMarshalByRef"] = this.isMarshalByRef;
        data["isPrimitive"] = this.isPrimitive;
        data["isValueType"] = this.isValueType;
        data["isSignatureType"] = this.isSignatureType;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["structLayoutAttribute"] = this.structLayoutAttribute ? this.structLayoutAttribute.toJSON() : <any>undefined;
        data["typeInitializer"] = this.typeInitializer ? this.typeInitializer.toJSON() : <any>undefined;
        data["typeHandle"] = this.typeHandle ? this.typeHandle.toJSON() : <any>undefined;
        data["guid"] = this.guid;
        data["baseType"] = this.baseType ? this.baseType.toJSON() : <any>undefined;
        data["isSerializable"] = this.isSerializable;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["isVisible"] = this.isVisible;
        if (Array.isArray(this.genericTypeParameters)) {
            data["genericTypeParameters"] = [];
            for (let item of this.genericTypeParameters)
                data["genericTypeParameters"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredConstructors)) {
            data["declaredConstructors"] = [];
            for (let item of this.declaredConstructors)
                data["declaredConstructors"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredEvents)) {
            data["declaredEvents"] = [];
            for (let item of this.declaredEvents)
                data["declaredEvents"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredFields)) {
            data["declaredFields"] = [];
            for (let item of this.declaredFields)
                data["declaredFields"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredMembers)) {
            data["declaredMembers"] = [];
            for (let item of this.declaredMembers)
                data["declaredMembers"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredMethods)) {
            data["declaredMethods"] = [];
            for (let item of this.declaredMethods)
                data["declaredMethods"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredNestedTypes)) {
            data["declaredNestedTypes"] = [];
            for (let item of this.declaredNestedTypes)
                data["declaredNestedTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredProperties)) {
            data["declaredProperties"] = [];
            for (let item of this.declaredProperties)
                data["declaredProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.implementedInterfaces)) {
            data["implementedInterfaces"] = [];
            for (let item of this.implementedInterfaces)
                data["implementedInterfaces"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITypeInfo {
    name?: string | undefined;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
    isInterface?: boolean;
    memberType?: TypeInfoMemberType;
    namespace?: string | undefined;
    assemblyQualifiedName?: string | undefined;
    fullName?: string | undefined;
    assembly?: Assembly;
    module?: Module;
    isNested?: boolean;
    declaringType?: Type;
    declaringMethod?: MethodBase;
    reflectedType?: Type;
    underlyingSystemType?: Type;
    isTypeDefinition?: boolean;
    isArray?: boolean;
    isByRef?: boolean;
    isPointer?: boolean;
    isConstructedGenericType?: boolean;
    isGenericParameter?: boolean;
    isGenericTypeParameter?: boolean;
    isGenericMethodParameter?: boolean;
    isGenericType?: boolean;
    isGenericTypeDefinition?: boolean;
    isSZArray?: boolean;
    isVariableBoundArray?: boolean;
    isByRefLike?: boolean;
    isFunctionPointer?: boolean;
    isUnmanagedFunctionPointer?: boolean;
    hasElementType?: boolean;
    genericTypeArguments?: Type[] | undefined;
    genericParameterPosition?: number;
    genericParameterAttributes?: TypeInfoGenericParameterAttributes;
    attributes?: TypeInfoAttributes;
    isAbstract?: boolean;
    isImport?: boolean;
    isSealed?: boolean;
    isSpecialName?: boolean;
    isClass?: boolean;
    isNestedAssembly?: boolean;
    isNestedFamANDAssem?: boolean;
    isNestedFamily?: boolean;
    isNestedFamORAssem?: boolean;
    isNestedPrivate?: boolean;
    isNestedPublic?: boolean;
    isNotPublic?: boolean;
    isPublic?: boolean;
    isAutoLayout?: boolean;
    isExplicitLayout?: boolean;
    isLayoutSequential?: boolean;
    isAnsiClass?: boolean;
    isAutoClass?: boolean;
    isUnicodeClass?: boolean;
    isCOMObject?: boolean;
    isContextful?: boolean;
    isEnum?: boolean;
    isMarshalByRef?: boolean;
    isPrimitive?: boolean;
    isValueType?: boolean;
    isSignatureType?: boolean;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    structLayoutAttribute?: StructLayoutAttribute;
    typeInitializer?: ConstructorInfo;
    typeHandle?: RuntimeTypeHandle;
    guid?: string;
    baseType?: Type;
    isSerializable?: boolean;
    containsGenericParameters?: boolean;
    isVisible?: boolean;
    genericTypeParameters?: Type[] | undefined;
    declaredConstructors?: ConstructorInfo[] | undefined;
    declaredEvents?: EventInfo[] | undefined;
    declaredFields?: FieldInfo[] | undefined;
    declaredMembers?: MemberInfo[] | undefined;
    declaredMethods?: MethodInfo[] | undefined;
    declaredNestedTypes?: TypeInfo[] | undefined;
    declaredProperties?: PropertyInfo[] | undefined;
    implementedInterfaces?: Type[] | undefined;
}

export class UpdateCategoryCommand implements IUpdateCategoryCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    categoryId?: string;
    name?: string | undefined;

    constructor(data?: IUpdateCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateCategoryCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    categoryId?: string;
    name?: string | undefined;
}

export class UpdateClientProfileCommand implements IUpdateClientProfileCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    clientId?: string;
    companyName?: string | undefined;
    companyDescription?: string | undefined;
    companyWebsite?: string | undefined;
    location?: string | undefined;
    companyLogo?: CreateFileDto;
    employerType?: UpdateClientProfileCommandEmployerType | undefined;
    phoneNumber?: string | undefined;

    constructor(data?: IUpdateClientProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.clientId = _data["clientId"];
            this.companyName = _data["companyName"];
            this.companyDescription = _data["companyDescription"];
            this.companyWebsite = _data["companyWebsite"];
            this.location = _data["location"];
            this.companyLogo = _data["companyLogo"] ? CreateFileDto.fromJS(_data["companyLogo"]) : <any>undefined;
            this.employerType = _data["employerType"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): UpdateClientProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["clientId"] = this.clientId;
        data["companyName"] = this.companyName;
        data["companyDescription"] = this.companyDescription;
        data["companyWebsite"] = this.companyWebsite;
        data["location"] = this.location;
        data["companyLogo"] = this.companyLogo ? this.companyLogo.toJSON() : <any>undefined;
        data["employerType"] = this.employerType;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface IUpdateClientProfileCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    clientId?: string;
    companyName?: string | undefined;
    companyDescription?: string | undefined;
    companyWebsite?: string | undefined;
    location?: string | undefined;
    companyLogo?: CreateFileDto;
    employerType?: UpdateClientProfileCommandEmployerType | undefined;
    phoneNumber?: string | undefined;
}

export class UpdateContestCommand implements IUpdateContestCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contestId?: string;
    title?: string | undefined;
    description?: string | undefined;
    prizePool?: number | undefined;

    constructor(data?: IUpdateContestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contestId = _data["contestId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.prizePool = _data["prizePool"];
        }
    }

    static fromJS(data: any): UpdateContestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contestId"] = this.contestId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["prizePool"] = this.prizePool;
        return data;
    }
}

export interface IUpdateContestCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contestId?: string;
    title?: string | undefined;
    description?: string | undefined;
    prizePool?: number | undefined;
}

export class UpdateFreelancerProfileCommand implements IUpdateFreelancerProfileCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    skills?: string[] | undefined;
    experience?: string | undefined;
    resume?: string | undefined;
    hourlyRate?: number | undefined;
    availability?: UpdateFreelancerProfileCommandAvailability | undefined;

    constructor(data?: IUpdateFreelancerProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(item);
            }
            this.experience = _data["experience"];
            this.resume = _data["resume"];
            this.hourlyRate = _data["hourlyRate"];
            this.availability = _data["availability"];
        }
    }

    static fromJS(data: any): UpdateFreelancerProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFreelancerProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item);
        }
        data["experience"] = this.experience;
        data["resume"] = this.resume;
        data["hourlyRate"] = this.hourlyRate;
        data["availability"] = this.availability;
        return data;
    }
}

export interface IUpdateFreelancerProfileCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    skills?: string[] | undefined;
    experience?: string | undefined;
    resume?: string | undefined;
    hourlyRate?: number | undefined;
    availability?: UpdateFreelancerProfileCommandAvailability | undefined;
}

export class UpdateFreelancerTeamCommand implements IUpdateFreelancerTeamCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    teamId?: string;
    name?: string | undefined;
    avatarFile?: CreateFileDto;
    closed?: boolean | undefined;
    closedReason?: string | undefined;

    constructor(data?: IUpdateFreelancerTeamCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.teamId = _data["teamId"];
            this.name = _data["name"];
            this.avatarFile = _data["avatarFile"] ? CreateFileDto.fromJS(_data["avatarFile"]) : <any>undefined;
            this.closed = _data["closed"];
            this.closedReason = _data["closedReason"];
        }
    }

    static fromJS(data: any): UpdateFreelancerTeamCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFreelancerTeamCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["teamId"] = this.teamId;
        data["name"] = this.name;
        data["avatarFile"] = this.avatarFile ? this.avatarFile.toJSON() : <any>undefined;
        data["closed"] = this.closed;
        data["closedReason"] = this.closedReason;
        return data;
    }
}

export interface IUpdateFreelancerTeamCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    teamId?: string;
    name?: string | undefined;
    avatarFile?: CreateFileDto;
    closed?: boolean | undefined;
    closedReason?: string | undefined;
}

export class UpdateJobCommand implements IUpdateJobCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    jobId?: string;
    title?: string | undefined;
    description?: string | undefined;
    requiredSkillIds?: string[] | undefined;
    categoryId?: string | undefined;
    budget?: number | undefined;
    hourlyRate?: number | undefined;
    expirationDate?: Date | undefined;
    duration?: number | undefined;
    files?: CreateFileDto[] | undefined;

    constructor(data?: IUpdateJobCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.jobId = _data["jobId"];
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["requiredSkillIds"])) {
                this.requiredSkillIds = [] as any;
                for (let item of _data["requiredSkillIds"])
                    this.requiredSkillIds!.push(item);
            }
            this.categoryId = _data["categoryId"];
            this.budget = _data["budget"];
            this.hourlyRate = _data["hourlyRate"];
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(CreateFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateJobCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateJobCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["jobId"] = this.jobId;
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.requiredSkillIds)) {
            data["requiredSkillIds"] = [];
            for (let item of this.requiredSkillIds)
                data["requiredSkillIds"].push(item);
        }
        data["categoryId"] = this.categoryId;
        data["budget"] = this.budget;
        data["hourlyRate"] = this.hourlyRate;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["duration"] = this.duration;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateJobCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    jobId?: string;
    title?: string | undefined;
    description?: string | undefined;
    requiredSkillIds?: string[] | undefined;
    categoryId?: string | undefined;
    budget?: number | undefined;
    hourlyRate?: number | undefined;
    expirationDate?: Date | undefined;
    duration?: number | undefined;
    files?: CreateFileDto[] | undefined;
}

export class UpdatePortfolioProjectCommand implements IUpdatePortfolioProjectCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    projectId?: string;
    name?: string | undefined;
    userRole?: string | undefined;
    skills?: string[] | undefined;
    description?: string | undefined;
    images?: CreateFileDto[] | undefined;
    hidden?: boolean | undefined;

    constructor(data?: IUpdatePortfolioProjectCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.projectId = _data["projectId"];
            this.name = _data["name"];
            this.userRole = _data["userRole"];
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(item);
            }
            this.description = _data["description"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(CreateFileDto.fromJS(item));
            }
            this.hidden = _data["hidden"];
        }
    }

    static fromJS(data: any): UpdatePortfolioProjectCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePortfolioProjectCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["projectId"] = this.projectId;
        data["name"] = this.name;
        data["userRole"] = this.userRole;
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item);
        }
        data["description"] = this.description;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["hidden"] = this.hidden;
        return data;
    }
}

export interface IUpdatePortfolioProjectCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    projectId?: string;
    name?: string | undefined;
    userRole?: string | undefined;
    skills?: string[] | undefined;
    description?: string | undefined;
    images?: CreateFileDto[] | undefined;
    hidden?: boolean | undefined;
}

export class UpdateProposalCommand implements IUpdateProposalCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    proposalId?: string;
    coverLetter?: string | undefined;
    proposedRate?: number | undefined;

    constructor(data?: IUpdateProposalCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.proposalId = _data["proposalId"];
            this.coverLetter = _data["coverLetter"];
            this.proposedRate = _data["proposedRate"];
        }
    }

    static fromJS(data: any): UpdateProposalCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProposalCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["proposalId"] = this.proposalId;
        data["coverLetter"] = this.coverLetter;
        data["proposedRate"] = this.proposedRate;
        return data;
    }
}

export interface IUpdateProposalCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    proposalId?: string;
    coverLetter?: string | undefined;
    proposedRate?: number | undefined;
}

export class UpdateSkillDto implements IUpdateSkillDto {
    skillId?: string;
    name?: string | undefined;

    constructor(data?: IUpdateSkillDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skillId = _data["skillId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateSkillDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSkillDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skillId"] = this.skillId;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateSkillDto {
    skillId?: string;
    name?: string | undefined;
}

export class UpdateSkillsCommand implements IUpdateSkillsCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    skills?: UpdateSkillDto[] | undefined;

    constructor(data?: IUpdateSkillsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(UpdateSkillDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateSkillsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSkillsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateSkillsCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    skills?: UpdateSkillDto[] | undefined;
}

export class UpdateTaskCommand implements IUpdateTaskCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    taskId?: string;
    title?: string | undefined;
    description?: string | undefined;
    priority?: number | undefined;

    constructor(data?: IUpdateTaskCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.taskId = _data["taskId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.priority = _data["priority"];
        }
    }

    static fromJS(data: any): UpdateTaskCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTaskCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["taskId"] = this.taskId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["priority"] = this.priority;
        return data;
    }
}

export interface IUpdateTaskCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    taskId?: string;
    title?: string | undefined;
    description?: string | undefined;
    priority?: number | undefined;
}

export class UpdateUserCommand implements IUpdateUserCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    userId!: string;
    email?: string | undefined;
    role?: UpdateUserCommandRole | undefined;
    avatar?: CreateFileDto;
    description?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    oldPassword?: string | undefined;
    newPassword?: string | undefined;
    telegramId?: string | undefined;

    constructor(data?: IUpdateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.role = _data["role"];
            this.avatar = _data["avatar"] ? CreateFileDto.fromJS(_data["avatar"]) : <any>undefined;
            this.description = _data["description"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
            this.telegramId = _data["telegramId"];
        }
    }

    static fromJS(data: any): UpdateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["role"] = this.role;
        data["avatar"] = this.avatar ? this.avatar.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        data["telegramId"] = this.telegramId;
        return data;
    }
}

export interface IUpdateUserCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    userId: string;
    email?: string | undefined;
    role?: UpdateUserCommandRole | undefined;
    avatar?: CreateFileDto;
    description?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    oldPassword?: string | undefined;
    newPassword?: string | undefined;
    telegramId?: string | undefined;
}

export class UserEntity implements IUserEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name!: string;
    surname!: string;
    fullname!: string;
    role?: UserEntityRole;
    type?: UserEntityType;
    email!: string;
    avatar?: FileEntity;
    isOnline!: boolean;
    isSuperadmin?: boolean;
    phone?: string | undefined;
    telegramId?: string | undefined;
    blocked?: boolean;
    location?: UserEntityLocation | undefined;
    readonly isExternalUser?: boolean;

    constructor(data?: IUserEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.fullname = _data["fullname"];
            this.role = _data["role"];
            this.type = _data["type"];
            this.email = _data["email"];
            this.avatar = _data["avatar"] ? FileEntity.fromJS(_data["avatar"]) : <any>undefined;
            this.isOnline = _data["isOnline"];
            this.isSuperadmin = _data["isSuperadmin"];
            this.phone = _data["phone"];
            this.telegramId = _data["telegramId"];
            this.blocked = _data["blocked"];
            this.location = _data["location"];
            (<any>this).isExternalUser = _data["isExternalUser"];
        }
    }

    static fromJS(data: any): UserEntity {
        data = typeof data === 'object' ? data : {};
        let result = new UserEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["fullname"] = this.fullname;
        data["role"] = this.role;
        data["type"] = this.type;
        data["email"] = this.email;
        data["avatar"] = this.avatar ? this.avatar.toJSON() : <any>undefined;
        data["isOnline"] = this.isOnline;
        data["isSuperadmin"] = this.isSuperadmin;
        data["phone"] = this.phone;
        data["telegramId"] = this.telegramId;
        data["blocked"] = this.blocked;
        data["location"] = this.location;
        data["isExternalUser"] = this.isExternalUser;
        return data;
    }
}

export interface IUserEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name: string;
    surname: string;
    fullname: string;
    role?: UserEntityRole;
    type?: UserEntityType;
    email: string;
    avatar?: FileEntity;
    isOnline: boolean;
    isSuperadmin?: boolean;
    phone?: string | undefined;
    telegramId?: string | undefined;
    blocked?: boolean;
    location?: UserEntityLocation | undefined;
    isExternalUser?: boolean;
}

export class WalletEntity implements IWalletEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    readonly userId!: string;
    user!: UserEntity;
    readonly currency!: WalletEntityCurrency;
    frozen!: Money;
    availableBalance!: Money;
    pendingIncome!: Money;
    readonly blocked!: boolean;
    readonly blockReason?: WalletEntityBlockReason;

    constructor(data?: IWalletEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEntity();
            this.frozen = new Money();
            this.availableBalance = new Money();
            this.pendingIncome = new Money();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            (<any>this).userId = _data["userId"];
            this.user = _data["user"] ? UserEntity.fromJS(_data["user"]) : new UserEntity();
            (<any>this).currency = _data["currency"];
            this.frozen = _data["frozen"] ? Money.fromJS(_data["frozen"]) : new Money();
            this.availableBalance = _data["availableBalance"] ? Money.fromJS(_data["availableBalance"]) : new Money();
            this.pendingIncome = _data["pendingIncome"] ? Money.fromJS(_data["pendingIncome"]) : new Money();
            (<any>this).blocked = _data["blocked"];
            (<any>this).blockReason = _data["blockReason"];
        }
    }

    static fromJS(data: any): WalletEntity {
        data = typeof data === 'object' ? data : {};
        let result = new WalletEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["currency"] = this.currency;
        data["frozen"] = this.frozen ? this.frozen.toJSON() : <any>undefined;
        data["availableBalance"] = this.availableBalance ? this.availableBalance.toJSON() : <any>undefined;
        data["pendingIncome"] = this.pendingIncome ? this.pendingIncome.toJSON() : <any>undefined;
        data["blocked"] = this.blocked;
        data["blockReason"] = this.blockReason;
        return data;
    }
}

export interface IWalletEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    userId: string;
    user: UserEntity;
    currency: WalletEntityCurrency;
    frozen: Money;
    availableBalance: Money;
    pendingIncome: Money;
    blocked: boolean;
    blockReason?: WalletEntityBlockReason;
}

export class WarnUserScheme implements IWarnUserScheme {
    reason?: string | undefined;

    constructor(data?: IWarnUserScheme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): WarnUserScheme {
        data = typeof data === 'object' ? data : {};
        let result = new WarnUserScheme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        return data;
    }
}

export interface IWarnUserScheme {
    reason?: string | undefined;
}

export class WithdrawProposalCommand implements IWithdrawProposalCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    proposalId?: string;

    constructor(data?: IWithdrawProposalCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.proposalId = _data["proposalId"];
        }
    }

    static fromJS(data: any): WithdrawProposalCommand {
        data = typeof data === 'object' ? data : {};
        let result = new WithdrawProposalCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["proposalId"] = this.proposalId;
        return data;
    }
}

export interface IWithdrawProposalCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    proposalId?: string;
}

export class WorkSessionEntity implements IWorkSessionEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    files?: FileEntity[] | undefined;
    contractId?: string;
    contract?: ContractEntity;
    freelancerId?: string;
    freelancer?: UserEntity;
    startDate?: Date;
    endDate?: Date | undefined;
    comment?: string | undefined;
    clientComment?: string | undefined;
    submittedAt?: Date | undefined;
    approvedAt?: Date | undefined;
    rejectedAt?: Date | undefined;
    status?: WorkSessionEntityStatus;
    readonly autoApproved?: boolean;

    constructor(data?: IWorkSessionEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(FileEntity.fromJS(item));
            }
            this.contractId = _data["contractId"];
            this.contract = _data["contract"] ? ContractEntity.fromJS(_data["contract"]) : <any>undefined;
            this.freelancerId = _data["freelancerId"];
            this.freelancer = _data["freelancer"] ? UserEntity.fromJS(_data["freelancer"]) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.comment = _data["comment"];
            this.clientComment = _data["clientComment"];
            this.submittedAt = _data["submittedAt"] ? new Date(_data["submittedAt"].toString()) : <any>undefined;
            this.approvedAt = _data["approvedAt"] ? new Date(_data["approvedAt"].toString()) : <any>undefined;
            this.rejectedAt = _data["rejectedAt"] ? new Date(_data["rejectedAt"].toString()) : <any>undefined;
            this.status = _data["status"];
            (<any>this).autoApproved = _data["autoApproved"];
        }
    }

    static fromJS(data: any): WorkSessionEntity {
        data = typeof data === 'object' ? data : {};
        let result = new WorkSessionEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["contractId"] = this.contractId;
        data["contract"] = this.contract ? this.contract.toJSON() : <any>undefined;
        data["freelancerId"] = this.freelancerId;
        data["freelancer"] = this.freelancer ? this.freelancer.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["clientComment"] = this.clientComment;
        data["submittedAt"] = this.submittedAt ? this.submittedAt.toISOString() : <any>undefined;
        data["approvedAt"] = this.approvedAt ? this.approvedAt.toISOString() : <any>undefined;
        data["rejectedAt"] = this.rejectedAt ? this.rejectedAt.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["autoApproved"] = this.autoApproved;
        return data;
    }
}

export interface IWorkSessionEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    files?: FileEntity[] | undefined;
    contractId?: string;
    contract?: ContractEntity;
    freelancerId?: string;
    freelancer?: UserEntity;
    startDate?: Date;
    endDate?: Date | undefined;
    comment?: string | undefined;
    clientComment?: string | undefined;
    submittedAt?: Date | undefined;
    approvedAt?: Date | undefined;
    rejectedAt?: Date | undefined;
    status?: WorkSessionEntityStatus;
    autoApproved?: boolean;
}

export enum AssemblySecurityRuleSet {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum BalanceOperationCommandBalanceOperationType {
    Freeze = "Freeze",
    Unfreeze = "Unfreeze",
    PendingIncome = "PendingIncome",
    Deposit = "Deposit",
    Withdrawl = "Withdrawl",
}

export enum BlockWalletCommandReason {
    None = "None",
    FraudSuspicion = "FraudSuspicion",
    LegalIssue = "LegalIssue",
    UserRequest = "UserRequest",
}

export enum CommandResultStatus {
    _100 = 100,
    _101 = 101,
    _102 = 102,
    _103 = 103,
    _200 = 200,
    _201 = 201,
    _202 = 202,
    _203 = 203,
    _204 = 204,
    _205 = 205,
    _206 = 206,
    _207 = 207,
    _208 = 208,
    _226 = 226,
    _300 = 300,
    _301 = 301,
    _302 = 302,
    _303 = 303,
    _304 = 304,
    _305 = 305,
    _306 = 306,
    _307 = 307,
    _308 = 308,
    _400 = 400,
    _401 = 401,
    _402 = 402,
    _403 = 403,
    _404 = 404,
    _405 = 405,
    _406 = 406,
    _407 = 407,
    _408 = 408,
    _409 = 409,
    _410 = 410,
    _411 = 411,
    _412 = 412,
    _413 = 413,
    _414 = 414,
    _415 = 415,
    _416 = 416,
    _417 = 417,
    _421 = 421,
    _422 = 422,
    _423 = 423,
    _424 = 424,
    _426 = 426,
    _428 = 428,
    _429 = 429,
    _431 = 431,
    _451 = 451,
    _500 = 500,
    _501 = 501,
    _502 = 502,
    _503 = 503,
    _504 = 504,
    _505 = 505,
    _506 = 506,
    _507 = 507,
    _508 = 508,
    _510 = 510,
    _511 = 511,
}

export enum ConstructorInfoAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _1024 = 1024,
    _2048 = 2048,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _53248 = 53248,
}

export enum ConstructorInfoMethodImplementationFlags {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _4096 = 4096,
    _65535 = 65535,
}

export enum ConstructorInfoCallingConvention {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _32 = 32,
    _64 = 64,
}

export enum ConstructorInfoMemberType {
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _191 = 191,
}

export enum ContestEntityStatus {
    Draft = "Draft",
    Moderation = "Moderation",
    Approved = "Approved",
    Open = "Open",
    Ended = "Ended",
    WinnerSelected = "WinnerSelected",
}

export enum ContractEntityStatus {
    PendingApproval = "PendingApproval",
    Active = "Active",
    Paused = "Paused",
    Completed = "Completed",
    Disputed = "Disputed",
    Cancelled = "Cancelled",
    Expired = "Expired",
    Closed = "Closed",
    PendingFinishApproval = "PendingFinishApproval",
}

export enum ContractEntityBudgetType {
    Hourly = "Hourly",
    Fixed = "Fixed",
}

export enum ContractEntityPaymentSchedule {
    Milestone = "Milestone",
    Weekly = "Weekly",
    Monthly = "Monthly",
    OnCompletion = "OnCompletion",
}

export enum CreateClientProfileCommandEmployerType {
    Company = "Company",
    Indivdual = "Indivdual",
}

export enum CreateContractCommandBudgetType {
    Hourly = "Hourly",
    Fixed = "Fixed",
}

export enum CreateContractCommandPaymentSchedule {
    Milestone = "Milestone",
    Weekly = "Weekly",
    Monthly = "Monthly",
    OnCompletion = "OnCompletion",
}

export enum CreateJobCommandBudgetType {
    Hourly = "Hourly",
    Fixed = "Fixed",
}

export enum CreateJobCommandLevel {
    Beginner = "Beginner",
    Intermediate = "Intermediate",
    Expert = "Expert",
}

export enum CreateNotificationCommandRole {
    User = "User",
    Moderator = "Moderator",
    Admin = "Admin",
    Superadmin = "Superadmin",
}

export enum CreateNotificationCommandType {
    Freelancer = "Freelancer",
    Client = "Client",
    NonUser = "NonUser",
}

export enum EventInfoMemberType {
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _191 = 191,
}

export enum EventInfoAttributes {
    _0 = 0,
    _512 = 512,
    _1024 = 1024,
}

export enum FieldInfoMemberType {
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _191 = 191,
}

export enum FieldInfoAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _1024 = 1024,
    _4096 = 4096,
    _8192 = 8192,
    _32768 = 32768,
    _38144 = 38144,
}

export enum FreelancerProfileEntityAvailability {
    Open = "Open",
    Busy = "Busy",
    Vacation = "Vacation",
}

export enum GatewayResultCommandCurrency {
    RussianRuble = "RussianRuble",
    Dollar = "Dollar",
    Euro = "Euro",
}

export enum JobEntityStatus {
    Open = "Open",
    Expired = "Expired",
    Closed = "Closed",
    Accepted = "Accepted",
    InContract = "InContract",
    Draft = "Draft",
    Completed = "Completed",
    WaitingFreelancerApproval = "WaitingFreelancerApproval",
}

export enum JobEntityLevel {
    Beginner = "Beginner",
    Intermediate = "Intermediate",
    Expert = "Expert",
}

export enum JobEntityBudgetType {
    Hourly = "Hourly",
    Fixed = "Fixed",
}

export enum MemberInfoMemberType {
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _191 = 191,
}

export enum MethodBaseMemberType {
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _191 = 191,
}

export enum MethodBaseAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _1024 = 1024,
    _2048 = 2048,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _53248 = 53248,
}

export enum MethodBaseMethodImplementationFlags {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _4096 = 4096,
    _65535 = 65535,
}

export enum MethodBaseCallingConvention {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _32 = 32,
    _64 = 64,
}

export enum MethodInfoAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _1024 = 1024,
    _2048 = 2048,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _53248 = 53248,
}

export enum MethodInfoMethodImplementationFlags {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _4096 = 4096,
    _65535 = 65535,
}

export enum MethodInfoCallingConvention {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _32 = 32,
    _64 = 64,
}

export enum MethodInfoMemberType {
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _191 = 191,
}

export enum MoneyCurrency {
    RussianRuble = "RussianRuble",
    Dollar = "Dollar",
    Euro = "Euro",
}

export enum NotificationEntityType {
    System = "System",
    Payment = "Payment",
    Other = "Other",
}

export enum ParameterInfoAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _61440 = 61440,
}

export enum PropertyInfoMemberType {
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _191 = 191,
}

export enum PropertyInfoAttributes {
    _0 = 0,
    _512 = 512,
    _1024 = 1024,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _62464 = 62464,
}

export enum ProposalEntityStatus {
    Pending = "Pending",
    Accepted = "Accepted",
    Hidden = "Hidden",
}

export enum ResolveDisputeCommandStrategy {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum StartPaymentFlowCommandFlow {
    Incoming = "Incoming",
    Outgoing = "Outgoing",
    Internal = "Internal",
}

export enum StartPaymentFlowCommandType {
    Deposit = "Deposit",
    Withdrawal = "Withdrawal",
    Transfer = "Transfer",
    Refund = "Refund",
    SystemAdjustment = "SystemAdjustment",
    Bonus = "Bonus",
    Penalty = "Penalty",
}

export enum StructLayoutAttributeValue {
    _0 = 0,
    _2 = 2,
    _3 = 3,
}

export enum TicketEntityStatus {
    Open = "Open",
    Closed = "Closed",
    InProgress = "InProgress",
}

export enum TransactionEntityStatus {
    Pending = "Pending",
    Processing = "Processing",
    Completed = "Completed",
    Failed = "Failed",
    Cancelled = "Cancelled",
    Expired = "Expired",
    Reversed = "Reversed",
}

export enum TransactionEntityType {
    Deposit = "Deposit",
    Withdrawal = "Withdrawal",
    Transfer = "Transfer",
    Refund = "Refund",
    SystemAdjustment = "SystemAdjustment",
    Bonus = "Bonus",
    Penalty = "Penalty",
}

export enum TransactionEntityFlow {
    Incoming = "Incoming",
    Outgoing = "Outgoing",
    Internal = "Internal",
}

export enum TypeMemberType {
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _191 = 191,
}

export enum TypeGenericParameterAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _28 = 28,
}

export enum TypeAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _24 = 24,
    _32 = 32,
    _128 = 128,
    _256 = 256,
    _1024 = 1024,
    _2048 = 2048,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _65536 = 65536,
    _131072 = 131072,
    _196608 = 196608,
    _262144 = 262144,
    _264192 = 264192,
    _1048576 = 1048576,
    _12582912 = 12582912,
}

export enum TypeInfoMemberType {
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _191 = 191,
}

export enum TypeInfoGenericParameterAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _28 = 28,
}

export enum TypeInfoAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _24 = 24,
    _32 = 32,
    _128 = 128,
    _256 = 256,
    _1024 = 1024,
    _2048 = 2048,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _65536 = 65536,
    _131072 = 131072,
    _196608 = 196608,
    _262144 = 262144,
    _264192 = 264192,
    _1048576 = 1048576,
    _12582912 = 12582912,
}

export enum UpdateClientProfileCommandEmployerType {
    Company = "Company",
    Indivdual = "Indivdual",
}

export enum UpdateFreelancerProfileCommandAvailability {
    Open = "Open",
    Busy = "Busy",
    Vacation = "Vacation",
}

export enum UpdateUserCommandRole {
    User = "User",
    Moderator = "Moderator",
    Admin = "Admin",
    Superadmin = "Superadmin",
}

export enum UserEntityRole {
    User = "User",
    Moderator = "Moderator",
    Admin = "Admin",
    Superadmin = "Superadmin",
}

export enum UserEntityType {
    Freelancer = "Freelancer",
    Client = "Client",
    NonUser = "NonUser",
}

export enum UserEntityLocation {
    Kazakhstan = "Kazakhstan",
    Russia = "Russia",
    Belarus = "Belarus",
}

export enum WalletEntityCurrency {
    RussianRuble = "RussianRuble",
    Dollar = "Dollar",
    Euro = "Euro",
}

export enum WalletEntityBlockReason {
    None = "None",
    FraudSuspicion = "FraudSuspicion",
    LegalIssue = "LegalIssue",
    UserRequest = "UserRequest",
}

export enum WorkSessionEntityStatus {
    Pending = "Pending",
    Approved = "Approved",
    Rejected = "Rejected",
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}