//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.3.0.0 (NJsonSchema v11.2.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface IClient {

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body?: LoginUserSchema | undefined): Promise<CommandResult>;

    /**
     * @return Success
     */
    logout(): Promise<void>;

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body?: RegisterUserSchema | undefined): Promise<CommandResult>;

    /**
     * @return Success
     */
    externalLogin(provider: string): Promise<void>;

    /**
     * @return Success
     */
    externalLoginCallback(): Promise<void>;

    /**
     * @param body (optional) 
     * @return Success
     */
    sendResetPasswordCode(body?: SendResetCodeCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body?: ResetPasswordCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    createCategory(body?: CreateCategoryCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCategory(body?: UpdateCategoryCommand | undefined): Promise<CommandResult>;

    /**
     * @return Success
     */
    deleteCategory(categoryId: string): Promise<CommandResult>;

    /**
     * @param searchQuery (optional) 
     * @return Success
     */
    getCategories(searchQuery?: string | undefined): Promise<CategoryEntity[]>;

    /**
     * @return Success
     */
    getClientOrderInfo(userId: string): Promise<ClientJobInfo>;

    /**
     * @param body (optional) 
     * @return Success
     */
    createClientProfile(body?: CreateClientProfileCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    suspendClientProfile(body?: SuspendClientProfileCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    updateClientProfile(body?: UpdateClientProfileCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    createContest(body?: CreateContestCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    approveContest(body?: ApproveContestCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    startContest(body?: StartContestCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    endContest(body?: EndContestCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteContest(body?: DeleteContestCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    selectContestWinner(body?: SelectContestWinnerCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    submitContestEntry(body?: SubmitContestEntryCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteContestEntry(body?: DeleteContestEntryCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    updateContest(body?: UpdateContestCommand | undefined): Promise<CommandResult>;

    /**
     * @return Success
     */
    getContest(id: string): Promise<ContestEntity>;

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    getContestList(start?: number | undefined, end?: number | undefined): Promise<ContestEntity[]>;

    /**
     * @param body (optional) 
     * @return Success
     */
    createContract(body?: CreateContractCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    clientAcceptFinishContract(body?: ClientAcceptFinishContractCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    clientCloseContract(body?: ClientCloseContractCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    clientRejectContractCompletion(body?: ClientRejectContractCompletionCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    freelancerAcceptContract(body?: FreelancerAcceptContractCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    freelancerFinishContract(body?: FreelancerFinishContractCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    acceptDispute(body?: AcceptDisputeCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    initiateDispute(body?: InitiateDisputeCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    resolveDispute(body?: ResolveDisputeCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    forceContractCancel(body?: ForceContractCancelCommand | undefined): Promise<CommandResult>;

    /**
     * @return Success
     */
    getContract(id: string): Promise<ContractEntity>;

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    getContractsList(start?: number | undefined, end?: number | undefined): Promise<ContractEntity[]>;

    /**
     * @param file (optional) 
     * @return Success
     */
    uploadFile(file?: FileParameter | undefined): Promise<FileEntity>;

    /**
     * @return Success
     */
    downloadFile(fileId: string): Promise<void>;

    /**
     * @param body (optional) 
     * @return Success
     */
    createFreelancerProfile(body?: CreateFreelancerProfileCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    updateFreelancerProfile(body?: UpdateFreelancerProfileCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    hideFreelancerProfile(body?: HideFreelancerProfileCommand | undefined): Promise<CommandResult>;

    /**
     * @return Success
     */
    getFreelancerProfile(userId: string): Promise<FreelancerProfileEntity>;

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @param skills (optional) 
     * @param minCost (optional) 
     * @param maxCost (optional) 
     * @param minReviews (optional) 
     * @param maxReviews (optional) 
     * @return Success
     */
    getFreelancerProfileList(start?: number | undefined, end?: number | undefined, skills?: string[] | undefined, minCost?: number | undefined, maxCost?: number | undefined, minReviews?: number | undefined, maxReviews?: number | undefined): Promise<FreelancerProfileEntity[]>;

    /**
     * @param body (optional) 
     * @return Success
     */
    createFreelancerTeam(body?: CreateFreelancerTeamCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    updateFreelancerTeam(body?: UpdateFreelancerTeamCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteFreelancerTeam(body?: DeleteFreelancerTeamCommand | undefined): Promise<CommandResult>;

    /**
     * @return Success
     */
    getFreelancerTeams(): Promise<FreelancerTeamEntity[]>;

    /**
     * @param body (optional) 
     * @return Success
     */
    createJob(body?: CreateJobCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    updateJob(body?: UpdateJobCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteJob(body?: DeleteJobCommand | undefined): Promise<CommandResult>;

    /**
     * @return Success
     */
    getJob(id: string): Promise<JobDetails>;

    /**
     * @return Success
     */
    getRawJob(id: string): Promise<JobEntity>;

    /**
     * @param body (optional) 
     * @return Success
     */
    getJobsList(body?: GetJobsListQuery | undefined): Promise<JobEntity[]>;

    /**
     * @param body (optional) 
     * @return Success
     */
    bookmarkJob(body?: BookmarkJobCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    hideJob(body?: HideJobCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    submitProposal(body?: SubmitProposalCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProposal(body?: UpdateProposalCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    withdrawProposal(body?: WithdrawProposalCommand | undefined): Promise<CommandResult>;

    /**
     * @return Success
     */
    getBookmarksList(): Promise<JobEntity[]>;

    /**
     * @param start (optional) 
     * @param ends (optional) 
     * @return Success
     */
    getNotifications(userId: string, start?: number | undefined, ends?: number | undefined): Promise<NotificationEntity[]>;

    /**
     * @param body (optional) 
     * @return Success
     */
    createNotification(body?: CreateNotificationCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    createPortfolioProject(body?: AddPortfolioProjectCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePortfolioProject(body?: UpdatePortfolioProjectCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    deletePortfolioProject(body?: DeletePortfolioProjectCommand | undefined): Promise<CommandResult>;

    /**
     * @return Success
     */
    getPortfolioProjects(): Promise<PortfolioProjectEntity[]>;

    /**
     * @param body (optional) 
     * @return Success
     */
    createSkills(body?: CreateSkillsCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSkills(body?: UpdateSkillsCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteSkills(body?: DeleteSkillsCommand | undefined): Promise<CommandResult>;

    /**
     * @param searchQuery (optional) 
     * @return Success
     */
    getSkills(searchQuery?: string | undefined): Promise<SkillModel[]>;

    /**
     * @return Success
     */
    blockUser(userId: string): Promise<boolean>;

    /**
     * @param body (optional) 
     * @return Success
     */
    warnUser(userId: string, body?: WarnUserScheme | undefined): Promise<boolean>;

    /**
     * @param body (optional) 
     * @return Success
     */
    createTicket(body?: CreateTicketDto | undefined): Promise<TicketEntity>;

    /**
     * @param body (optional) 
     * @return Success
     */
    getTickets(body?: GetTicketsDto | undefined): Promise<TicketEntity[]>;

    /**
     * @return Success
     */
    getTicket(ticketId: string): Promise<TicketEntity>;

    /**
     * @param body (optional) 
     * @return Success
     */
    createTask(body?: CreateTaskCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    completeTask(body?: CompleteTaskCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    reactToTask(body?: ReactToTaskCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTask(body?: UpdateTaskCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteTask(body?: DeleteTaskCommand | undefined): Promise<CommandResult>;

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    getTasks(contractId: string, start?: number | undefined, end?: number | undefined): Promise<TransactionEntity[]>;

    /**
     * @param body (optional) 
     * @return Success
     */
    handleTransaction(body?: HandleTransactionCommand | undefined): Promise<CommandResult>;

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    getTransactionsList(start?: number | undefined, end?: number | undefined): Promise<TransactionEntity[]>;

    /**
     * @return Success
     */
    getTransactionProviders(): Promise<TransactionProviderEntity[]>;

    /**
     * @param body (optional) 
     * @return Success
     */
    handleDepositGatewayResult(body?: GatewayResultCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    refundTransaction(body?: RefundTransactionCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    handleWithdrawalGatewayResult(body?: GatewayResultCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    startPaymentFlow(body?: StartPaymentFlowCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUser(userId: string, body?: UpdateUserCommand | undefined): Promise<boolean>;

    /**
     * @return Success
     */
    getUserById(userId: string): Promise<UserEntity>;

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMe(body?: UpdateUserCommand | undefined): Promise<boolean>;

    /**
     * @return Success
     */
    getMe(): Promise<UserEntity>;

    /**
     * @param body (optional) 
     * @return Success
     */
    balanceOperation(body?: BalanceOperationCommand | undefined): Promise<CommandResult>;

    /**
     * @return Success
     */
    getWallet(walletId: string): Promise<WalletEntity>;

    /**
     * @param body (optional) 
     * @return Success
     */
    blockWallet(body?: BlockWalletCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    startSession(body?: StartWorkSessionCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    submitSession(body?: SubmitWorkSessionCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    endSession(body?: EndWorkSessionCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    approveSession(body?: ApproveWorkSessionCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return Success
     */
    reactSession(body?: ReactToWorkSessionCommand | undefined): Promise<CommandResult>;

    /**
     * @return Success
     */
    getSession(id: string): Promise<WorkSessionEntity>;

    /**
     * @param contractId (optional) 
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    getSessionList(contractId?: string | undefined, start?: number | undefined, end?: number | undefined): Promise<WorkSessionEntity[]>;
}

export class Client implements IClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body?: LoginUserSchema | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return Success
     */
    logout(): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body?: RegisterUserSchema | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return Success
     */
    externalLogin(provider: string): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/external-login/{provider}";
        if (provider === undefined || provider === null)
            throw new Error("The parameter 'provider' must be defined.");
        url_ = url_.replace("{provider}", encodeURIComponent("" + provider));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExternalLogin(_response);
        });
    }

    protected processExternalLogin(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    externalLoginCallback(): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/external-login-callback";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExternalLoginCallback(_response);
        });
    }

    protected processExternalLoginCallback(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendResetPasswordCode(body?: SendResetCodeCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/auth/send-reset-code";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendResetPasswordCode(_response);
        });
    }

    protected processSendResetPasswordCode(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body?: ResetPasswordCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/auth/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCategory(body?: CreateCategoryCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/category/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCategory(_response);
        });
    }

    protected processCreateCategory(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCategory(body?: UpdateCategoryCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/category/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCategory(_response);
        });
    }

    protected processUpdateCategory(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return Success
     */
    deleteCategory(categoryId: string): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/category/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCategory(_response);
        });
    }

    protected processDeleteCategory(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param searchQuery (optional) 
     * @return Success
     */
    getCategories(searchQuery?: string | undefined): Promise<CategoryEntity[]> {
        let url_ = this.baseUrl + "/api/category/list?";
        if (searchQuery === null)
            throw new Error("The parameter 'searchQuery' cannot be null.");
        else if (searchQuery !== undefined)
            url_ += "searchQuery=" + encodeURIComponent("" + searchQuery) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCategories(_response);
        });
    }

    protected processGetCategories(response: Response): Promise<CategoryEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CategoryEntity[]>(null as any);
    }

    /**
     * @return Success
     */
    getClientOrderInfo(userId: string): Promise<ClientJobInfo> {
        let url_ = this.baseUrl + "/api/client-profile/order-info/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetClientOrderInfo(_response);
        });
    }

    protected processGetClientOrderInfo(response: Response): Promise<ClientJobInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientJobInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientJobInfo>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createClientProfile(body?: CreateClientProfileCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/client-profile/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateClientProfile(_response);
        });
    }

    protected processCreateClientProfile(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    suspendClientProfile(body?: SuspendClientProfileCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/client-profile/suspend";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSuspendClientProfile(_response);
        });
    }

    protected processSuspendClientProfile(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateClientProfile(body?: UpdateClientProfileCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/client-profile/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateClientProfile(_response);
        });
    }

    protected processUpdateClientProfile(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createContest(body?: CreateContestCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateContest(_response);
        });
    }

    protected processCreateContest(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveContest(body?: ApproveContestCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApproveContest(_response);
        });
    }

    protected processApproveContest(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    startContest(body?: StartContestCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/start";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartContest(_response);
        });
    }

    protected processStartContest(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    endContest(body?: EndContestCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/end";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEndContest(_response);
        });
    }

    protected processEndContest(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteContest(body?: DeleteContestCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteContest(_response);
        });
    }

    protected processDeleteContest(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    selectContestWinner(body?: SelectContestWinnerCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/select-winner";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSelectContestWinner(_response);
        });
    }

    protected processSelectContestWinner(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submitContestEntry(body?: SubmitContestEntryCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/submit-entry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubmitContestEntry(_response);
        });
    }

    protected processSubmitContestEntry(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteContestEntry(body?: DeleteContestEntryCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/delete-entry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteContestEntry(_response);
        });
    }

    protected processDeleteContestEntry(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateContest(body?: UpdateContestCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateContest(_response);
        });
    }

    protected processUpdateContest(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return Success
     */
    getContest(id: string): Promise<ContestEntity> {
        let url_ = this.baseUrl + "/api/contest/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContest(_response);
        });
    }

    protected processGetContest(response: Response): Promise<ContestEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContestEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContestEntity>(null as any);
    }

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    getContestList(start?: number | undefined, end?: number | undefined): Promise<ContestEntity[]> {
        let url_ = this.baseUrl + "/api/contest/list?";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent("" + end) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContestList(_response);
        });
    }

    protected processGetContestList(response: Response): Promise<ContestEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContestEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContestEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createContract(body?: CreateContractCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateContract(_response);
        });
    }

    protected processCreateContract(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clientAcceptFinishContract(body?: ClientAcceptFinishContractCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/client-accept-finish";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClientAcceptFinishContract(_response);
        });
    }

    protected processClientAcceptFinishContract(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clientCloseContract(body?: ClientCloseContractCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/client-close";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClientCloseContract(_response);
        });
    }

    protected processClientCloseContract(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clientRejectContractCompletion(body?: ClientRejectContractCompletionCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/client-reject-completion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClientRejectContractCompletion(_response);
        });
    }

    protected processClientRejectContractCompletion(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    freelancerAcceptContract(body?: FreelancerAcceptContractCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/freelancer-accept";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFreelancerAcceptContract(_response);
        });
    }

    protected processFreelancerAcceptContract(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    freelancerFinishContract(body?: FreelancerFinishContractCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/freelancer-finish";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFreelancerFinishContract(_response);
        });
    }

    protected processFreelancerFinishContract(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    acceptDispute(body?: AcceptDisputeCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/accept-dispute";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAcceptDispute(_response);
        });
    }

    protected processAcceptDispute(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    initiateDispute(body?: InitiateDisputeCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/initiate-dispute";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInitiateDispute(_response);
        });
    }

    protected processInitiateDispute(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resolveDispute(body?: ResolveDisputeCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/resolve-dispute";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResolveDispute(_response);
        });
    }

    protected processResolveDispute(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    forceContractCancel(body?: ForceContractCancelCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/force-cancel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForceContractCancel(_response);
        });
    }

    protected processForceContractCancel(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return Success
     */
    getContract(id: string): Promise<ContractEntity> {
        let url_ = this.baseUrl + "/api/contract/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContract(_response);
        });
    }

    protected processGetContract(response: Response): Promise<ContractEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractEntity>(null as any);
    }

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    getContractsList(start?: number | undefined, end?: number | undefined): Promise<ContractEntity[]> {
        let url_ = this.baseUrl + "/api/contract/list?";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent("" + end) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContractsList(_response);
        });
    }

    protected processGetContractsList(response: Response): Promise<ContractEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContractEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractEntity[]>(null as any);
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    uploadFile(file?: FileParameter | undefined): Promise<FileEntity> {
        let url_ = this.baseUrl + "/api/files/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadFile(_response);
        });
    }

    protected processUploadFile(response: Response): Promise<FileEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileEntity>(null as any);
    }

    /**
     * @return Success
     */
    downloadFile(fileId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/files/download/{fileId}";
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownloadFile(_response);
        });
    }

    protected processDownloadFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFreelancerProfile(body?: CreateFreelancerProfileCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/freelancer-profile/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateFreelancerProfile(_response);
        });
    }

    protected processCreateFreelancerProfile(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateFreelancerProfile(body?: UpdateFreelancerProfileCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/freelancer-profile/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateFreelancerProfile(_response);
        });
    }

    protected processUpdateFreelancerProfile(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hideFreelancerProfile(body?: HideFreelancerProfileCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/freelancer-profile/hide";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHideFreelancerProfile(_response);
        });
    }

    protected processHideFreelancerProfile(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return Success
     */
    getFreelancerProfile(userId: string): Promise<FreelancerProfileEntity> {
        let url_ = this.baseUrl + "/api/freelancer-profile/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFreelancerProfile(_response);
        });
    }

    protected processGetFreelancerProfile(response: Response): Promise<FreelancerProfileEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FreelancerProfileEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FreelancerProfileEntity>(null as any);
    }

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @param skills (optional) 
     * @param minCost (optional) 
     * @param maxCost (optional) 
     * @param minReviews (optional) 
     * @param maxReviews (optional) 
     * @return Success
     */
    getFreelancerProfileList(start?: number | undefined, end?: number | undefined, skills?: string[] | undefined, minCost?: number | undefined, maxCost?: number | undefined, minReviews?: number | undefined, maxReviews?: number | undefined): Promise<FreelancerProfileEntity[]> {
        let url_ = this.baseUrl + "/api/freelancer-profile/list?";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent("" + end) + "&";
        if (skills === null)
            throw new Error("The parameter 'skills' cannot be null.");
        else if (skills !== undefined)
            skills && skills.forEach(item => { url_ += "skills=" + encodeURIComponent("" + item) + "&"; });
        if (minCost === null)
            throw new Error("The parameter 'minCost' cannot be null.");
        else if (minCost !== undefined)
            url_ += "minCost=" + encodeURIComponent("" + minCost) + "&";
        if (maxCost === null)
            throw new Error("The parameter 'maxCost' cannot be null.");
        else if (maxCost !== undefined)
            url_ += "maxCost=" + encodeURIComponent("" + maxCost) + "&";
        if (minReviews === null)
            throw new Error("The parameter 'minReviews' cannot be null.");
        else if (minReviews !== undefined)
            url_ += "minReviews=" + encodeURIComponent("" + minReviews) + "&";
        if (maxReviews === null)
            throw new Error("The parameter 'maxReviews' cannot be null.");
        else if (maxReviews !== undefined)
            url_ += "maxReviews=" + encodeURIComponent("" + maxReviews) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFreelancerProfileList(_response);
        });
    }

    protected processGetFreelancerProfileList(response: Response): Promise<FreelancerProfileEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FreelancerProfileEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FreelancerProfileEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFreelancerTeam(body?: CreateFreelancerTeamCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/freelancer-team/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateFreelancerTeam(_response);
        });
    }

    protected processCreateFreelancerTeam(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateFreelancerTeam(body?: UpdateFreelancerTeamCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/freelancer-team/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateFreelancerTeam(_response);
        });
    }

    protected processUpdateFreelancerTeam(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteFreelancerTeam(body?: DeleteFreelancerTeamCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/freelancer-team/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteFreelancerTeam(_response);
        });
    }

    protected processDeleteFreelancerTeam(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return Success
     */
    getFreelancerTeams(): Promise<FreelancerTeamEntity[]> {
        let url_ = this.baseUrl + "/api/freelancer-team/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFreelancerTeams(_response);
        });
    }

    protected processGetFreelancerTeams(response: Response): Promise<FreelancerTeamEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FreelancerTeamEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FreelancerTeamEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createJob(body?: CreateJobCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateJob(_response);
        });
    }

    protected processCreateJob(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateJob(body?: UpdateJobCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateJob(_response);
        });
    }

    protected processUpdateJob(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteJob(body?: DeleteJobCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteJob(_response);
        });
    }

    protected processDeleteJob(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return Success
     */
    getJob(id: string): Promise<JobDetails> {
        let url_ = this.baseUrl + "/api/job/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetJob(_response);
        });
    }

    protected processGetJob(response: Response): Promise<JobDetails> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobDetails.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JobDetails>(null as any);
    }

    /**
     * @return Success
     */
    getRawJob(id: string): Promise<JobEntity> {
        let url_ = this.baseUrl + "/api/job/{id}/raw";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRawJob(_response);
        });
    }

    protected processGetRawJob(response: Response): Promise<JobEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JobEntity>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getJobsList(body?: GetJobsListQuery | undefined): Promise<JobEntity[]> {
        let url_ = this.baseUrl + "/api/job/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetJobsList(_response);
        });
    }

    protected processGetJobsList(response: Response): Promise<JobEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JobEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JobEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bookmarkJob(body?: BookmarkJobCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/bookmark";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBookmarkJob(_response);
        });
    }

    protected processBookmarkJob(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hideJob(body?: HideJobCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/hide";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHideJob(_response);
        });
    }

    protected processHideJob(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submitProposal(body?: SubmitProposalCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/submit-proposal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubmitProposal(_response);
        });
    }

    protected processSubmitProposal(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProposal(body?: UpdateProposalCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/update-proposal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProposal(_response);
        });
    }

    protected processUpdateProposal(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    withdrawProposal(body?: WithdrawProposalCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/withdraw-proposal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWithdrawProposal(_response);
        });
    }

    protected processWithdrawProposal(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return Success
     */
    getBookmarksList(): Promise<JobEntity[]> {
        let url_ = this.baseUrl + "/api/job/bookmarks";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBookmarksList(_response);
        });
    }

    protected processGetBookmarksList(response: Response): Promise<JobEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JobEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JobEntity[]>(null as any);
    }

    /**
     * @param start (optional) 
     * @param ends (optional) 
     * @return Success
     */
    getNotifications(userId: string, start?: number | undefined, ends?: number | undefined): Promise<NotificationEntity[]> {
        let url_ = this.baseUrl + "/api/notification/user/{userId}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "Start=" + encodeURIComponent("" + start) + "&";
        if (ends === null)
            throw new Error("The parameter 'ends' cannot be null.");
        else if (ends !== undefined)
            url_ += "Ends=" + encodeURIComponent("" + ends) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNotifications(_response);
        });
    }

    protected processGetNotifications(response: Response): Promise<NotificationEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NotificationEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createNotification(body?: CreateNotificationCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/notification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateNotification(_response);
        });
    }

    protected processCreateNotification(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPortfolioProject(body?: AddPortfolioProjectCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/portfolio-project/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreatePortfolioProject(_response);
        });
    }

    protected processCreatePortfolioProject(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePortfolioProject(body?: UpdatePortfolioProjectCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/portfolio-project/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdatePortfolioProject(_response);
        });
    }

    protected processUpdatePortfolioProject(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deletePortfolioProject(body?: DeletePortfolioProjectCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/portfolio-project/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeletePortfolioProject(_response);
        });
    }

    protected processDeletePortfolioProject(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return Success
     */
    getPortfolioProjects(): Promise<PortfolioProjectEntity[]> {
        let url_ = this.baseUrl + "/api/portfolio-project/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPortfolioProjects(_response);
        });
    }

    protected processGetPortfolioProjects(response: Response): Promise<PortfolioProjectEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PortfolioProjectEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PortfolioProjectEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSkills(body?: CreateSkillsCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/skill/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSkills(_response);
        });
    }

    protected processCreateSkills(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSkills(body?: UpdateSkillsCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/skill/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSkills(_response);
        });
    }

    protected processUpdateSkills(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteSkills(body?: DeleteSkillsCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/skill/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSkills(_response);
        });
    }

    protected processDeleteSkills(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param searchQuery (optional) 
     * @return Success
     */
    getSkills(searchQuery?: string | undefined): Promise<SkillModel[]> {
        let url_ = this.baseUrl + "/api/skill/list?";
        if (searchQuery === null)
            throw new Error("The parameter 'searchQuery' cannot be null.");
        else if (searchQuery !== undefined)
            url_ += "searchQuery=" + encodeURIComponent("" + searchQuery) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSkills(_response);
        });
    }

    protected processGetSkills(response: Response): Promise<SkillModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SkillModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SkillModel[]>(null as any);
    }

    /**
     * @return Success
     */
    blockUser(userId: string): Promise<boolean> {
        let url_ = this.baseUrl + "/api/stuff/user/{userId}/block";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBlockUser(_response);
        });
    }

    protected processBlockUser(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    warnUser(userId: string, body?: WarnUserScheme | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/stuff/user/{userId}/warn";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWarnUser(_response);
        });
    }

    protected processWarnUser(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTicket(body?: CreateTicketDto | undefined): Promise<TicketEntity> {
        let url_ = this.baseUrl + "/api/stuff/ticket";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTicket(_response);
        });
    }

    protected processCreateTicket(response: Response): Promise<TicketEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TicketEntity>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getTickets(body?: GetTicketsDto | undefined): Promise<TicketEntity[]> {
        let url_ = this.baseUrl + "/api/stuff/ticket";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTickets(_response);
        });
    }

    protected processGetTickets(response: Response): Promise<TicketEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TicketEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TicketEntity[]>(null as any);
    }

    /**
     * @return Success
     */
    getTicket(ticketId: string): Promise<TicketEntity> {
        let url_ = this.baseUrl + "/api/stuff/ticket/{ticketId}";
        if (ticketId === undefined || ticketId === null)
            throw new Error("The parameter 'ticketId' must be defined.");
        url_ = url_.replace("{ticketId}", encodeURIComponent("" + ticketId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTicket(_response);
        });
    }

    protected processGetTicket(response: Response): Promise<TicketEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TicketEntity>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTask(body?: CreateTaskCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/task/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTask(_response);
        });
    }

    protected processCreateTask(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completeTask(body?: CompleteTaskCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/task/complete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompleteTask(_response);
        });
    }

    protected processCompleteTask(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reactToTask(body?: ReactToTaskCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/task/react";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReactToTask(_response);
        });
    }

    protected processReactToTask(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTask(body?: UpdateTaskCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/task/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTask(_response);
        });
    }

    protected processUpdateTask(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteTask(body?: DeleteTaskCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/task/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTask(_response);
        });
    }

    protected processDeleteTask(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    getTasks(contractId: string, start?: number | undefined, end?: number | undefined): Promise<TransactionEntity[]> {
        let url_ = this.baseUrl + "/api/task/list/{contractId}?";
        if (contractId === undefined || contractId === null)
            throw new Error("The parameter 'contractId' must be defined.");
        url_ = url_.replace("{contractId}", encodeURIComponent("" + contractId));
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent("" + end) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTasks(_response);
        });
    }

    protected processGetTasks(response: Response): Promise<TransactionEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TransactionEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransactionEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    handleTransaction(body?: HandleTransactionCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/transaction/handle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHandleTransaction(_response);
        });
    }

    protected processHandleTransaction(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    getTransactionsList(start?: number | undefined, end?: number | undefined): Promise<TransactionEntity[]> {
        let url_ = this.baseUrl + "/api/transaction/list?";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent("" + end) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTransactionsList(_response);
        });
    }

    protected processGetTransactionsList(response: Response): Promise<TransactionEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TransactionEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransactionEntity[]>(null as any);
    }

    /**
     * @return Success
     */
    getTransactionProviders(): Promise<TransactionProviderEntity[]> {
        let url_ = this.baseUrl + "/api/transaction/providers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTransactionProviders(_response);
        });
    }

    protected processGetTransactionProviders(response: Response): Promise<TransactionProviderEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TransactionProviderEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransactionProviderEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    handleDepositGatewayResult(body?: GatewayResultCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/transaction/deposit-result";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHandleDepositGatewayResult(_response);
        });
    }

    protected processHandleDepositGatewayResult(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    refundTransaction(body?: RefundTransactionCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/transaction/refund";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefundTransaction(_response);
        });
    }

    protected processRefundTransaction(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    handleWithdrawalGatewayResult(body?: GatewayResultCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/transaction/withdrawal-result";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHandleWithdrawalGatewayResult(_response);
        });
    }

    protected processHandleWithdrawalGatewayResult(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    startPaymentFlow(body?: StartPaymentFlowCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/transaction/start";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartPaymentFlow(_response);
        });
    }

    protected processStartPaymentFlow(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUser(userId: string, body?: UpdateUserCommand | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/user/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    getUserById(userId: string): Promise<UserEntity> {
        let url_ = this.baseUrl + "/api/user/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserById(_response);
        });
    }

    protected processGetUserById(response: Response): Promise<UserEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserEntity>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMe(body?: UpdateUserCommand | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/user/me";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateMe(_response);
        });
    }

    protected processUpdateMe(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    getMe(): Promise<UserEntity> {
        let url_ = this.baseUrl + "/api/user/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMe(_response);
        });
    }

    protected processGetMe(response: Response): Promise<UserEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserEntity>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    balanceOperation(body?: BalanceOperationCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/wallet/balance-operation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBalanceOperation(_response);
        });
    }

    protected processBalanceOperation(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return Success
     */
    getWallet(walletId: string): Promise<WalletEntity> {
        let url_ = this.baseUrl + "/api/wallet/{walletId}";
        if (walletId === undefined || walletId === null)
            throw new Error("The parameter 'walletId' must be defined.");
        url_ = url_.replace("{walletId}", encodeURIComponent("" + walletId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWallet(_response);
        });
    }

    protected processGetWallet(response: Response): Promise<WalletEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WalletEntity>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    blockWallet(body?: BlockWalletCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/wallet/block";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBlockWallet(_response);
        });
    }

    protected processBlockWallet(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    startSession(body?: StartWorkSessionCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/work-session/start";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartSession(_response);
        });
    }

    protected processStartSession(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submitSession(body?: SubmitWorkSessionCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/work-session/submit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubmitSession(_response);
        });
    }

    protected processSubmitSession(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    endSession(body?: EndWorkSessionCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/work-session/end";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEndSession(_response);
        });
    }

    protected processEndSession(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveSession(body?: ApproveWorkSessionCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/work-session/approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApproveSession(_response);
        });
    }

    protected processApproveSession(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reactSession(body?: ReactToWorkSessionCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/work-session/react";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReactSession(_response);
        });
    }

    protected processReactSession(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return Success
     */
    getSession(id: string): Promise<WorkSessionEntity> {
        let url_ = this.baseUrl + "/api/work-session/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSession(_response);
        });
    }

    protected processGetSession(response: Response): Promise<WorkSessionEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkSessionEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkSessionEntity>(null as any);
    }

    /**
     * @param contractId (optional) 
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    getSessionList(contractId?: string | undefined, start?: number | undefined, end?: number | undefined): Promise<WorkSessionEntity[]> {
        let url_ = this.baseUrl + "/api/work-session/list?";
        if (contractId === null)
            throw new Error("The parameter 'contractId' cannot be null.");
        else if (contractId !== undefined)
            url_ += "contractId=" + encodeURIComponent("" + contractId) + "&";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent("" + end) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSessionList(_response);
        });
    }

    protected processGetSessionList(response: Response): Promise<WorkSessionEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkSessionEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkSessionEntity[]>(null as any);
    }
}

export class AcceptDisputeCommand implements IAcceptDisputeCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    disputeId?: string;

    constructor(data?: IAcceptDisputeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.disputeId = _data["disputeId"];
        }
    }

    static fromJS(data: any): AcceptDisputeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptDisputeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["disputeId"] = this.disputeId;
        return data;
    }
}

export interface IAcceptDisputeCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    disputeId?: string;
}

export class AddPortfolioProjectCommand implements IAddPortfolioProjectCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    name?: string | undefined;
    userRole?: string | undefined;
    skills?: string[] | undefined;
    description?: string | undefined;
    files?: CreateFileDto[] | undefined;

    constructor(data?: IAddPortfolioProjectCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.userRole = _data["userRole"];
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(item);
            }
            this.description = _data["description"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(CreateFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddPortfolioProjectCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddPortfolioProjectCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["userRole"] = this.userRole;
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item);
        }
        data["description"] = this.description;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAddPortfolioProjectCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    name?: string | undefined;
    userRole?: string | undefined;
    skills?: string[] | undefined;
    description?: string | undefined;
    files?: CreateFileDto[] | undefined;
}

export class ApproveContestCommand implements IApproveContestCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contestId?: string;

    constructor(data?: IApproveContestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contestId = _data["contestId"];
        }
    }

    static fromJS(data: any): ApproveContestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveContestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contestId"] = this.contestId;
        return data;
    }
}

export interface IApproveContestCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contestId?: string;
}

export class ApproveWorkSessionCommand implements IApproveWorkSessionCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    sessionId?: string;

    constructor(data?: IApproveWorkSessionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.sessionId = _data["sessionId"];
        }
    }

    static fromJS(data: any): ApproveWorkSessionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveWorkSessionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["sessionId"] = this.sessionId;
        return data;
    }
}

export interface IApproveWorkSessionCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    sessionId?: string;
}

export class BalanceOperationCommand implements IBalanceOperationCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    readonly walletId!: string;
    balance!: Money;
    readonly balanceOperationType?: BalanceOperationCommandBalanceOperationType;

    constructor(data?: IBalanceOperationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.balance = new Money();
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            (<any>this).walletId = _data["walletId"];
            this.balance = _data["balance"] ? Money.fromJS(_data["balance"]) : new Money();
            (<any>this).balanceOperationType = _data["balanceOperationType"];
        }
    }

    static fromJS(data: any): BalanceOperationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceOperationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["walletId"] = this.walletId;
        data["balance"] = this.balance ? this.balance.toJSON() : <any>undefined;
        data["balanceOperationType"] = this.balanceOperationType;
        return data;
    }
}

export interface IBalanceOperationCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    walletId: string;
    balance: Money;
    balanceOperationType?: BalanceOperationCommandBalanceOperationType;
}

export class BlockWalletCommand implements IBlockWalletCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    walletId!: string;
    reason!: BlockWalletCommandReason;

    constructor(data?: IBlockWalletCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.walletId = _data["walletId"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): BlockWalletCommand {
        data = typeof data === 'object' ? data : {};
        let result = new BlockWalletCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["walletId"] = this.walletId;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IBlockWalletCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    walletId: string;
    reason: BlockWalletCommandReason;
}

export class BookmarkJobCommand implements IBookmarkJobCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    jobId?: string;

    constructor(data?: IBookmarkJobCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.jobId = _data["jobId"];
        }
    }

    static fromJS(data: any): BookmarkJobCommand {
        data = typeof data === 'object' ? data : {};
        let result = new BookmarkJobCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["jobId"] = this.jobId;
        return data;
    }
}

export interface IBookmarkJobCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    jobId?: string;
}

export class CategoryEntity implements ICategoryEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name?: string | undefined;
    slug?: string | undefined;
    parentCategoryId?: string | undefined;
    parentCategory?: CategoryEntity;
    subCategories?: CategoryEntity[] | undefined;

    constructor(data?: ICategoryEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.parentCategory = _data["parentCategory"] ? CategoryEntity.fromJS(_data["parentCategory"]) : <any>undefined;
            if (Array.isArray(_data["subCategories"])) {
                this.subCategories = [] as any;
                for (let item of _data["subCategories"])
                    this.subCategories!.push(CategoryEntity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategoryEntity {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["parentCategoryId"] = this.parentCategoryId;
        data["parentCategory"] = this.parentCategory ? this.parentCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.subCategories)) {
            data["subCategories"] = [];
            for (let item of this.subCategories)
                data["subCategories"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICategoryEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name?: string | undefined;
    slug?: string | undefined;
    parentCategoryId?: string | undefined;
    parentCategory?: CategoryEntity;
    subCategories?: CategoryEntity[] | undefined;
}

export class CategoryModel implements ICategoryModel {

    constructor(data?: ICategoryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): CategoryModel {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface ICategoryModel {
}

export class ClientAcceptFinishContractCommand implements IClientAcceptFinishContractCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    readonly contractId?: string;

    constructor(data?: IClientAcceptFinishContractCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            (<any>this).contractId = _data["contractId"];
        }
    }

    static fromJS(data: any): ClientAcceptFinishContractCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ClientAcceptFinishContractCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contractId"] = this.contractId;
        return data;
    }
}

export interface IClientAcceptFinishContractCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contractId?: string;
}

export class ClientCloseContractCommand implements IClientCloseContractCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contractId?: string;
    reason?: string | undefined;

    constructor(data?: IClientCloseContractCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contractId = _data["contractId"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): ClientCloseContractCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ClientCloseContractCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contractId"] = this.contractId;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IClientCloseContractCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contractId?: string;
    reason?: string | undefined;
}

export class ClientJobInfo implements IClientJobInfo {
    userId?: string;
    name?: string | undefined;
    avatar?: FileEntity;
    isVerified?: boolean;
    activeJobs?: number;
    closedJobs?: number;
    arbitrationJobs?: number;
    activeContracts?: number;
    completedContracts?: number;
    arbitrationContracts?: number;
    registeredAt?: string | undefined;
    lastActiveAt?: string | undefined;
    isPhoneVerified?: boolean;
    hasPremium?: boolean;

    constructor(data?: IClientJobInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.avatar = _data["avatar"] ? FileEntity.fromJS(_data["avatar"]) : <any>undefined;
            this.isVerified = _data["isVerified"];
            this.activeJobs = _data["activeJobs"];
            this.closedJobs = _data["closedJobs"];
            this.arbitrationJobs = _data["arbitrationJobs"];
            this.activeContracts = _data["activeContracts"];
            this.completedContracts = _data["completedContracts"];
            this.arbitrationContracts = _data["arbitrationContracts"];
            this.registeredAt = _data["registeredAt"];
            this.lastActiveAt = _data["lastActiveAt"];
            this.isPhoneVerified = _data["isPhoneVerified"];
            this.hasPremium = _data["hasPremium"];
        }
    }

    static fromJS(data: any): ClientJobInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ClientJobInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["avatar"] = this.avatar ? this.avatar.toJSON() : <any>undefined;
        data["isVerified"] = this.isVerified;
        data["activeJobs"] = this.activeJobs;
        data["closedJobs"] = this.closedJobs;
        data["arbitrationJobs"] = this.arbitrationJobs;
        data["activeContracts"] = this.activeContracts;
        data["completedContracts"] = this.completedContracts;
        data["arbitrationContracts"] = this.arbitrationContracts;
        data["registeredAt"] = this.registeredAt;
        data["lastActiveAt"] = this.lastActiveAt;
        data["isPhoneVerified"] = this.isPhoneVerified;
        data["hasPremium"] = this.hasPremium;
        return data;
    }
}

export interface IClientJobInfo {
    userId?: string;
    name?: string | undefined;
    avatar?: FileEntity;
    isVerified?: boolean;
    activeJobs?: number;
    closedJobs?: number;
    arbitrationJobs?: number;
    activeContracts?: number;
    completedContracts?: number;
    arbitrationContracts?: number;
    registeredAt?: string | undefined;
    lastActiveAt?: string | undefined;
    isPhoneVerified?: boolean;
    hasPremium?: boolean;
}

export class ClientRejectContractCompletionCommand implements IClientRejectContractCompletionCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contractId?: string;
    reason?: string | undefined;

    constructor(data?: IClientRejectContractCompletionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contractId = _data["contractId"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): ClientRejectContractCompletionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ClientRejectContractCompletionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contractId"] = this.contractId;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IClientRejectContractCompletionCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contractId?: string;
    reason?: string | undefined;
}

export class CommandResult implements ICommandResult {
    readonly message?: string | undefined;
    readonly id!: string;
    readonly ids?: string[] | undefined;
    readonly status!: CommandResultStatus;
    readonly isSuccess?: boolean;

    constructor(data?: ICommandResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).message = _data["message"];
            (<any>this).id = _data["id"];
            if (Array.isArray(_data["ids"])) {
                (<any>this).ids = [] as any;
                for (let item of _data["ids"])
                    (<any>this).ids!.push(item);
            }
            (<any>this).status = _data["status"];
            (<any>this).isSuccess = _data["isSuccess"];
        }
    }

    static fromJS(data: any): CommandResult {
        data = typeof data === 'object' ? data : {};
        let result = new CommandResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["id"] = this.id;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["status"] = this.status;
        data["isSuccess"] = this.isSuccess;
        return data;
    }
}

export interface ICommandResult {
    message?: string | undefined;
    id: string;
    ids?: string[] | undefined;
    status: CommandResultStatus;
    isSuccess?: boolean;
}

export class CompleteTaskCommand implements ICompleteTaskCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    taskId?: string;

    constructor(data?: ICompleteTaskCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.taskId = _data["taskId"];
        }
    }

    static fromJS(data: any): CompleteTaskCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteTaskCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["taskId"] = this.taskId;
        return data;
    }
}

export interface ICompleteTaskCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    taskId?: string;
}

export class ContestEntity implements IContestEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    employerId?: string;
    employer?: UserEntity;
    title?: string | undefined;
    description?: string | undefined;
    prizePool?: Money;
    startDate?: Date;
    endDate?: Date | undefined;
    status?: ContestEntityStatus;
    winnerEntryId?: string | undefined;
    isResultPublic?: boolean;
    isEntriesPublic?: boolean;
    files?: FileEntity[] | undefined;

    constructor(data?: IContestEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.employerId = _data["employerId"];
            this.employer = _data["employer"] ? UserEntity.fromJS(_data["employer"]) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            this.prizePool = _data["prizePool"] ? Money.fromJS(_data["prizePool"]) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.winnerEntryId = _data["winnerEntryId"];
            this.isResultPublic = _data["isResultPublic"];
            this.isEntriesPublic = _data["isEntriesPublic"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(FileEntity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContestEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ContestEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["employerId"] = this.employerId;
        data["employer"] = this.employer ? this.employer.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["prizePool"] = this.prizePool ? this.prizePool.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["winnerEntryId"] = this.winnerEntryId;
        data["isResultPublic"] = this.isResultPublic;
        data["isEntriesPublic"] = this.isEntriesPublic;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContestEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    employerId?: string;
    employer?: UserEntity;
    title?: string | undefined;
    description?: string | undefined;
    prizePool?: Money;
    startDate?: Date;
    endDate?: Date | undefined;
    status?: ContestEntityStatus;
    winnerEntryId?: string | undefined;
    isResultPublic?: boolean;
    isEntriesPublic?: boolean;
    files?: FileEntity[] | undefined;
}

export class ContractEntity implements IContractEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    freelancerId?: string;
    freelancer?: UserEntity;
    employerId?: string;
    employer?: UserEntity;
    startDate?: Date;
    endDate?: Date | undefined;
    budget?: Money;
    status?: ContractEntityStatus;
    costPerHour?: Money;
    budgetType?: ContractEntityBudgetType;
    tasks?: TaskEntity[] | undefined;
    workSessions?: WorkSessionEntity[] | undefined;
    readonly totalWorkSessions?: number;
    readonly totalHoursWorked?: number;
    remainingBudget?: Money;
    paymentSchedule?: ContractEntityPaymentSchedule;
    isPaused?: boolean;
    pauseReason?: string | undefined;
    contractTerms?: string | undefined;
    bonus?: number | undefined;
    disputeId?: string | undefined;

    constructor(data?: IContractEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.freelancerId = _data["freelancerId"];
            this.freelancer = _data["freelancer"] ? UserEntity.fromJS(_data["freelancer"]) : <any>undefined;
            this.employerId = _data["employerId"];
            this.employer = _data["employer"] ? UserEntity.fromJS(_data["employer"]) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.budget = _data["budget"] ? Money.fromJS(_data["budget"]) : <any>undefined;
            this.status = _data["status"];
            this.costPerHour = _data["costPerHour"] ? Money.fromJS(_data["costPerHour"]) : <any>undefined;
            this.budgetType = _data["budgetType"];
            if (Array.isArray(_data["tasks"])) {
                this.tasks = [] as any;
                for (let item of _data["tasks"])
                    this.tasks!.push(TaskEntity.fromJS(item));
            }
            if (Array.isArray(_data["workSessions"])) {
                this.workSessions = [] as any;
                for (let item of _data["workSessions"])
                    this.workSessions!.push(WorkSessionEntity.fromJS(item));
            }
            (<any>this).totalWorkSessions = _data["totalWorkSessions"];
            (<any>this).totalHoursWorked = _data["totalHoursWorked"];
            this.remainingBudget = _data["remainingBudget"] ? Money.fromJS(_data["remainingBudget"]) : <any>undefined;
            this.paymentSchedule = _data["paymentSchedule"];
            this.isPaused = _data["isPaused"];
            this.pauseReason = _data["pauseReason"];
            this.contractTerms = _data["contractTerms"];
            this.bonus = _data["bonus"];
            this.disputeId = _data["disputeId"];
        }
    }

    static fromJS(data: any): ContractEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ContractEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["freelancerId"] = this.freelancerId;
        data["freelancer"] = this.freelancer ? this.freelancer.toJSON() : <any>undefined;
        data["employerId"] = this.employerId;
        data["employer"] = this.employer ? this.employer.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["budget"] = this.budget ? this.budget.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["costPerHour"] = this.costPerHour ? this.costPerHour.toJSON() : <any>undefined;
        data["budgetType"] = this.budgetType;
        if (Array.isArray(this.tasks)) {
            data["tasks"] = [];
            for (let item of this.tasks)
                data["tasks"].push(item.toJSON());
        }
        if (Array.isArray(this.workSessions)) {
            data["workSessions"] = [];
            for (let item of this.workSessions)
                data["workSessions"].push(item.toJSON());
        }
        data["totalWorkSessions"] = this.totalWorkSessions;
        data["totalHoursWorked"] = this.totalHoursWorked;
        data["remainingBudget"] = this.remainingBudget ? this.remainingBudget.toJSON() : <any>undefined;
        data["paymentSchedule"] = this.paymentSchedule;
        data["isPaused"] = this.isPaused;
        data["pauseReason"] = this.pauseReason;
        data["contractTerms"] = this.contractTerms;
        data["bonus"] = this.bonus;
        data["disputeId"] = this.disputeId;
        return data;
    }
}

export interface IContractEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    freelancerId?: string;
    freelancer?: UserEntity;
    employerId?: string;
    employer?: UserEntity;
    startDate?: Date;
    endDate?: Date | undefined;
    budget?: Money;
    status?: ContractEntityStatus;
    costPerHour?: Money;
    budgetType?: ContractEntityBudgetType;
    tasks?: TaskEntity[] | undefined;
    workSessions?: WorkSessionEntity[] | undefined;
    totalWorkSessions?: number;
    totalHoursWorked?: number;
    remainingBudget?: Money;
    paymentSchedule?: ContractEntityPaymentSchedule;
    isPaused?: boolean;
    pauseReason?: string | undefined;
    contractTerms?: string | undefined;
    bonus?: number | undefined;
    disputeId?: string | undefined;
}

export class CreateCategoryCommand implements ICreateCategoryCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    name?: string | undefined;
    slug?: string | undefined;
    tags?: string | undefined;
    parentCategoryId?: string | undefined;

    constructor(data?: ICreateCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.tags = _data["tags"];
            this.parentCategoryId = _data["parentCategoryId"];
        }
    }

    static fromJS(data: any): CreateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["tags"] = this.tags;
        data["parentCategoryId"] = this.parentCategoryId;
        return data;
    }
}

export interface ICreateCategoryCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    name?: string | undefined;
    slug?: string | undefined;
    tags?: string | undefined;
    parentCategoryId?: string | undefined;
}

export class CreateClientProfileCommand implements ICreateClientProfileCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    companyName!: string;
    companyDescription?: string | undefined;
    companyWebsite?: string | undefined;
    location?: string | undefined;
    companyLogo?: CreateFileDto;
    employerType?: CreateClientProfileCommandEmployerType;
    phoneNumber?: string | undefined;

    constructor(data?: ICreateClientProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.companyName = _data["companyName"];
            this.companyDescription = _data["companyDescription"];
            this.companyWebsite = _data["companyWebsite"];
            this.location = _data["location"];
            this.companyLogo = _data["companyLogo"] ? CreateFileDto.fromJS(_data["companyLogo"]) : <any>undefined;
            this.employerType = _data["employerType"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): CreateClientProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClientProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["companyName"] = this.companyName;
        data["companyDescription"] = this.companyDescription;
        data["companyWebsite"] = this.companyWebsite;
        data["location"] = this.location;
        data["companyLogo"] = this.companyLogo ? this.companyLogo.toJSON() : <any>undefined;
        data["employerType"] = this.employerType;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface ICreateClientProfileCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    companyName: string;
    companyDescription?: string | undefined;
    companyWebsite?: string | undefined;
    location?: string | undefined;
    companyLogo?: CreateFileDto;
    employerType?: CreateClientProfileCommandEmployerType;
    phoneNumber?: string | undefined;
}

export class CreateContestCommand implements ICreateContestCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    title!: string;
    description!: string;
    prizePool!: number;
    isResultPublic?: boolean;

    constructor(data?: ICreateContestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            this.prizePool = _data["prizePool"];
            this.isResultPublic = _data["isResultPublic"];
        }
    }

    static fromJS(data: any): CreateContestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["prizePool"] = this.prizePool;
        data["isResultPublic"] = this.isResultPublic;
        return data;
    }
}

export interface ICreateContestCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    title: string;
    description: string;
    prizePool: number;
    isResultPublic?: boolean;
}

export class CreateContractCommand implements ICreateContractCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    freelancerId?: string;
    jobId?: string;
    budget?: number | undefined;
    costPerHour?: number | undefined;
    budgetType?: CreateContractCommandBudgetType;
    paymentSchedule?: CreateContractCommandPaymentSchedule;
    contractTerms?: string | undefined;
    endDate?: Date | undefined;

    constructor(data?: ICreateContractCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.freelancerId = _data["freelancerId"];
            this.jobId = _data["jobId"];
            this.budget = _data["budget"];
            this.costPerHour = _data["costPerHour"];
            this.budgetType = _data["budgetType"];
            this.paymentSchedule = _data["paymentSchedule"];
            this.contractTerms = _data["contractTerms"];
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateContractCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContractCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["freelancerId"] = this.freelancerId;
        data["jobId"] = this.jobId;
        data["budget"] = this.budget;
        data["costPerHour"] = this.costPerHour;
        data["budgetType"] = this.budgetType;
        data["paymentSchedule"] = this.paymentSchedule;
        data["contractTerms"] = this.contractTerms;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICreateContractCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    freelancerId?: string;
    jobId?: string;
    budget?: number | undefined;
    costPerHour?: number | undefined;
    budgetType?: CreateContractCommandBudgetType;
    paymentSchedule?: CreateContractCommandPaymentSchedule;
    contractTerms?: string | undefined;
    endDate?: Date | undefined;
}

export class CreateFileDto implements ICreateFileDto {
    downloadUrl?: string | undefined;
    fileId?: string | undefined;
    name?: string | undefined;
    mimeType?: string | undefined;
    stream?: string;

    constructor(data?: ICreateFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.downloadUrl = _data["downloadUrl"];
            this.fileId = _data["fileId"];
            this.name = _data["name"];
            this.mimeType = _data["mimeType"];
            this.stream = _data["stream"];
        }
    }

    static fromJS(data: any): CreateFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["downloadUrl"] = this.downloadUrl;
        data["fileId"] = this.fileId;
        data["name"] = this.name;
        data["mimeType"] = this.mimeType;
        data["stream"] = this.stream;
        return data;
    }
}

export interface ICreateFileDto {
    downloadUrl?: string | undefined;
    fileId?: string | undefined;
    name?: string | undefined;
    mimeType?: string | undefined;
    stream?: string;
}

export class CreateFreelancerProfileCommand implements ICreateFreelancerProfileCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    userId?: string | undefined;
    experience?: string | undefined;
    hourlyRate?: number;
    resume?: string | undefined;

    constructor(data?: ICreateFreelancerProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.experience = _data["experience"];
            this.hourlyRate = _data["hourlyRate"];
            this.resume = _data["resume"];
        }
    }

    static fromJS(data: any): CreateFreelancerProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFreelancerProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["experience"] = this.experience;
        data["hourlyRate"] = this.hourlyRate;
        data["resume"] = this.resume;
        return data;
    }
}

export interface ICreateFreelancerProfileCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    userId?: string | undefined;
    experience?: string | undefined;
    hourlyRate?: number;
    resume?: string | undefined;
}

export class CreateFreelancerTeamCommand implements ICreateFreelancerTeamCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICreateFreelancerTeamCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateFreelancerTeamCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFreelancerTeamCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreateFreelancerTeamCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    name?: string | undefined;
    description?: string | undefined;
}

export class CreateJobCommand implements ICreateJobCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    title?: string | undefined;
    description?: string | undefined;
    requiredSkillIds?: string[] | undefined;
    categoryId?: string;
    budget?: number | undefined;
    hourlyRate?: number | undefined;
    duration?: number | undefined;
    budgetType?: CreateJobCommandBudgetType;
    level?: CreateJobCommandLevel;
    expirationDate?: Date | undefined;
    files?: CreateFileDto[] | undefined;

    constructor(data?: ICreateJobCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["requiredSkillIds"])) {
                this.requiredSkillIds = [] as any;
                for (let item of _data["requiredSkillIds"])
                    this.requiredSkillIds!.push(item);
            }
            this.categoryId = _data["categoryId"];
            this.budget = _data["budget"];
            this.hourlyRate = _data["hourlyRate"];
            this.duration = _data["duration"];
            this.budgetType = _data["budgetType"];
            this.level = _data["level"];
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(CreateFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateJobCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateJobCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.requiredSkillIds)) {
            data["requiredSkillIds"] = [];
            for (let item of this.requiredSkillIds)
                data["requiredSkillIds"].push(item);
        }
        data["categoryId"] = this.categoryId;
        data["budget"] = this.budget;
        data["hourlyRate"] = this.hourlyRate;
        data["duration"] = this.duration;
        data["budgetType"] = this.budgetType;
        data["level"] = this.level;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateJobCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    title?: string | undefined;
    description?: string | undefined;
    requiredSkillIds?: string[] | undefined;
    categoryId?: string;
    budget?: number | undefined;
    hourlyRate?: number | undefined;
    duration?: number | undefined;
    budgetType?: CreateJobCommandBudgetType;
    level?: CreateJobCommandLevel;
    expirationDate?: Date | undefined;
    files?: CreateFileDto[] | undefined;
}

export class CreateNotificationCommand implements ICreateNotificationCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    title!: string;
    text!: string;
    data!: { [key: string]: string; };
    userId?: string | undefined;
    role?: CreateNotificationCommandRole | undefined;
    type?: CreateNotificationCommandType | undefined;

    constructor(data?: ICreateNotificationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.text = _data["text"];
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
            this.userId = _data["userId"];
            this.role = _data["role"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CreateNotificationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNotificationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["text"] = this.text;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        data["userId"] = this.userId;
        data["role"] = this.role;
        data["type"] = this.type;
        return data;
    }
}

export interface ICreateNotificationCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    title: string;
    text: string;
    data: { [key: string]: string; };
    userId?: string | undefined;
    role?: CreateNotificationCommandRole | undefined;
    type?: CreateNotificationCommandType | undefined;
}

export class CreateSkillsCommand implements ICreateSkillsCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    skillNames?: string[] | undefined;

    constructor(data?: ICreateSkillsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            if (Array.isArray(_data["skillNames"])) {
                this.skillNames = [] as any;
                for (let item of _data["skillNames"])
                    this.skillNames!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateSkillsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSkillsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        if (Array.isArray(this.skillNames)) {
            data["skillNames"] = [];
            for (let item of this.skillNames)
                data["skillNames"].push(item);
        }
        return data;
    }
}

export interface ICreateSkillsCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    skillNames?: string[] | undefined;
}

export class CreateTaskCommand implements ICreateTaskCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contractId?: string;
    title?: string | undefined;
    description?: string | undefined;
    priority?: number;

    constructor(data?: ICreateTaskCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contractId = _data["contractId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.priority = _data["priority"];
        }
    }

    static fromJS(data: any): CreateTaskCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTaskCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contractId"] = this.contractId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["priority"] = this.priority;
        return data;
    }
}

export interface ICreateTaskCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contractId?: string;
    title?: string | undefined;
    description?: string | undefined;
    priority?: number;
}

export class CreateTicketDto implements ICreateTicketDto {
    subject!: string;
    text!: string;
    files?: CreateFileDto[] | undefined;
    priorityScore?: number;
    linkedDisputeId?: string | undefined;
    title?: string | undefined;

    constructor(data?: ICreateTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subject = _data["subject"];
            this.text = _data["text"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(CreateFileDto.fromJS(item));
            }
            this.priorityScore = _data["priorityScore"];
            this.linkedDisputeId = _data["linkedDisputeId"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["text"] = this.text;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["priorityScore"] = this.priorityScore;
        data["linkedDisputeId"] = this.linkedDisputeId;
        data["title"] = this.title;
        return data;
    }
}

export interface ICreateTicketDto {
    subject: string;
    text: string;
    files?: CreateFileDto[] | undefined;
    priorityScore?: number;
    linkedDisputeId?: string | undefined;
    title?: string | undefined;
}

export class DeleteContestCommand implements IDeleteContestCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contestId?: string;

    constructor(data?: IDeleteContestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contestId = _data["contestId"];
        }
    }

    static fromJS(data: any): DeleteContestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteContestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contestId"] = this.contestId;
        return data;
    }
}

export interface IDeleteContestCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contestId?: string;
}

export class DeleteContestEntryCommand implements IDeleteContestEntryCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contestEntryId?: string;

    constructor(data?: IDeleteContestEntryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contestEntryId = _data["contestEntryId"];
        }
    }

    static fromJS(data: any): DeleteContestEntryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteContestEntryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contestEntryId"] = this.contestEntryId;
        return data;
    }
}

export interface IDeleteContestEntryCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contestEntryId?: string;
}

export class DeleteFreelancerTeamCommand implements IDeleteFreelancerTeamCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    teamId?: string;

    constructor(data?: IDeleteFreelancerTeamCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.teamId = _data["teamId"];
        }
    }

    static fromJS(data: any): DeleteFreelancerTeamCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteFreelancerTeamCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["teamId"] = this.teamId;
        return data;
    }
}

export interface IDeleteFreelancerTeamCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    teamId?: string;
}

export class DeleteJobCommand implements IDeleteJobCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    jobId?: string;

    constructor(data?: IDeleteJobCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.jobId = _data["jobId"];
        }
    }

    static fromJS(data: any): DeleteJobCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteJobCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["jobId"] = this.jobId;
        return data;
    }
}

export interface IDeleteJobCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    jobId?: string;
}

export class DeletePortfolioProjectCommand implements IDeletePortfolioProjectCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    projectId?: string;

    constructor(data?: IDeletePortfolioProjectCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): DeletePortfolioProjectCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeletePortfolioProjectCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["projectId"] = this.projectId;
        return data;
    }
}

export interface IDeletePortfolioProjectCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    projectId?: string;
}

export class DeleteSkillsCommand implements IDeleteSkillsCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    skillIds?: string[] | undefined;
    skillNames?: string[] | undefined;

    constructor(data?: IDeleteSkillsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            if (Array.isArray(_data["skillIds"])) {
                this.skillIds = [] as any;
                for (let item of _data["skillIds"])
                    this.skillIds!.push(item);
            }
            if (Array.isArray(_data["skillNames"])) {
                this.skillNames = [] as any;
                for (let item of _data["skillNames"])
                    this.skillNames!.push(item);
            }
        }
    }

    static fromJS(data: any): DeleteSkillsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteSkillsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        if (Array.isArray(this.skillIds)) {
            data["skillIds"] = [];
            for (let item of this.skillIds)
                data["skillIds"].push(item);
        }
        if (Array.isArray(this.skillNames)) {
            data["skillNames"] = [];
            for (let item of this.skillNames)
                data["skillNames"].push(item);
        }
        return data;
    }
}

export interface IDeleteSkillsCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    skillIds?: string[] | undefined;
    skillNames?: string[] | undefined;
}

export class DeleteTaskCommand implements IDeleteTaskCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    taskId?: string;

    constructor(data?: IDeleteTaskCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.taskId = _data["taskId"];
        }
    }

    static fromJS(data: any): DeleteTaskCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteTaskCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["taskId"] = this.taskId;
        return data;
    }
}

export interface IDeleteTaskCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    taskId?: string;
}

export class EndContestCommand implements IEndContestCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contestId?: string;

    constructor(data?: IEndContestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contestId = _data["contestId"];
        }
    }

    static fromJS(data: any): EndContestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EndContestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contestId"] = this.contestId;
        return data;
    }
}

export interface IEndContestCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contestId?: string;
}

export class EndWorkSessionCommand implements IEndWorkSessionCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    sessionId?: string;
    selectedFiles?: CreateFileDto[] | undefined;

    constructor(data?: IEndWorkSessionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.sessionId = _data["sessionId"];
            if (Array.isArray(_data["selectedFiles"])) {
                this.selectedFiles = [] as any;
                for (let item of _data["selectedFiles"])
                    this.selectedFiles!.push(CreateFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EndWorkSessionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EndWorkSessionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["sessionId"] = this.sessionId;
        if (Array.isArray(this.selectedFiles)) {
            data["selectedFiles"] = [];
            for (let item of this.selectedFiles)
                data["selectedFiles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEndWorkSessionCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    sessionId?: string;
    selectedFiles?: CreateFileDto[] | undefined;
}

export class FeeContext implements IFeeContext {
    readonly isContractCancellation?: boolean;
    readonly isAdminOverride?: boolean;

    constructor(data?: IFeeContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isContractCancellation = _data["isContractCancellation"];
            (<any>this).isAdminOverride = _data["isAdminOverride"];
        }
    }

    static fromJS(data: any): FeeContext {
        data = typeof data === 'object' ? data : {};
        let result = new FeeContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isContractCancellation"] = this.isContractCancellation;
        data["isAdminOverride"] = this.isAdminOverride;
        return data;
    }
}

export interface IFeeContext {
    isContractCancellation?: boolean;
    isAdminOverride?: boolean;
}

export class FileEntity implements IFileEntity {
    id!: string;
    fileName!: string;
    filePath!: string;
    mimeType!: string;
    size?: number;

    constructor(data?: IFileEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileName = _data["fileName"];
            this.filePath = _data["filePath"];
            this.mimeType = _data["mimeType"];
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): FileEntity {
        data = typeof data === 'object' ? data : {};
        let result = new FileEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileName"] = this.fileName;
        data["filePath"] = this.filePath;
        data["mimeType"] = this.mimeType;
        data["size"] = this.size;
        return data;
    }
}

export interface IFileEntity {
    id: string;
    fileName: string;
    filePath: string;
    mimeType: string;
    size?: number;
}

export class ForceContractCancelCommand implements IForceContractCancelCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contractId?: string;
    reason?: string | undefined;

    constructor(data?: IForceContractCancelCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contractId = _data["contractId"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): ForceContractCancelCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ForceContractCancelCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contractId"] = this.contractId;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IForceContractCancelCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contractId?: string;
    reason?: string | undefined;
}

export class FreelancerAcceptContractCommand implements IFreelancerAcceptContractCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contractId?: string;

    constructor(data?: IFreelancerAcceptContractCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contractId = _data["contractId"];
        }
    }

    static fromJS(data: any): FreelancerAcceptContractCommand {
        data = typeof data === 'object' ? data : {};
        let result = new FreelancerAcceptContractCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contractId"] = this.contractId;
        return data;
    }
}

export interface IFreelancerAcceptContractCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contractId?: string;
}

export class FreelancerFinishContractCommand implements IFreelancerFinishContractCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contractId?: string;

    constructor(data?: IFreelancerFinishContractCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contractId = _data["contractId"];
        }
    }

    static fromJS(data: any): FreelancerFinishContractCommand {
        data = typeof data === 'object' ? data : {};
        let result = new FreelancerFinishContractCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contractId"] = this.contractId;
        return data;
    }
}

export interface IFreelancerFinishContractCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contractId?: string;
}

export class FreelancerProfileEntity implements IFreelancerProfileEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    userId?: string;
    user?: UserEntity;
    skills?: SkillEntity[] | undefined;
    experience?: string | undefined;
    portfolioProjects?: PortfolioProjectEntity[] | undefined;
    resume?: string | undefined;
    costPerHour?: number;
    availability?: FreelancerProfileEntityAvailability;
    rating?: number;
    isHidden?: boolean;
    reviews?: JobReviewEntity[] | undefined;

    constructor(data?: IFreelancerProfileEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserEntity.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(SkillEntity.fromJS(item));
            }
            this.experience = _data["experience"];
            if (Array.isArray(_data["portfolioProjects"])) {
                this.portfolioProjects = [] as any;
                for (let item of _data["portfolioProjects"])
                    this.portfolioProjects!.push(PortfolioProjectEntity.fromJS(item));
            }
            this.resume = _data["resume"];
            this.costPerHour = _data["costPerHour"];
            this.availability = _data["availability"];
            this.rating = _data["rating"];
            this.isHidden = _data["isHidden"];
            if (Array.isArray(_data["reviews"])) {
                this.reviews = [] as any;
                for (let item of _data["reviews"])
                    this.reviews!.push(JobReviewEntity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FreelancerProfileEntity {
        data = typeof data === 'object' ? data : {};
        let result = new FreelancerProfileEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item.toJSON());
        }
        data["experience"] = this.experience;
        if (Array.isArray(this.portfolioProjects)) {
            data["portfolioProjects"] = [];
            for (let item of this.portfolioProjects)
                data["portfolioProjects"].push(item.toJSON());
        }
        data["resume"] = this.resume;
        data["costPerHour"] = this.costPerHour;
        data["availability"] = this.availability;
        data["rating"] = this.rating;
        data["isHidden"] = this.isHidden;
        if (Array.isArray(this.reviews)) {
            data["reviews"] = [];
            for (let item of this.reviews)
                data["reviews"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFreelancerProfileEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    userId?: string;
    user?: UserEntity;
    skills?: SkillEntity[] | undefined;
    experience?: string | undefined;
    portfolioProjects?: PortfolioProjectEntity[] | undefined;
    resume?: string | undefined;
    costPerHour?: number;
    availability?: FreelancerProfileEntityAvailability;
    rating?: number;
    isHidden?: boolean;
    reviews?: JobReviewEntity[] | undefined;
}

export class FreelancerTeamEntity implements IFreelancerTeamEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name?: string | undefined;
    participants?: UserEntity[] | undefined;
    readonly closed?: boolean;
    readonly closedReason?: string | undefined;
    avatarId?: string;
    avatar?: FileEntity;
    owner?: UserEntity;
    ownerId?: string;

    constructor(data?: IFreelancerTeamEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            if (Array.isArray(_data["participants"])) {
                this.participants = [] as any;
                for (let item of _data["participants"])
                    this.participants!.push(UserEntity.fromJS(item));
            }
            (<any>this).closed = _data["closed"];
            (<any>this).closedReason = _data["closedReason"];
            this.avatarId = _data["avatarId"];
            this.avatar = _data["avatar"] ? FileEntity.fromJS(_data["avatar"]) : <any>undefined;
            this.owner = _data["owner"] ? UserEntity.fromJS(_data["owner"]) : <any>undefined;
            this.ownerId = _data["ownerId"];
        }
    }

    static fromJS(data: any): FreelancerTeamEntity {
        data = typeof data === 'object' ? data : {};
        let result = new FreelancerTeamEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        if (Array.isArray(this.participants)) {
            data["participants"] = [];
            for (let item of this.participants)
                data["participants"].push(item.toJSON());
        }
        data["closed"] = this.closed;
        data["closedReason"] = this.closedReason;
        data["avatarId"] = this.avatarId;
        data["avatar"] = this.avatar ? this.avatar.toJSON() : <any>undefined;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["ownerId"] = this.ownerId;
        return data;
    }
}

export interface IFreelancerTeamEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name?: string | undefined;
    participants?: UserEntity[] | undefined;
    closed?: boolean;
    closedReason?: string | undefined;
    avatarId?: string;
    avatar?: FileEntity;
    owner?: UserEntity;
    ownerId?: string;
}

export class GatewayResultCommand implements IGatewayResultCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    success!: boolean;
    gatewayTransactionId!: string;
    internalTransactionId!: string;
    customId?: string | undefined;
    amount!: number;
    fee!: number;
    currency!: GatewayResultCommandCurrency;
    status?: string | undefined;
    failureReason?: string | undefined;
    metadata?: { [key: string]: string; } | undefined;

    constructor(data?: IGatewayResultCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.success = _data["success"];
            this.gatewayTransactionId = _data["gatewayTransactionId"];
            this.internalTransactionId = _data["internalTransactionId"];
            this.customId = _data["customId"];
            this.amount = _data["amount"];
            this.fee = _data["fee"];
            this.currency = _data["currency"];
            this.status = _data["status"];
            this.failureReason = _data["failureReason"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
        }
    }

    static fromJS(data: any): GatewayResultCommand {
        data = typeof data === 'object' ? data : {};
        let result = new GatewayResultCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["success"] = this.success;
        data["gatewayTransactionId"] = this.gatewayTransactionId;
        data["internalTransactionId"] = this.internalTransactionId;
        data["customId"] = this.customId;
        data["amount"] = this.amount;
        data["fee"] = this.fee;
        data["currency"] = this.currency;
        data["status"] = this.status;
        data["failureReason"] = this.failureReason;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        return data;
    }
}

export interface IGatewayResultCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    success: boolean;
    gatewayTransactionId: string;
    internalTransactionId: string;
    customId?: string | undefined;
    amount: number;
    fee: number;
    currency: GatewayResultCommandCurrency;
    status?: string | undefined;
    failureReason?: string | undefined;
    metadata?: { [key: string]: string; } | undefined;
}

export class GetJobsListQuery implements IGetJobsListQuery {
    readonly queryId?: string | undefined;
    readonly timestamp?: Date;
    start?: number;
    ends?: number;
    search?: string | undefined;
    categoryId?: string | undefined;
    levels?: Levels[] | undefined;
    isHourly?: boolean | undefined;
    minBudget?: number | undefined;
    maxBudget?: number | undefined;
    minHourlyRate?: number | undefined;
    maxHourlyRate?: number | undefined;
    minProposals?: number | undefined;
    maxProposals?: number | undefined;
    minDurationDays?: number | undefined;
    maxDurationDays?: number | undefined;
    employerLocation?: GetJobsListQueryEmployerLocation | undefined;
    statuses?: Statuses[] | undefined;
    sortType?: GetJobsListQuerySortType | undefined;
    sortOption?: GetJobsListQuerySortOption | undefined;

    constructor(data?: IGetJobsListQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).queryId = _data["queryId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.start = _data["start"];
            this.ends = _data["ends"];
            this.search = _data["search"];
            this.categoryId = _data["categoryId"];
            if (Array.isArray(_data["levels"])) {
                this.levels = [] as any;
                for (let item of _data["levels"])
                    this.levels!.push(item);
            }
            this.isHourly = _data["isHourly"];
            this.minBudget = _data["minBudget"];
            this.maxBudget = _data["maxBudget"];
            this.minHourlyRate = _data["minHourlyRate"];
            this.maxHourlyRate = _data["maxHourlyRate"];
            this.minProposals = _data["minProposals"];
            this.maxProposals = _data["maxProposals"];
            this.minDurationDays = _data["minDurationDays"];
            this.maxDurationDays = _data["maxDurationDays"];
            this.employerLocation = _data["employerLocation"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(item);
            }
            this.sortType = _data["sortType"];
            this.sortOption = _data["sortOption"];
        }
    }

    static fromJS(data: any): GetJobsListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetJobsListQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["queryId"] = this.queryId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["start"] = this.start;
        data["ends"] = this.ends;
        data["search"] = this.search;
        data["categoryId"] = this.categoryId;
        if (Array.isArray(this.levels)) {
            data["levels"] = [];
            for (let item of this.levels)
                data["levels"].push(item);
        }
        data["isHourly"] = this.isHourly;
        data["minBudget"] = this.minBudget;
        data["maxBudget"] = this.maxBudget;
        data["minHourlyRate"] = this.minHourlyRate;
        data["maxHourlyRate"] = this.maxHourlyRate;
        data["minProposals"] = this.minProposals;
        data["maxProposals"] = this.maxProposals;
        data["minDurationDays"] = this.minDurationDays;
        data["maxDurationDays"] = this.maxDurationDays;
        data["employerLocation"] = this.employerLocation;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item);
        }
        data["sortType"] = this.sortType;
        data["sortOption"] = this.sortOption;
        return data;
    }
}

export interface IGetJobsListQuery {
    queryId?: string | undefined;
    timestamp?: Date;
    start?: number;
    ends?: number;
    search?: string | undefined;
    categoryId?: string | undefined;
    levels?: Levels[] | undefined;
    isHourly?: boolean | undefined;
    minBudget?: number | undefined;
    maxBudget?: number | undefined;
    minHourlyRate?: number | undefined;
    maxHourlyRate?: number | undefined;
    minProposals?: number | undefined;
    maxProposals?: number | undefined;
    minDurationDays?: number | undefined;
    maxDurationDays?: number | undefined;
    employerLocation?: GetJobsListQueryEmployerLocation | undefined;
    statuses?: Statuses[] | undefined;
    sortType?: GetJobsListQuerySortType | undefined;
    sortOption?: GetJobsListQuerySortOption | undefined;
}

export class GetTicketsDto implements IGetTicketsDto {
    start?: number;
    ends?: number;
    userId?: string | undefined;
    subject?: string | undefined;
    isAssignedToMe?: boolean | undefined;

    constructor(data?: IGetTicketsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start = _data["start"];
            this.ends = _data["ends"];
            this.userId = _data["userId"];
            this.subject = _data["subject"];
            this.isAssignedToMe = _data["isAssignedToMe"];
        }
    }

    static fromJS(data: any): GetTicketsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start;
        data["ends"] = this.ends;
        data["userId"] = this.userId;
        data["subject"] = this.subject;
        data["isAssignedToMe"] = this.isAssignedToMe;
        return data;
    }
}

export interface IGetTicketsDto {
    start?: number;
    ends?: number;
    userId?: string | undefined;
    subject?: string | undefined;
    isAssignedToMe?: boolean | undefined;
}

export class HandleTransactionCommand implements IHandleTransactionCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    transactionId!: string;

    constructor(data?: IHandleTransactionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.transactionId = _data["transactionId"];
        }
    }

    static fromJS(data: any): HandleTransactionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new HandleTransactionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["transactionId"] = this.transactionId;
        return data;
    }
}

export interface IHandleTransactionCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    transactionId: string;
}

export class HideFreelancerProfileCommand implements IHideFreelancerProfileCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    userId?: string;

    constructor(data?: IHideFreelancerProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): HideFreelancerProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new HideFreelancerProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IHideFreelancerProfileCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    userId?: string;
}

export class HideJobCommand implements IHideJobCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    jobId?: string;

    constructor(data?: IHideJobCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.jobId = _data["jobId"];
        }
    }

    static fromJS(data: any): HideJobCommand {
        data = typeof data === 'object' ? data : {};
        let result = new HideJobCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["jobId"] = this.jobId;
        return data;
    }
}

export interface IHideJobCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    jobId?: string;
}

export class InitiateDisputeCommand implements IInitiateDisputeCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contractId?: string;
    reason?: string | undefined;

    constructor(data?: IInitiateDisputeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contractId = _data["contractId"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): InitiateDisputeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new InitiateDisputeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contractId"] = this.contractId;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IInitiateDisputeCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contractId?: string;
    reason?: string | undefined;
}

export class JobDetails implements IJobDetails {
    jobId?: string;
    title?: string | undefined;
    description?: string | undefined;
    status?: JobDetailsStatus;
    budget?: Money;
    currency?: JobDetailsCurrency;
    category?: CategoryModel;
    skills?: string[] | undefined;
    languages?: string[] | undefined;
    clientName?: string | undefined;
    clientAvatarUrl?: string | undefined;
    isClientVerified?: boolean;
    createdAt?: Date;
    deadline?: Date | undefined;
    responsesRangeMin?: number;
    responsesRangeMax?: number;
    dailyResponsesMin?: number;
    dailyResponsesMax?: number;
    confirmedResponses?: number;

    constructor(data?: IJobDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.budget = _data["budget"] ? Money.fromJS(_data["budget"]) : <any>undefined;
            this.currency = _data["currency"];
            this.category = _data["category"] ? CategoryModel.fromJS(_data["category"]) : <any>undefined;
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(item);
            }
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(item);
            }
            this.clientName = _data["clientName"];
            this.clientAvatarUrl = _data["clientAvatarUrl"];
            this.isClientVerified = _data["isClientVerified"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.deadline = _data["deadline"] ? new Date(_data["deadline"].toString()) : <any>undefined;
            this.responsesRangeMin = _data["responsesRangeMin"];
            this.responsesRangeMax = _data["responsesRangeMax"];
            this.dailyResponsesMin = _data["dailyResponsesMin"];
            this.dailyResponsesMax = _data["dailyResponsesMax"];
            this.confirmedResponses = _data["confirmedResponses"];
        }
    }

    static fromJS(data: any): JobDetails {
        data = typeof data === 'object' ? data : {};
        let result = new JobDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["status"] = this.status;
        data["budget"] = this.budget ? this.budget.toJSON() : <any>undefined;
        data["currency"] = this.currency;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item);
        }
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item);
        }
        data["clientName"] = this.clientName;
        data["clientAvatarUrl"] = this.clientAvatarUrl;
        data["isClientVerified"] = this.isClientVerified;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["deadline"] = this.deadline ? this.deadline.toISOString() : <any>undefined;
        data["responsesRangeMin"] = this.responsesRangeMin;
        data["responsesRangeMax"] = this.responsesRangeMax;
        data["dailyResponsesMin"] = this.dailyResponsesMin;
        data["dailyResponsesMax"] = this.dailyResponsesMax;
        data["confirmedResponses"] = this.confirmedResponses;
        return data;
    }
}

export interface IJobDetails {
    jobId?: string;
    title?: string | undefined;
    description?: string | undefined;
    status?: JobDetailsStatus;
    budget?: Money;
    currency?: JobDetailsCurrency;
    category?: CategoryModel;
    skills?: string[] | undefined;
    languages?: string[] | undefined;
    clientName?: string | undefined;
    clientAvatarUrl?: string | undefined;
    isClientVerified?: boolean;
    createdAt?: Date;
    deadline?: Date | undefined;
    responsesRangeMin?: number;
    responsesRangeMax?: number;
    dailyResponsesMin?: number;
    dailyResponsesMax?: number;
    confirmedResponses?: number;
}

export class JobEntity implements IJobEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    employerId?: string;
    employer?: UserEntity;
    title?: string | undefined;
    description?: string | undefined;
    requiredSkills?: SkillEntity[] | undefined;
    category?: CategoryEntity;
    categoryId?: string;
    payout?: Money;
    expirationDate?: Date | undefined;
    duration?: number | undefined;
    status?: JobEntityStatus;
    proposals?: ProposalEntity[] | undefined;
    level?: JobEntityLevel;
    budgetType?: JobEntityBudgetType;
    publicationDate?: Date | undefined;
    paymentVerified?: boolean;
    readonly files?: FileEntity[] | undefined;
    isHidden?: boolean;

    constructor(data?: IJobEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.employerId = _data["employerId"];
            this.employer = _data["employer"] ? UserEntity.fromJS(_data["employer"]) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["requiredSkills"])) {
                this.requiredSkills = [] as any;
                for (let item of _data["requiredSkills"])
                    this.requiredSkills!.push(SkillEntity.fromJS(item));
            }
            this.category = _data["category"] ? CategoryEntity.fromJS(_data["category"]) : <any>undefined;
            this.categoryId = _data["categoryId"];
            this.payout = _data["payout"] ? Money.fromJS(_data["payout"]) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            this.status = _data["status"];
            if (Array.isArray(_data["proposals"])) {
                this.proposals = [] as any;
                for (let item of _data["proposals"])
                    this.proposals!.push(ProposalEntity.fromJS(item));
            }
            this.level = _data["level"];
            this.budgetType = _data["budgetType"];
            this.publicationDate = _data["publicationDate"] ? new Date(_data["publicationDate"].toString()) : <any>undefined;
            this.paymentVerified = _data["paymentVerified"];
            if (Array.isArray(_data["files"])) {
                (<any>this).files = [] as any;
                for (let item of _data["files"])
                    (<any>this).files!.push(FileEntity.fromJS(item));
            }
            this.isHidden = _data["isHidden"];
        }
    }

    static fromJS(data: any): JobEntity {
        data = typeof data === 'object' ? data : {};
        let result = new JobEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["employerId"] = this.employerId;
        data["employer"] = this.employer ? this.employer.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.requiredSkills)) {
            data["requiredSkills"] = [];
            for (let item of this.requiredSkills)
                data["requiredSkills"].push(item.toJSON());
        }
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["payout"] = this.payout ? this.payout.toJSON() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["duration"] = this.duration;
        data["status"] = this.status;
        if (Array.isArray(this.proposals)) {
            data["proposals"] = [];
            for (let item of this.proposals)
                data["proposals"].push(item.toJSON());
        }
        data["level"] = this.level;
        data["budgetType"] = this.budgetType;
        data["publicationDate"] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
        data["paymentVerified"] = this.paymentVerified;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["isHidden"] = this.isHidden;
        return data;
    }
}

export interface IJobEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    employerId?: string;
    employer?: UserEntity;
    title?: string | undefined;
    description?: string | undefined;
    requiredSkills?: SkillEntity[] | undefined;
    category?: CategoryEntity;
    categoryId?: string;
    payout?: Money;
    expirationDate?: Date | undefined;
    duration?: number | undefined;
    status?: JobEntityStatus;
    proposals?: ProposalEntity[] | undefined;
    level?: JobEntityLevel;
    budgetType?: JobEntityBudgetType;
    publicationDate?: Date | undefined;
    paymentVerified?: boolean;
    files?: FileEntity[] | undefined;
    isHidden?: boolean;
}

export class JobReviewEntity implements IJobReviewEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    reviewerId!: string;
    reviewer!: UserEntity;
    targetId!: string;
    target!: UserEntity;
    jobId!: string;
    job!: JobEntity;
    readonly rating!: number;
    comment!: string;
    reviewDate!: Date;

    constructor(data?: IJobReviewEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.reviewer = new UserEntity();
            this.target = new UserEntity();
            this.job = new JobEntity();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.reviewerId = _data["reviewerId"];
            this.reviewer = _data["reviewer"] ? UserEntity.fromJS(_data["reviewer"]) : new UserEntity();
            this.targetId = _data["targetId"];
            this.target = _data["target"] ? UserEntity.fromJS(_data["target"]) : new UserEntity();
            this.jobId = _data["jobId"];
            this.job = _data["job"] ? JobEntity.fromJS(_data["job"]) : new JobEntity();
            (<any>this).rating = _data["rating"];
            this.comment = _data["comment"];
            this.reviewDate = _data["reviewDate"] ? new Date(_data["reviewDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): JobReviewEntity {
        data = typeof data === 'object' ? data : {};
        let result = new JobReviewEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["reviewerId"] = this.reviewerId;
        data["reviewer"] = this.reviewer ? this.reviewer.toJSON() : <any>undefined;
        data["targetId"] = this.targetId;
        data["target"] = this.target ? this.target.toJSON() : <any>undefined;
        data["jobId"] = this.jobId;
        data["job"] = this.job ? this.job.toJSON() : <any>undefined;
        data["rating"] = this.rating;
        data["comment"] = this.comment;
        data["reviewDate"] = this.reviewDate ? this.reviewDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IJobReviewEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    reviewerId: string;
    reviewer: UserEntity;
    targetId: string;
    target: UserEntity;
    jobId: string;
    job: JobEntity;
    rating: number;
    comment: string;
    reviewDate: Date;
}

export class LoginUserSchema implements ILoginUserSchema {
    email!: string;
    password!: string;
    rememberMe?: boolean;

    constructor(data?: ILoginUserSchema) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.rememberMe = _data["rememberMe"];
        }
    }

    static fromJS(data: any): LoginUserSchema {
        data = typeof data === 'object' ? data : {};
        let result = new LoginUserSchema();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        return data;
    }
}

export interface ILoginUserSchema {
    email: string;
    password: string;
    rememberMe?: boolean;
}

export class Money implements IMoney {
    amount!: number;
    currency!: MoneyCurrency;

    constructor(data?: IMoney) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.currency = _data["currency"];
        }
    }

    static fromJS(data: any): Money {
        data = typeof data === 'object' ? data : {};
        let result = new Money();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["currency"] = this.currency;
        return data;
    }
}

export interface IMoney {
    amount: number;
    currency: MoneyCurrency;
}

export class NotificationEntity implements INotificationEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    title!: string;
    text!: string;
    fromUserId?: string | undefined;
    toUserId!: string;
    type?: NotificationEntityType;
    data?: string | undefined;
    icon?: FileEntity;

    constructor(data?: INotificationEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.text = _data["text"];
            this.fromUserId = _data["fromUserId"];
            this.toUserId = _data["toUserId"];
            this.type = _data["type"];
            this.data = _data["data"];
            this.icon = _data["icon"] ? FileEntity.fromJS(_data["icon"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NotificationEntity {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["text"] = this.text;
        data["fromUserId"] = this.fromUserId;
        data["toUserId"] = this.toUserId;
        data["type"] = this.type;
        data["data"] = this.data;
        data["icon"] = this.icon ? this.icon.toJSON() : <any>undefined;
        return data;
    }
}

export interface INotificationEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    title: string;
    text: string;
    fromUserId?: string | undefined;
    toUserId: string;
    type?: NotificationEntityType;
    data?: string | undefined;
    icon?: FileEntity;
}

export class PaymentSystemEntity implements IPaymentSystemEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name!: string;
    isActive?: boolean;

    constructor(data?: IPaymentSystemEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PaymentSystemEntity {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentSystemEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IPaymentSystemEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name: string;
    isActive?: boolean;
}

export class PortfolioProjectEntity implements IPortfolioProjectEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name?: string | undefined;
    userRole?: string | undefined;
    skills?: SkillEntity[] | undefined;
    description?: string | undefined;
    images?: FileEntity[] | undefined;
    hidden?: boolean;
    userId?: string;
    user?: UserEntity;

    constructor(data?: IPortfolioProjectEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.userRole = _data["userRole"];
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(SkillEntity.fromJS(item));
            }
            this.description = _data["description"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(FileEntity.fromJS(item));
            }
            this.hidden = _data["hidden"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserEntity.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PortfolioProjectEntity {
        data = typeof data === 'object' ? data : {};
        let result = new PortfolioProjectEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["userRole"] = this.userRole;
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item.toJSON());
        }
        data["description"] = this.description;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["hidden"] = this.hidden;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPortfolioProjectEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name?: string | undefined;
    userRole?: string | undefined;
    skills?: SkillEntity[] | undefined;
    description?: string | undefined;
    images?: FileEntity[] | undefined;
    hidden?: boolean;
    userId?: string;
    user?: UserEntity;
}

export class ProposalEntity implements IProposalEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    jobId?: string;
    job?: JobEntity;
    freelancerId?: string;
    freelancer?: UserEntity;
    proposedRate?: number;
    coverLetter?: string | undefined;
    status?: ProposalEntityStatus;
    files?: FileEntity[] | undefined;

    constructor(data?: IProposalEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.jobId = _data["jobId"];
            this.job = _data["job"] ? JobEntity.fromJS(_data["job"]) : <any>undefined;
            this.freelancerId = _data["freelancerId"];
            this.freelancer = _data["freelancer"] ? UserEntity.fromJS(_data["freelancer"]) : <any>undefined;
            this.proposedRate = _data["proposedRate"];
            this.coverLetter = _data["coverLetter"];
            this.status = _data["status"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(FileEntity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProposalEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ProposalEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["jobId"] = this.jobId;
        data["job"] = this.job ? this.job.toJSON() : <any>undefined;
        data["freelancerId"] = this.freelancerId;
        data["freelancer"] = this.freelancer ? this.freelancer.toJSON() : <any>undefined;
        data["proposedRate"] = this.proposedRate;
        data["coverLetter"] = this.coverLetter;
        data["status"] = this.status;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProposalEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    jobId?: string;
    job?: JobEntity;
    freelancerId?: string;
    freelancer?: UserEntity;
    proposedRate?: number;
    coverLetter?: string | undefined;
    status?: ProposalEntityStatus;
    files?: FileEntity[] | undefined;
}

export class ReactToTaskCommand implements IReactToTaskCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    taskId?: string;
    approve?: boolean;
    newTitle?: string | undefined;
    newDescription?: string | undefined;

    constructor(data?: IReactToTaskCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.taskId = _data["taskId"];
            this.approve = _data["approve"];
            this.newTitle = _data["newTitle"];
            this.newDescription = _data["newDescription"];
        }
    }

    static fromJS(data: any): ReactToTaskCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ReactToTaskCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["taskId"] = this.taskId;
        data["approve"] = this.approve;
        data["newTitle"] = this.newTitle;
        data["newDescription"] = this.newDescription;
        return data;
    }
}

export interface IReactToTaskCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    taskId?: string;
    approve?: boolean;
    newTitle?: string | undefined;
    newDescription?: string | undefined;
}

export class ReactToWorkSessionCommand implements IReactToWorkSessionCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    workSessionId?: string;
    isApproved?: boolean;
    clientComment?: string | undefined;

    constructor(data?: IReactToWorkSessionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.workSessionId = _data["workSessionId"];
            this.isApproved = _data["isApproved"];
            this.clientComment = _data["clientComment"];
        }
    }

    static fromJS(data: any): ReactToWorkSessionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ReactToWorkSessionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["workSessionId"] = this.workSessionId;
        data["isApproved"] = this.isApproved;
        data["clientComment"] = this.clientComment;
        return data;
    }
}

export interface IReactToWorkSessionCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    workSessionId?: string;
    isApproved?: boolean;
    clientComment?: string | undefined;
}

export class RefundTransactionCommand implements IRefundTransactionCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    transactionId!: string;
    isContractCancellation?: boolean;

    constructor(data?: IRefundTransactionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.transactionId = _data["transactionId"];
            this.isContractCancellation = _data["isContractCancellation"];
        }
    }

    static fromJS(data: any): RefundTransactionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RefundTransactionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["transactionId"] = this.transactionId;
        data["isContractCancellation"] = this.isContractCancellation;
        return data;
    }
}

export interface IRefundTransactionCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    transactionId: string;
    isContractCancellation?: boolean;
}

export class RegisterUserSchema implements IRegisterUserSchema {
    name!: string;
    surname!: string;
    phone?: string | undefined;
    password!: string;
    email!: string;
    country!: RegisterUserSchemaCountry;
    type!: RegisterUserSchemaType;

    constructor(data?: IRegisterUserSchema) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.phone = _data["phone"];
            this.password = _data["password"];
            this.email = _data["email"];
            this.country = _data["country"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): RegisterUserSchema {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserSchema();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["phone"] = this.phone;
        data["password"] = this.password;
        data["email"] = this.email;
        data["country"] = this.country;
        data["type"] = this.type;
        return data;
    }
}

export interface IRegisterUserSchema {
    name: string;
    surname: string;
    phone?: string | undefined;
    password: string;
    email: string;
    country: RegisterUserSchemaCountry;
    type: RegisterUserSchemaType;
}

export class ResetPasswordCommand implements IResetPasswordCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    code!: string;
    email!: string;
    newPassword!: string;

    constructor(data?: IResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.code = _data["code"];
            this.email = _data["email"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["code"] = this.code;
        data["email"] = this.email;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IResetPasswordCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    code: string;
    email: string;
    newPassword: string;
}

export class ResolveDisputeCommand implements IResolveDisputeCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    disputeId?: string;
    strategy?: ResolveDisputeCommandStrategy;
    moderatorComment?: string | undefined;
    blockFreelancerWallet?: boolean;
    blockClientWallet?: boolean;
    blockFreelancerOrders?: boolean;
    blockUntil?: Date | undefined;

    constructor(data?: IResolveDisputeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.disputeId = _data["disputeId"];
            this.strategy = _data["strategy"];
            this.moderatorComment = _data["moderatorComment"];
            this.blockFreelancerWallet = _data["blockFreelancerWallet"];
            this.blockClientWallet = _data["blockClientWallet"];
            this.blockFreelancerOrders = _data["blockFreelancerOrders"];
            this.blockUntil = _data["blockUntil"] ? new Date(_data["blockUntil"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ResolveDisputeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveDisputeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["disputeId"] = this.disputeId;
        data["strategy"] = this.strategy;
        data["moderatorComment"] = this.moderatorComment;
        data["blockFreelancerWallet"] = this.blockFreelancerWallet;
        data["blockClientWallet"] = this.blockClientWallet;
        data["blockFreelancerOrders"] = this.blockFreelancerOrders;
        data["blockUntil"] = this.blockUntil ? this.blockUntil.toISOString() : <any>undefined;
        return data;
    }
}

export interface IResolveDisputeCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    disputeId?: string;
    strategy?: ResolveDisputeCommandStrategy;
    moderatorComment?: string | undefined;
    blockFreelancerWallet?: boolean;
    blockClientWallet?: boolean;
    blockFreelancerOrders?: boolean;
    blockUntil?: Date | undefined;
}

export class SelectContestWinnerCommand implements ISelectContestWinnerCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contestId!: string;
    entryId!: string;

    constructor(data?: ISelectContestWinnerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contestId = _data["contestId"];
            this.entryId = _data["entryId"];
        }
    }

    static fromJS(data: any): SelectContestWinnerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SelectContestWinnerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contestId"] = this.contestId;
        data["entryId"] = this.entryId;
        return data;
    }
}

export interface ISelectContestWinnerCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contestId: string;
    entryId: string;
}

export class SendResetCodeCommand implements ISendResetCodeCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    email!: string;

    constructor(data?: ISendResetCodeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): SendResetCodeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendResetCodeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["email"] = this.email;
        return data;
    }
}

export interface ISendResetCodeCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    email: string;
}

export class SkillEntity implements ISkillEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name?: string | undefined;

    constructor(data?: ISkillEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SkillEntity {
        data = typeof data === 'object' ? data : {};
        let result = new SkillEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        return data;
    }
}

export interface ISkillEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name?: string | undefined;
}

export class SkillModel implements ISkillModel {
    id?: string;
    name?: string | undefined;

    constructor(data?: ISkillModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SkillModel {
        data = typeof data === 'object' ? data : {};
        let result = new SkillModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ISkillModel {
    id?: string;
    name?: string | undefined;
}

export class StartContestCommand implements IStartContestCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contestId?: string;

    constructor(data?: IStartContestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contestId = _data["contestId"];
        }
    }

    static fromJS(data: any): StartContestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new StartContestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contestId"] = this.contestId;
        return data;
    }
}

export interface IStartContestCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contestId?: string;
}

export class StartPaymentFlowCommand implements IStartPaymentFlowCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    amount?: Money;
    flow?: StartPaymentFlowCommandFlow;
    type?: StartPaymentFlowCommandType;
    providerId?: string;

    constructor(data?: IStartPaymentFlowCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.amount = _data["amount"] ? Money.fromJS(_data["amount"]) : <any>undefined;
            this.flow = _data["flow"];
            this.type = _data["type"];
            this.providerId = _data["providerId"];
        }
    }

    static fromJS(data: any): StartPaymentFlowCommand {
        data = typeof data === 'object' ? data : {};
        let result = new StartPaymentFlowCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["amount"] = this.amount ? this.amount.toJSON() : <any>undefined;
        data["flow"] = this.flow;
        data["type"] = this.type;
        data["providerId"] = this.providerId;
        return data;
    }
}

export interface IStartPaymentFlowCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    amount?: Money;
    flow?: StartPaymentFlowCommandFlow;
    type?: StartPaymentFlowCommandType;
    providerId?: string;
}

export class StartWorkSessionCommand implements IStartWorkSessionCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contractId?: string;

    constructor(data?: IStartWorkSessionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contractId = _data["contractId"];
        }
    }

    static fromJS(data: any): StartWorkSessionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new StartWorkSessionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contractId"] = this.contractId;
        return data;
    }
}

export interface IStartWorkSessionCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contractId?: string;
}

export class SubmitContestEntryCommand implements ISubmitContestEntryCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contestId?: string;
    description?: string | undefined;
    submissionFiles?: CreateFileDto[] | undefined;

    constructor(data?: ISubmitContestEntryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contestId = _data["contestId"];
            this.description = _data["description"];
            if (Array.isArray(_data["submissionFiles"])) {
                this.submissionFiles = [] as any;
                for (let item of _data["submissionFiles"])
                    this.submissionFiles!.push(CreateFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubmitContestEntryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitContestEntryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contestId"] = this.contestId;
        data["description"] = this.description;
        if (Array.isArray(this.submissionFiles)) {
            data["submissionFiles"] = [];
            for (let item of this.submissionFiles)
                data["submissionFiles"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISubmitContestEntryCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contestId?: string;
    description?: string | undefined;
    submissionFiles?: CreateFileDto[] | undefined;
}

export class SubmitProposalCommand implements ISubmitProposalCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    jobId?: string;
    coverLetter?: string | undefined;
    proposedRate?: number | undefined;

    constructor(data?: ISubmitProposalCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.jobId = _data["jobId"];
            this.coverLetter = _data["coverLetter"];
            this.proposedRate = _data["proposedRate"];
        }
    }

    static fromJS(data: any): SubmitProposalCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitProposalCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["jobId"] = this.jobId;
        data["coverLetter"] = this.coverLetter;
        data["proposedRate"] = this.proposedRate;
        return data;
    }
}

export interface ISubmitProposalCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    jobId?: string;
    coverLetter?: string | undefined;
    proposedRate?: number | undefined;
}

export class SubmitWorkSessionCommand implements ISubmitWorkSessionCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    sessionId?: string;

    constructor(data?: ISubmitWorkSessionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.sessionId = _data["sessionId"];
        }
    }

    static fromJS(data: any): SubmitWorkSessionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitWorkSessionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["sessionId"] = this.sessionId;
        return data;
    }
}

export interface ISubmitWorkSessionCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    sessionId?: string;
}

export class SuspendClientProfileCommand implements ISuspendClientProfileCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    clientId?: string;
    reason?: string | undefined;

    constructor(data?: ISuspendClientProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.clientId = _data["clientId"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): SuspendClientProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SuspendClientProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["clientId"] = this.clientId;
        data["reason"] = this.reason;
        return data;
    }
}

export interface ISuspendClientProfileCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    clientId?: string;
    reason?: string | undefined;
}

export class TaskEntity implements ITaskEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    contractId?: string;
    contract?: ContractEntity;
    readonly taskTitle?: string | undefined;
    readonly taskDescription?: string | undefined;
    readonly status?: string | undefined;
    readonly priority?: number;
    readonly creationDate?: Date;
    readonly completionDate?: Date | undefined;
    readonly isCompleted?: boolean;
    readonly isApproved?: boolean;
    readonly isInRevision?: boolean;

    constructor(data?: ITaskEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.contractId = _data["contractId"];
            this.contract = _data["contract"] ? ContractEntity.fromJS(_data["contract"]) : <any>undefined;
            (<any>this).taskTitle = _data["taskTitle"];
            (<any>this).taskDescription = _data["taskDescription"];
            (<any>this).status = _data["status"];
            (<any>this).priority = _data["priority"];
            (<any>this).creationDate = _data["creationDate"] ? new Date(_data["creationDate"].toString()) : <any>undefined;
            (<any>this).completionDate = _data["completionDate"] ? new Date(_data["completionDate"].toString()) : <any>undefined;
            (<any>this).isCompleted = _data["isCompleted"];
            (<any>this).isApproved = _data["isApproved"];
            (<any>this).isInRevision = _data["isInRevision"];
        }
    }

    static fromJS(data: any): TaskEntity {
        data = typeof data === 'object' ? data : {};
        let result = new TaskEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["contractId"] = this.contractId;
        data["contract"] = this.contract ? this.contract.toJSON() : <any>undefined;
        data["taskTitle"] = this.taskTitle;
        data["taskDescription"] = this.taskDescription;
        data["status"] = this.status;
        data["priority"] = this.priority;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["completionDate"] = this.completionDate ? this.completionDate.toISOString() : <any>undefined;
        data["isCompleted"] = this.isCompleted;
        data["isApproved"] = this.isApproved;
        data["isInRevision"] = this.isInRevision;
        return data;
    }
}

export interface ITaskEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    contractId?: string;
    contract?: ContractEntity;
    taskTitle?: string | undefined;
    taskDescription?: string | undefined;
    status?: string | undefined;
    priority?: number;
    creationDate?: Date;
    completionDate?: Date | undefined;
    isCompleted?: boolean;
    isApproved?: boolean;
    isInRevision?: boolean;
}

export class TicketCommentEntity implements ITicketCommentEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    createdBy!: UserEntity;
    text!: string;
    parentCommentId?: string | undefined;
    isDeleted!: boolean;
    ticketId!: string;
    files!: FileEntity[];

    constructor(data?: ITicketCommentEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new UserEntity();
            this.files = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"] ? UserEntity.fromJS(_data["createdBy"]) : new UserEntity();
            this.text = _data["text"];
            this.parentCommentId = _data["parentCommentId"];
            this.isDeleted = _data["isDeleted"];
            this.ticketId = _data["ticketId"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(FileEntity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TicketCommentEntity {
        data = typeof data === 'object' ? data : {};
        let result = new TicketCommentEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["text"] = this.text;
        data["parentCommentId"] = this.parentCommentId;
        data["isDeleted"] = this.isDeleted;
        data["ticketId"] = this.ticketId;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITicketCommentEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    createdBy: UserEntity;
    text: string;
    parentCommentId?: string | undefined;
    isDeleted: boolean;
    ticketId: string;
    files: FileEntity[];
}

export class TicketEntity implements ITicketEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    text!: string;
    subject!: string;
    files?: FileEntity[] | undefined;
    answeredCommentId?: string | undefined;
    readonly status!: TicketEntityStatus;
    assignedUser?: UserEntity;
    readonly assignedUserId?: string | undefined;
    readonly comments?: TicketCommentEntity[] | undefined;
    readonly closedById?: string | undefined;
    createdBy?: UserEntity;

    constructor(data?: ITicketEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.text = _data["text"];
            this.subject = _data["subject"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(FileEntity.fromJS(item));
            }
            this.answeredCommentId = _data["answeredCommentId"];
            (<any>this).status = _data["status"];
            this.assignedUser = _data["assignedUser"] ? UserEntity.fromJS(_data["assignedUser"]) : <any>undefined;
            (<any>this).assignedUserId = _data["assignedUserId"];
            if (Array.isArray(_data["comments"])) {
                (<any>this).comments = [] as any;
                for (let item of _data["comments"])
                    (<any>this).comments!.push(TicketCommentEntity.fromJS(item));
            }
            (<any>this).closedById = _data["closedById"];
            this.createdBy = _data["createdBy"] ? UserEntity.fromJS(_data["createdBy"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TicketEntity {
        data = typeof data === 'object' ? data : {};
        let result = new TicketEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["text"] = this.text;
        data["subject"] = this.subject;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["answeredCommentId"] = this.answeredCommentId;
        data["status"] = this.status;
        data["assignedUser"] = this.assignedUser ? this.assignedUser.toJSON() : <any>undefined;
        data["assignedUserId"] = this.assignedUserId;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        data["closedById"] = this.closedById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITicketEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    text: string;
    subject: string;
    files?: FileEntity[] | undefined;
    answeredCommentId?: string | undefined;
    status: TicketEntityStatus;
    assignedUser?: UserEntity;
    assignedUserId?: string | undefined;
    comments?: TicketCommentEntity[] | undefined;
    closedById?: string | undefined;
    createdBy?: UserEntity;
}

export class TransactionEntity implements ITransactionEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    readonly walletId?: string;
    antoganistTransactionId?: string | undefined;
    rawAmount?: Money;
    netAmount?: Money;
    appliedFee?: Money;
    readonly status?: TransactionEntityStatus;
    readonly type?: TransactionEntityType;
    readonly flow?: TransactionEntityFlow;
    props?: TransactionPropsEntity;
    readonly frozenUntil?: Date | undefined;
    readonly comment?: string | undefined;
    completedAt?: Date | undefined;
    provider?: TransactionProviderEntity;

    constructor(data?: ITransactionEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            (<any>this).walletId = _data["walletId"];
            this.antoganistTransactionId = _data["antoganistTransactionId"];
            this.rawAmount = _data["rawAmount"] ? Money.fromJS(_data["rawAmount"]) : <any>undefined;
            this.netAmount = _data["netAmount"] ? Money.fromJS(_data["netAmount"]) : <any>undefined;
            this.appliedFee = _data["appliedFee"] ? Money.fromJS(_data["appliedFee"]) : <any>undefined;
            (<any>this).status = _data["status"];
            (<any>this).type = _data["type"];
            (<any>this).flow = _data["flow"];
            this.props = _data["props"] ? TransactionPropsEntity.fromJS(_data["props"]) : <any>undefined;
            (<any>this).frozenUntil = _data["frozenUntil"] ? new Date(_data["frozenUntil"].toString()) : <any>undefined;
            (<any>this).comment = _data["comment"];
            this.completedAt = _data["completedAt"] ? new Date(_data["completedAt"].toString()) : <any>undefined;
            this.provider = _data["provider"] ? TransactionProviderEntity.fromJS(_data["provider"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TransactionEntity {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["walletId"] = this.walletId;
        data["antoganistTransactionId"] = this.antoganistTransactionId;
        data["rawAmount"] = this.rawAmount ? this.rawAmount.toJSON() : <any>undefined;
        data["netAmount"] = this.netAmount ? this.netAmount.toJSON() : <any>undefined;
        data["appliedFee"] = this.appliedFee ? this.appliedFee.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["type"] = this.type;
        data["flow"] = this.flow;
        data["props"] = this.props ? this.props.toJSON() : <any>undefined;
        data["frozenUntil"] = this.frozenUntil ? this.frozenUntil.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["completedAt"] = this.completedAt ? this.completedAt.toISOString() : <any>undefined;
        data["provider"] = this.provider ? this.provider.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITransactionEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    walletId?: string;
    antoganistTransactionId?: string | undefined;
    rawAmount?: Money;
    netAmount?: Money;
    appliedFee?: Money;
    status?: TransactionEntityStatus;
    type?: TransactionEntityType;
    flow?: TransactionEntityFlow;
    props?: TransactionPropsEntity;
    frozenUntil?: Date | undefined;
    comment?: string | undefined;
    completedAt?: Date | undefined;
    provider?: TransactionProviderEntity;
}

export class TransactionPropsEntity implements ITransactionPropsEntity {
    readonly paymentUrl?: string | undefined;
    readonly successUrl?: string | undefined;
    readonly paymentGateway?: string | undefined;
    feeContext?: FeeContext;

    constructor(data?: ITransactionPropsEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).paymentUrl = _data["paymentUrl"];
            (<any>this).successUrl = _data["successUrl"];
            (<any>this).paymentGateway = _data["paymentGateway"];
            this.feeContext = _data["feeContext"] ? FeeContext.fromJS(_data["feeContext"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TransactionPropsEntity {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionPropsEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentUrl"] = this.paymentUrl;
        data["successUrl"] = this.successUrl;
        data["paymentGateway"] = this.paymentGateway;
        data["feeContext"] = this.feeContext ? this.feeContext.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITransactionPropsEntity {
    paymentUrl?: string | undefined;
    successUrl?: string | undefined;
    paymentGateway?: string | undefined;
    feeContext?: FeeContext;
}

export class TransactionProviderEntity implements ITransactionProviderEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name!: string;
    feePercent!: number;
    systems!: PaymentSystemEntity[];
    logo!: FileEntity;

    constructor(data?: ITransactionProviderEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.systems = [];
            this.logo = new FileEntity();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.feePercent = _data["feePercent"];
            if (Array.isArray(_data["systems"])) {
                this.systems = [] as any;
                for (let item of _data["systems"])
                    this.systems!.push(PaymentSystemEntity.fromJS(item));
            }
            this.logo = _data["logo"] ? FileEntity.fromJS(_data["logo"]) : new FileEntity();
        }
    }

    static fromJS(data: any): TransactionProviderEntity {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionProviderEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["feePercent"] = this.feePercent;
        if (Array.isArray(this.systems)) {
            data["systems"] = [];
            for (let item of this.systems)
                data["systems"].push(item.toJSON());
        }
        data["logo"] = this.logo ? this.logo.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITransactionProviderEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name: string;
    feePercent: number;
    systems: PaymentSystemEntity[];
    logo: FileEntity;
}

export class UpdateCategoryCommand implements IUpdateCategoryCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    categoryId?: string;
    name?: string | undefined;

    constructor(data?: IUpdateCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateCategoryCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    categoryId?: string;
    name?: string | undefined;
}

export class UpdateClientProfileCommand implements IUpdateClientProfileCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    clientId?: string;
    companyName?: string | undefined;
    companyDescription?: string | undefined;
    companyWebsite?: string | undefined;
    location?: string | undefined;
    companyLogo?: CreateFileDto;
    employerType?: UpdateClientProfileCommandEmployerType | undefined;
    phoneNumber?: string | undefined;

    constructor(data?: IUpdateClientProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.clientId = _data["clientId"];
            this.companyName = _data["companyName"];
            this.companyDescription = _data["companyDescription"];
            this.companyWebsite = _data["companyWebsite"];
            this.location = _data["location"];
            this.companyLogo = _data["companyLogo"] ? CreateFileDto.fromJS(_data["companyLogo"]) : <any>undefined;
            this.employerType = _data["employerType"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): UpdateClientProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["clientId"] = this.clientId;
        data["companyName"] = this.companyName;
        data["companyDescription"] = this.companyDescription;
        data["companyWebsite"] = this.companyWebsite;
        data["location"] = this.location;
        data["companyLogo"] = this.companyLogo ? this.companyLogo.toJSON() : <any>undefined;
        data["employerType"] = this.employerType;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface IUpdateClientProfileCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    clientId?: string;
    companyName?: string | undefined;
    companyDescription?: string | undefined;
    companyWebsite?: string | undefined;
    location?: string | undefined;
    companyLogo?: CreateFileDto;
    employerType?: UpdateClientProfileCommandEmployerType | undefined;
    phoneNumber?: string | undefined;
}

export class UpdateContestCommand implements IUpdateContestCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    contestId?: string;
    title?: string | undefined;
    description?: string | undefined;
    prizePool?: number | undefined;

    constructor(data?: IUpdateContestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contestId = _data["contestId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.prizePool = _data["prizePool"];
        }
    }

    static fromJS(data: any): UpdateContestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contestId"] = this.contestId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["prizePool"] = this.prizePool;
        return data;
    }
}

export interface IUpdateContestCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    contestId?: string;
    title?: string | undefined;
    description?: string | undefined;
    prizePool?: number | undefined;
}

export class UpdateFreelancerProfileCommand implements IUpdateFreelancerProfileCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    skills?: string[] | undefined;
    experience?: string | undefined;
    resume?: string | undefined;
    hourlyRate?: number | undefined;
    availability?: UpdateFreelancerProfileCommandAvailability | undefined;

    constructor(data?: IUpdateFreelancerProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(item);
            }
            this.experience = _data["experience"];
            this.resume = _data["resume"];
            this.hourlyRate = _data["hourlyRate"];
            this.availability = _data["availability"];
        }
    }

    static fromJS(data: any): UpdateFreelancerProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFreelancerProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item);
        }
        data["experience"] = this.experience;
        data["resume"] = this.resume;
        data["hourlyRate"] = this.hourlyRate;
        data["availability"] = this.availability;
        return data;
    }
}

export interface IUpdateFreelancerProfileCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    skills?: string[] | undefined;
    experience?: string | undefined;
    resume?: string | undefined;
    hourlyRate?: number | undefined;
    availability?: UpdateFreelancerProfileCommandAvailability | undefined;
}

export class UpdateFreelancerTeamCommand implements IUpdateFreelancerTeamCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    teamId?: string;
    name?: string | undefined;
    avatarFile?: CreateFileDto;
    closed?: boolean | undefined;
    closedReason?: string | undefined;

    constructor(data?: IUpdateFreelancerTeamCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.teamId = _data["teamId"];
            this.name = _data["name"];
            this.avatarFile = _data["avatarFile"] ? CreateFileDto.fromJS(_data["avatarFile"]) : <any>undefined;
            this.closed = _data["closed"];
            this.closedReason = _data["closedReason"];
        }
    }

    static fromJS(data: any): UpdateFreelancerTeamCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFreelancerTeamCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["teamId"] = this.teamId;
        data["name"] = this.name;
        data["avatarFile"] = this.avatarFile ? this.avatarFile.toJSON() : <any>undefined;
        data["closed"] = this.closed;
        data["closedReason"] = this.closedReason;
        return data;
    }
}

export interface IUpdateFreelancerTeamCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    teamId?: string;
    name?: string | undefined;
    avatarFile?: CreateFileDto;
    closed?: boolean | undefined;
    closedReason?: string | undefined;
}

export class UpdateJobCommand implements IUpdateJobCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    jobId?: string;
    title?: string | undefined;
    description?: string | undefined;
    requiredSkillIds?: string[] | undefined;
    categoryId?: string | undefined;
    budget?: number | undefined;
    hourlyRate?: number | undefined;
    expirationDate?: Date | undefined;
    duration?: number | undefined;
    files?: CreateFileDto[] | undefined;

    constructor(data?: IUpdateJobCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.jobId = _data["jobId"];
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["requiredSkillIds"])) {
                this.requiredSkillIds = [] as any;
                for (let item of _data["requiredSkillIds"])
                    this.requiredSkillIds!.push(item);
            }
            this.categoryId = _data["categoryId"];
            this.budget = _data["budget"];
            this.hourlyRate = _data["hourlyRate"];
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(CreateFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateJobCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateJobCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["jobId"] = this.jobId;
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.requiredSkillIds)) {
            data["requiredSkillIds"] = [];
            for (let item of this.requiredSkillIds)
                data["requiredSkillIds"].push(item);
        }
        data["categoryId"] = this.categoryId;
        data["budget"] = this.budget;
        data["hourlyRate"] = this.hourlyRate;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["duration"] = this.duration;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateJobCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    jobId?: string;
    title?: string | undefined;
    description?: string | undefined;
    requiredSkillIds?: string[] | undefined;
    categoryId?: string | undefined;
    budget?: number | undefined;
    hourlyRate?: number | undefined;
    expirationDate?: Date | undefined;
    duration?: number | undefined;
    files?: CreateFileDto[] | undefined;
}

export class UpdatePortfolioProjectCommand implements IUpdatePortfolioProjectCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    projectId?: string;
    name?: string | undefined;
    userRole?: string | undefined;
    skills?: string[] | undefined;
    description?: string | undefined;
    images?: CreateFileDto[] | undefined;
    hidden?: boolean | undefined;

    constructor(data?: IUpdatePortfolioProjectCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.projectId = _data["projectId"];
            this.name = _data["name"];
            this.userRole = _data["userRole"];
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(item);
            }
            this.description = _data["description"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(CreateFileDto.fromJS(item));
            }
            this.hidden = _data["hidden"];
        }
    }

    static fromJS(data: any): UpdatePortfolioProjectCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePortfolioProjectCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["projectId"] = this.projectId;
        data["name"] = this.name;
        data["userRole"] = this.userRole;
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item);
        }
        data["description"] = this.description;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["hidden"] = this.hidden;
        return data;
    }
}

export interface IUpdatePortfolioProjectCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    projectId?: string;
    name?: string | undefined;
    userRole?: string | undefined;
    skills?: string[] | undefined;
    description?: string | undefined;
    images?: CreateFileDto[] | undefined;
    hidden?: boolean | undefined;
}

export class UpdateProposalCommand implements IUpdateProposalCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    proposalId?: string;
    coverLetter?: string | undefined;
    proposedRate?: number | undefined;

    constructor(data?: IUpdateProposalCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.proposalId = _data["proposalId"];
            this.coverLetter = _data["coverLetter"];
            this.proposedRate = _data["proposedRate"];
        }
    }

    static fromJS(data: any): UpdateProposalCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProposalCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["proposalId"] = this.proposalId;
        data["coverLetter"] = this.coverLetter;
        data["proposedRate"] = this.proposedRate;
        return data;
    }
}

export interface IUpdateProposalCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    proposalId?: string;
    coverLetter?: string | undefined;
    proposedRate?: number | undefined;
}

export class UpdateSkillDto implements IUpdateSkillDto {
    skillId?: string;
    name?: string | undefined;

    constructor(data?: IUpdateSkillDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skillId = _data["skillId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateSkillDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSkillDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skillId"] = this.skillId;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateSkillDto {
    skillId?: string;
    name?: string | undefined;
}

export class UpdateSkillsCommand implements IUpdateSkillsCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    skills?: UpdateSkillDto[] | undefined;

    constructor(data?: IUpdateSkillsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(UpdateSkillDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateSkillsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSkillsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateSkillsCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    skills?: UpdateSkillDto[] | undefined;
}

export class UpdateTaskCommand implements IUpdateTaskCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    taskId?: string;
    title?: string | undefined;
    description?: string | undefined;
    priority?: number | undefined;

    constructor(data?: IUpdateTaskCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.taskId = _data["taskId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.priority = _data["priority"];
        }
    }

    static fromJS(data: any): UpdateTaskCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTaskCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["taskId"] = this.taskId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["priority"] = this.priority;
        return data;
    }
}

export interface IUpdateTaskCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    taskId?: string;
    title?: string | undefined;
    description?: string | undefined;
    priority?: number | undefined;
}

export class UpdateUserCommand implements IUpdateUserCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    userId!: string;
    email?: string | undefined;
    role?: UpdateUserCommandRole | undefined;
    avatar?: CreateFileDto;
    description?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    oldPassword?: string | undefined;
    newPassword?: string | undefined;
    telegramId?: string | undefined;

    constructor(data?: IUpdateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.role = _data["role"];
            this.avatar = _data["avatar"] ? CreateFileDto.fromJS(_data["avatar"]) : <any>undefined;
            this.description = _data["description"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
            this.telegramId = _data["telegramId"];
        }
    }

    static fromJS(data: any): UpdateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["role"] = this.role;
        data["avatar"] = this.avatar ? this.avatar.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        data["telegramId"] = this.telegramId;
        return data;
    }
}

export interface IUpdateUserCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    userId: string;
    email?: string | undefined;
    role?: UpdateUserCommandRole | undefined;
    avatar?: CreateFileDto;
    description?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    oldPassword?: string | undefined;
    newPassword?: string | undefined;
    telegramId?: string | undefined;
}

export class UserEntity implements IUserEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name!: string;
    surname!: string;
    fullname!: string;
    role?: UserEntityRole;
    type?: UserEntityType;
    email!: string;
    avatar?: FileEntity;
    isOnline!: boolean;
    isSuperadmin?: boolean;
    phone?: string | undefined;
    telegramId?: string | undefined;
    blocked?: boolean;
    location?: UserEntityLocation | undefined;
    readonly isExternalUser?: boolean;

    constructor(data?: IUserEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.fullname = _data["fullname"];
            this.role = _data["role"];
            this.type = _data["type"];
            this.email = _data["email"];
            this.avatar = _data["avatar"] ? FileEntity.fromJS(_data["avatar"]) : <any>undefined;
            this.isOnline = _data["isOnline"];
            this.isSuperadmin = _data["isSuperadmin"];
            this.phone = _data["phone"];
            this.telegramId = _data["telegramId"];
            this.blocked = _data["blocked"];
            this.location = _data["location"];
            (<any>this).isExternalUser = _data["isExternalUser"];
        }
    }

    static fromJS(data: any): UserEntity {
        data = typeof data === 'object' ? data : {};
        let result = new UserEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["fullname"] = this.fullname;
        data["role"] = this.role;
        data["type"] = this.type;
        data["email"] = this.email;
        data["avatar"] = this.avatar ? this.avatar.toJSON() : <any>undefined;
        data["isOnline"] = this.isOnline;
        data["isSuperadmin"] = this.isSuperadmin;
        data["phone"] = this.phone;
        data["telegramId"] = this.telegramId;
        data["blocked"] = this.blocked;
        data["location"] = this.location;
        data["isExternalUser"] = this.isExternalUser;
        return data;
    }
}

export interface IUserEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    name: string;
    surname: string;
    fullname: string;
    role?: UserEntityRole;
    type?: UserEntityType;
    email: string;
    avatar?: FileEntity;
    isOnline: boolean;
    isSuperadmin?: boolean;
    phone?: string | undefined;
    telegramId?: string | undefined;
    blocked?: boolean;
    location?: UserEntityLocation | undefined;
    isExternalUser?: boolean;
}

export class WalletEntity implements IWalletEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    readonly userId!: string;
    user!: UserEntity;
    readonly currency!: WalletEntityCurrency;
    frozen!: Money;
    availableBalance!: Money;
    pendingIncome!: Money;
    readonly blocked!: boolean;
    readonly blockReason?: WalletEntityBlockReason;

    constructor(data?: IWalletEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEntity();
            this.frozen = new Money();
            this.availableBalance = new Money();
            this.pendingIncome = new Money();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            (<any>this).userId = _data["userId"];
            this.user = _data["user"] ? UserEntity.fromJS(_data["user"]) : new UserEntity();
            (<any>this).currency = _data["currency"];
            this.frozen = _data["frozen"] ? Money.fromJS(_data["frozen"]) : new Money();
            this.availableBalance = _data["availableBalance"] ? Money.fromJS(_data["availableBalance"]) : new Money();
            this.pendingIncome = _data["pendingIncome"] ? Money.fromJS(_data["pendingIncome"]) : new Money();
            (<any>this).blocked = _data["blocked"];
            (<any>this).blockReason = _data["blockReason"];
        }
    }

    static fromJS(data: any): WalletEntity {
        data = typeof data === 'object' ? data : {};
        let result = new WalletEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["currency"] = this.currency;
        data["frozen"] = this.frozen ? this.frozen.toJSON() : <any>undefined;
        data["availableBalance"] = this.availableBalance ? this.availableBalance.toJSON() : <any>undefined;
        data["pendingIncome"] = this.pendingIncome ? this.pendingIncome.toJSON() : <any>undefined;
        data["blocked"] = this.blocked;
        data["blockReason"] = this.blockReason;
        return data;
    }
}

export interface IWalletEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    userId: string;
    user: UserEntity;
    currency: WalletEntityCurrency;
    frozen: Money;
    availableBalance: Money;
    pendingIncome: Money;
    blocked: boolean;
    blockReason?: WalletEntityBlockReason;
}

export class WarnUserScheme implements IWarnUserScheme {
    reason?: string | undefined;

    constructor(data?: IWarnUserScheme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): WarnUserScheme {
        data = typeof data === 'object' ? data : {};
        let result = new WarnUserScheme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        return data;
    }
}

export interface IWarnUserScheme {
    reason?: string | undefined;
}

export class WithdrawProposalCommand implements IWithdrawProposalCommand {
    readonly commandId?: string | undefined;
    readonly timestamp?: Date;
    proposalId?: string;

    constructor(data?: IWithdrawProposalCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.proposalId = _data["proposalId"];
        }
    }

    static fromJS(data: any): WithdrawProposalCommand {
        data = typeof data === 'object' ? data : {};
        let result = new WithdrawProposalCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["proposalId"] = this.proposalId;
        return data;
    }
}

export interface IWithdrawProposalCommand {
    commandId?: string | undefined;
    timestamp?: Date;
    proposalId?: string;
}

export class WorkSessionEntity implements IWorkSessionEntity {
    id!: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    files?: FileEntity[] | undefined;
    contractId?: string;
    contract?: ContractEntity;
    freelancerId?: string;
    freelancer?: UserEntity;
    startDate?: Date;
    endDate?: Date | undefined;
    comment?: string | undefined;
    clientComment?: string | undefined;
    submittedAt?: Date | undefined;
    approvedAt?: Date | undefined;
    rejectedAt?: Date | undefined;
    status?: WorkSessionEntityStatus;
    readonly autoApproved?: boolean;

    constructor(data?: IWorkSessionEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(FileEntity.fromJS(item));
            }
            this.contractId = _data["contractId"];
            this.contract = _data["contract"] ? ContractEntity.fromJS(_data["contract"]) : <any>undefined;
            this.freelancerId = _data["freelancerId"];
            this.freelancer = _data["freelancer"] ? UserEntity.fromJS(_data["freelancer"]) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.comment = _data["comment"];
            this.clientComment = _data["clientComment"];
            this.submittedAt = _data["submittedAt"] ? new Date(_data["submittedAt"].toString()) : <any>undefined;
            this.approvedAt = _data["approvedAt"] ? new Date(_data["approvedAt"].toString()) : <any>undefined;
            this.rejectedAt = _data["rejectedAt"] ? new Date(_data["rejectedAt"].toString()) : <any>undefined;
            this.status = _data["status"];
            (<any>this).autoApproved = _data["autoApproved"];
        }
    }

    static fromJS(data: any): WorkSessionEntity {
        data = typeof data === 'object' ? data : {};
        let result = new WorkSessionEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["contractId"] = this.contractId;
        data["contract"] = this.contract ? this.contract.toJSON() : <any>undefined;
        data["freelancerId"] = this.freelancerId;
        data["freelancer"] = this.freelancer ? this.freelancer.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["clientComment"] = this.clientComment;
        data["submittedAt"] = this.submittedAt ? this.submittedAt.toISOString() : <any>undefined;
        data["approvedAt"] = this.approvedAt ? this.approvedAt.toISOString() : <any>undefined;
        data["rejectedAt"] = this.rejectedAt ? this.rejectedAt.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["autoApproved"] = this.autoApproved;
        return data;
    }
}

export interface IWorkSessionEntity {
    id: string;
    createdById?: string | undefined;
    createdAt?: Date | undefined;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    files?: FileEntity[] | undefined;
    contractId?: string;
    contract?: ContractEntity;
    freelancerId?: string;
    freelancer?: UserEntity;
    startDate?: Date;
    endDate?: Date | undefined;
    comment?: string | undefined;
    clientComment?: string | undefined;
    submittedAt?: Date | undefined;
    approvedAt?: Date | undefined;
    rejectedAt?: Date | undefined;
    status?: WorkSessionEntityStatus;
    autoApproved?: boolean;
}

export enum BalanceOperationCommandBalanceOperationType {
    Freeze = "Freeze",
    Unfreeze = "Unfreeze",
    PendingIncome = "PendingIncome",
    Deposit = "Deposit",
    Withdrawl = "Withdrawl",
}

export enum BlockWalletCommandReason {
    None = "None",
    FraudSuspicion = "FraudSuspicion",
    LegalIssue = "LegalIssue",
    UserRequest = "UserRequest",
}

export enum CommandResultStatus {
    _100 = 100,
    _101 = 101,
    _102 = 102,
    _103 = 103,
    _200 = 200,
    _201 = 201,
    _202 = 202,
    _203 = 203,
    _204 = 204,
    _205 = 205,
    _206 = 206,
    _207 = 207,
    _208 = 208,
    _226 = 226,
    _300 = 300,
    _301 = 301,
    _302 = 302,
    _303 = 303,
    _304 = 304,
    _305 = 305,
    _306 = 306,
    _307 = 307,
    _308 = 308,
    _400 = 400,
    _401 = 401,
    _402 = 402,
    _403 = 403,
    _404 = 404,
    _405 = 405,
    _406 = 406,
    _407 = 407,
    _408 = 408,
    _409 = 409,
    _410 = 410,
    _411 = 411,
    _412 = 412,
    _413 = 413,
    _414 = 414,
    _415 = 415,
    _416 = 416,
    _417 = 417,
    _421 = 421,
    _422 = 422,
    _423 = 423,
    _424 = 424,
    _426 = 426,
    _428 = 428,
    _429 = 429,
    _431 = 431,
    _451 = 451,
    _500 = 500,
    _501 = 501,
    _502 = 502,
    _503 = 503,
    _504 = 504,
    _505 = 505,
    _506 = 506,
    _507 = 507,
    _508 = 508,
    _510 = 510,
    _511 = 511,
}

export enum ContestEntityStatus {
    Draft = "Draft",
    Moderation = "Moderation",
    Approved = "Approved",
    Open = "Open",
    Ended = "Ended",
    WinnerSelected = "WinnerSelected",
}

export enum ContractEntityStatus {
    PendingApproval = "PendingApproval",
    Active = "Active",
    Paused = "Paused",
    Completed = "Completed",
    Disputed = "Disputed",
    Cancelled = "Cancelled",
    Expired = "Expired",
    Closed = "Closed",
    PendingFinishApproval = "PendingFinishApproval",
}

export enum ContractEntityBudgetType {
    Hourly = "Hourly",
    Fixed = "Fixed",
}

export enum ContractEntityPaymentSchedule {
    Milestone = "Milestone",
    Weekly = "Weekly",
    Monthly = "Monthly",
    OnCompletion = "OnCompletion",
}

export enum CreateClientProfileCommandEmployerType {
    Company = "Company",
    Indivdual = "Indivdual",
}

export enum CreateContractCommandBudgetType {
    Hourly = "Hourly",
    Fixed = "Fixed",
}

export enum CreateContractCommandPaymentSchedule {
    Milestone = "Milestone",
    Weekly = "Weekly",
    Monthly = "Monthly",
    OnCompletion = "OnCompletion",
}

export enum CreateJobCommandBudgetType {
    Hourly = "Hourly",
    Fixed = "Fixed",
}

export enum CreateJobCommandLevel {
    Beginner = "Beginner",
    Intermediate = "Intermediate",
    Expert = "Expert",
}

export enum CreateNotificationCommandRole {
    User = "User",
    Moderator = "Moderator",
    Admin = "Admin",
    Superadmin = "Superadmin",
}

export enum CreateNotificationCommandType {
    Freelancer = "Freelancer",
    Client = "Client",
    Other = "Other",
    NonUser = "NonUser",
    Staff = "Staff",
}

export enum FreelancerProfileEntityAvailability {
    Open = "Open",
    Busy = "Busy",
    Vacation = "Vacation",
}

export enum GatewayResultCommandCurrency {
    RussianRuble = "RussianRuble",
    Dollar = "Dollar",
    Euro = "Euro",
}

export enum Levels {
    Beginner = "Beginner",
    Intermediate = "Intermediate",
    Expert = "Expert",
}

export enum GetJobsListQueryEmployerLocation {
    Kazakhstan = "Kazakhstan",
    Russia = "Russia",
    Belarus = "Belarus",
}

export enum Statuses {
    Open = "Open",
    Expired = "Expired",
    Closed = "Closed",
    Accepted = "Accepted",
    InContract = "InContract",
    Draft = "Draft",
    Completed = "Completed",
    WaitingFreelancerApproval = "WaitingFreelancerApproval",
}

export enum GetJobsListQuerySortType {
    Ascending = "Ascending",
    Descending = "Descending",
    Default = "Default",
    Recommended = "Recommended",
}

export enum GetJobsListQuerySortOption {
    Date = "Date",
    Recomended = "Recomended",
}

export enum JobDetailsStatus {
    Open = "Open",
    Expired = "Expired",
    Closed = "Closed",
    Accepted = "Accepted",
    InContract = "InContract",
    Draft = "Draft",
    Completed = "Completed",
    WaitingFreelancerApproval = "WaitingFreelancerApproval",
}

export enum JobDetailsCurrency {
    RussianRuble = "RussianRuble",
    Dollar = "Dollar",
    Euro = "Euro",
}

export enum JobEntityStatus {
    Open = "Open",
    Expired = "Expired",
    Closed = "Closed",
    Accepted = "Accepted",
    InContract = "InContract",
    Draft = "Draft",
    Completed = "Completed",
    WaitingFreelancerApproval = "WaitingFreelancerApproval",
}

export enum JobEntityLevel {
    Beginner = "Beginner",
    Intermediate = "Intermediate",
    Expert = "Expert",
}

export enum JobEntityBudgetType {
    Hourly = "Hourly",
    Fixed = "Fixed",
}

export enum MoneyCurrency {
    RussianRuble = "RussianRuble",
    Dollar = "Dollar",
    Euro = "Euro",
}

export enum NotificationEntityType {
    System = "System",
    Payment = "Payment",
    Other = "Other",
}

export enum ProposalEntityStatus {
    Pending = "Pending",
    Accepted = "Accepted",
    Hidden = "Hidden",
}

export enum RegisterUserSchemaCountry {
    Kazakhstan = "Kazakhstan",
    Russia = "Russia",
    Belarus = "Belarus",
}

export enum RegisterUserSchemaType {
    Freelancer = "Freelancer",
    Client = "Client",
    Other = "Other",
    NonUser = "NonUser",
    Staff = "Staff",
}

export enum ResolveDisputeCommandStrategy {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum StartPaymentFlowCommandFlow {
    Incoming = "Incoming",
    Outgoing = "Outgoing",
    Internal = "Internal",
}

export enum StartPaymentFlowCommandType {
    Deposit = "Deposit",
    Withdrawal = "Withdrawal",
    Transfer = "Transfer",
    Refund = "Refund",
    SystemAdjustment = "SystemAdjustment",
    Bonus = "Bonus",
    Penalty = "Penalty",
}

export enum TicketEntityStatus {
    Open = "Open",
    Closed = "Closed",
    InProgress = "InProgress",
}

export enum TransactionEntityStatus {
    Pending = "Pending",
    Processing = "Processing",
    Completed = "Completed",
    Failed = "Failed",
    Cancelled = "Cancelled",
    Expired = "Expired",
    Reversed = "Reversed",
}

export enum TransactionEntityType {
    Deposit = "Deposit",
    Withdrawal = "Withdrawal",
    Transfer = "Transfer",
    Refund = "Refund",
    SystemAdjustment = "SystemAdjustment",
    Bonus = "Bonus",
    Penalty = "Penalty",
}

export enum TransactionEntityFlow {
    Incoming = "Incoming",
    Outgoing = "Outgoing",
    Internal = "Internal",
}

export enum UpdateClientProfileCommandEmployerType {
    Company = "Company",
    Indivdual = "Indivdual",
}

export enum UpdateFreelancerProfileCommandAvailability {
    Open = "Open",
    Busy = "Busy",
    Vacation = "Vacation",
}

export enum UpdateUserCommandRole {
    User = "User",
    Moderator = "Moderator",
    Admin = "Admin",
    Superadmin = "Superadmin",
}

export enum UserEntityRole {
    User = "User",
    Moderator = "Moderator",
    Admin = "Admin",
    Superadmin = "Superadmin",
}

export enum UserEntityType {
    Freelancer = "Freelancer",
    Client = "Client",
    Other = "Other",
    NonUser = "NonUser",
    Staff = "Staff",
}

export enum UserEntityLocation {
    Kazakhstan = "Kazakhstan",
    Russia = "Russia",
    Belarus = "Belarus",
}

export enum WalletEntityCurrency {
    RussianRuble = "RussianRuble",
    Dollar = "Dollar",
    Euro = "Euro",
}

export enum WalletEntityBlockReason {
    None = "None",
    FraudSuspicion = "FraudSuspicion",
    LegalIssue = "LegalIssue",
    UserRequest = "UserRequest",
}

export enum WorkSessionEntityStatus {
    Pending = "Pending",
    Approved = "Approved",
    Rejected = "Rejected",
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}