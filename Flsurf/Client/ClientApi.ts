//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.3.0.0 (NJsonSchema v11.2.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface IClient {

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body?: LoginUserSchema | undefined): Promise<CommandResult>;

    /**
     * @return OK
     */
    logout(): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    register(body?: RegisterUserSchema | undefined): Promise<CommandResult>;

    /**
     * @return OK
     */
    externalLogin(provider: string): Promise<void>;

    /**
     * @return OK
     */
    externalLoginCallback(): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    sendResetPasswordCode(body?: SendResetCodeCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    resetPassword(body?: ResetPasswordCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createCategory(body?: CreateCategoryCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updateCategory(body?: UpdateCategoryCommand | undefined): Promise<CommandResult>;

    /**
     * @return OK
     */
    deleteCategory(categoryId: string): Promise<CommandResult>;

    /**
     * @param searchQuery (optional) 
     * @return OK
     */
    getCategories(searchQuery?: string | undefined): Promise<CategoryEntity[]>;

    /**
     * @return OK
     */
    getChats(): Promise<ChatEntity[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createChat(body?: CreateChatDto | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    closeChat(body?: CloseChatDto | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    bookmarkChat(body?: BookmarkChatDto | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updateChat(body?: UpdateChatDto | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    markAsRead(body?: MarkAsReadDto | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    inviteMember(body?: InviteMemberDto | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    kickMember(body?: KickMemberDto | undefined): Promise<CommandResult>;

    /**
     * @return OK
     */
    getChat(chatId: string): Promise<ChatEntity>;

    /**
     * @return OK
     */
    getChatUnreadCounter(chatId: string): Promise<number>;

    /**
     * @return OK
     */
    getUnreadCounter(): Promise<number>;

    /**
     * @return OK
     */
    getClientOrderInfo(userId: string): Promise<ClientJobInfo>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createClientProfile(body?: CreateClientProfileCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    suspendClientProfile(body?: SuspendClientProfileCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updateClientProfile(body?: UpdateClientProfileCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createContest(body?: CreateContestCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    approveContest(body?: ApproveContestCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    startContest(body?: StartContestCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    endContest(body?: EndContestCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteContest(body?: DeleteContestCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    selectContestWinner(body?: SelectContestWinnerCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    submitContestEntry(body?: SubmitContestEntryCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteContestEntry(body?: DeleteContestEntryCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updateContest(body?: UpdateContestCommand | undefined): Promise<CommandResult>;

    /**
     * @return OK
     */
    getContest(id: string): Promise<ContestEntity>;

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return OK
     */
    getContestList(start?: number | undefined, end?: number | undefined): Promise<ContestEntity[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createContract(body?: CreateContractCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    clientAcceptFinishContract(body?: ClientAcceptFinishContractCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    clientCloseContract(body?: ClientCloseContractCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    clientRejectContractCompletion(body?: ClientRejectContractCompletionCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    freelancerAcceptContract(body?: FreelancerAcceptContractCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    freelancerFinishContract(body?: FreelancerFinishContractCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    acceptDispute(body?: AcceptDisputeCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    initiateDispute(body?: InitiateDisputeCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    resolveDispute(body?: ResolveDisputeCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    forceContractCancel(body?: ForceContractCancelCommand | undefined): Promise<CommandResult>;

    /**
     * @return OK
     */
    getContract(id: string): Promise<ContractEntity>;

    /**
     * @param body (optional) 
     * @return OK
     */
    getContractsList(body?: GetContractsListQuery | undefined): Promise<ContractEntity[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    addBonusToContract(body?: AddBonusToContractCommand | undefined): Promise<CommandResult>;

    /**
     * @return OK
     */
    getBonuses(contractId: string): Promise<BonusEntity[]>;

    /**
     * @param file (optional) 
     * @return OK
     */
    uploadFile(file?: FileParameter | undefined): Promise<FileEntity>;

    /**
     * @return OK
     */
    downloadFile(fileId: string): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createFreelancerProfile(body?: CreateFreelancerProfileCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updateFreelancerProfile(body?: UpdateFreelancerProfileCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    hideFreelancerProfile(body?: HideFreelancerProfileCommand | undefined): Promise<CommandResult>;

    /**
     * @return OK
     */
    getFreelancerProfile(userId: string): Promise<FreelancerProfileEntity>;

    /**
     * @return OK
     */
    getMyFreelancerStats(): Promise<FreelancerStatsDto>;

    /**
     * @return OK
     */
    getFreelancerStats(userId: string): Promise<FreelancerStatsDto>;

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @param skills (optional) 
     * @param minCost (optional) 
     * @param maxCost (optional) 
     * @param minReviews (optional) 
     * @param maxReviews (optional) 
     * @return OK
     */
    getFreelancerProfileList(start?: number | undefined, end?: number | undefined, skills?: string[] | undefined, minCost?: number | undefined, maxCost?: number | undefined, minReviews?: number | undefined, maxReviews?: number | undefined): Promise<FreelancerProfileEntity[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createFreelancerTeam(body?: CreateFreelancerTeamCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updateFreelancerTeam(body?: UpdateFreelancerTeamCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteFreelancerTeam(body?: DeleteFreelancerTeamCommand | undefined): Promise<CommandResult>;

    /**
     * @return OK
     */
    getFreelancerTeams(): Promise<FreelancerTeamEntity[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createJob(body?: CreateJobCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    reactToSentJob(body?: ReactToSentJobCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    sentDraftToMod(body?: SendDraftJobToModerationCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updateJob(body?: UpdateJobCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteJob(body?: DeleteJobCommand | undefined): Promise<CommandResult>;

    /**
     * @return OK
     */
    getJob(id: string): Promise<JobDetails>;

    /**
     * @return OK
     */
    getRawJob(id: string): Promise<JobEntity>;

    /**
     * @param body (optional) 
     * @return OK
     */
    getJobsList(body?: GetJobsListQuery | undefined): Promise<JobEntity[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    bookmarkJob(body?: BookmarkJobCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    hideJob(body?: HideJobCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    submitProposal(body?: SubmitProposalCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updateProposal(body?: UpdateProposalCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    withdrawProposal(body?: WithdrawProposalCommand | undefined): Promise<CommandResult>;

    /**
     * @param start (optional) 
     * @param ends (optional) 
     * @return OK
     */
    getBookmarksList(start?: number | undefined, ends?: number | undefined): Promise<BookmarkedJobEntity[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    reactToProposal(body?: ReactToProposalCommand | undefined): Promise<CommandResult>;

    /**
     * @param jobId (optional) 
     * @param status (optional) 
     * @return OK
     */
    getProposalsList(jobId?: string | undefined, status?: Status | undefined): Promise<ProposalEntity[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    startChatWithFreelancer(body?: StartChatWithFreelancerCommand | undefined): Promise<CommandResult>;

    /**
     * @param starts (optional) 
     * @param ends (optional) 
     * @return OK
     */
    getMessages(chatId: string, starts?: number | undefined, ends?: number | undefined): Promise<MessageEntity[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    sendMessage(body?: SendMessageDto | undefined): Promise<MessageEntity>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updateMessage(body?: UpdateMessageDto | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteMessage(body?: DeleteMessageDto | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    pinMessage(body?: PinMessageDto | undefined): Promise<boolean>;

    /**
     * @return OK
     */
    getThreadMessages(messageId: string): Promise<MessageThreadDto[]>;

    /**
     * @param start (optional) 
     * @param ends (optional) 
     * @return OK
     */
    getNotifications(userId: string, start?: number | undefined, ends?: number | undefined): Promise<NotificationEntity[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createNotification(body?: CreateNotificationCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    hideNotifications(body?: HideNotificationsCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createPortfolioProject(body?: AddPortfolioProjectCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updatePortfolioProject(body?: UpdatePortfolioProjectCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    deletePortfolioProject(body?: DeletePortfolioProjectCommand | undefined): Promise<CommandResult>;

    /**
     * @return OK
     */
    getPortfolioProjects(userId: string): Promise<PortfolioProjectEntity[]>;

    /**
     * @return OK
     */
    getMyPortfolioProjects(): Promise<PortfolioProjectEntity[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    getUserFinancesSummary(body?: GetFinanceSummaryQuery | undefined): Promise<FinanceSummaryDto>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createSkills(body?: CreateSkillsCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updateSkills(body?: UpdateSkillsCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteSkills(body?: DeleteSkillsCommand | undefined): Promise<CommandResult>;

    /**
     * @param searchQuery (optional) 
     * @return OK
     */
    getSkills(searchQuery?: string | undefined): Promise<SkillModel[]>;

    /**
     * @return OK
     */
    blockUser(userId: string): Promise<boolean>;

    /**
     * @param body (optional) 
     * @return OK
     */
    warnUser(userId: string, body?: WarnUserScheme | undefined): Promise<boolean>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createTicket(body?: CreateTicketDto | undefined): Promise<TicketEntity>;

    /**
     * @param body (optional) 
     * @return OK
     */
    getTickets(body?: GetTicketsDto | undefined): Promise<TicketEntity[]>;

    /**
     * @return OK
     */
    getTicket(ticketId: string): Promise<TicketEntity>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createNews(body?: CreateNewsDto | undefined): Promise<NewsEntity>;

    /**
     * @param start (optional) 
     * @param ends (optional) 
     * @param includeHidden (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param changeNotes (optional) 
     * @return OK
     */
    getNewsList(start?: number | undefined, ends?: number | undefined, includeHidden?: boolean | undefined, startDate?: Date | undefined, endDate?: Date | undefined, changeNotes?: boolean | undefined): Promise<NewsEntity[]>;

    /**
     * @return OK
     */
    getNewsById(newsId: string): Promise<NewsEntity>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updateNews(newsId: string, body?: UpdateNewsDto | undefined): Promise<NewsEntity>;

    /**
     * @return No Content
     */
    deleteNews(newsId: string): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createTask(body?: CreateTaskCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    completeTask(body?: CompleteTaskCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    reactToTask(body?: ReactToTaskCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updateTask(body?: UpdateTaskCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteTask(body?: DeleteTaskCommand | undefined): Promise<CommandResult>;

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return OK
     */
    getTasks(contractId: string, start?: number | undefined, end?: number | undefined): Promise<TransactionEntity[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    handleTransaction(body?: HandleTransactionCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    getTransactionsList(body?: GetTransactionsListQuery | undefined): Promise<TransactionEntity[]>;

    /**
     * @return OK
     */
    getTransactionProviders(): Promise<TransactionProviderEntity[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    handleGatewayWebhook(body?: GatewayResultCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    refundTransaction(body?: RefundTransactionCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    startPaymentFlow(body?: StartPaymentFlowCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createSetupIntent(body?: CreateSetupIntentCommand | undefined): Promise<CardSetupDetails>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updateUser(userId: string, body?: UpdateUserCommand | undefined): Promise<boolean>;

    /**
     * @return OK
     */
    getUserById(userId: string): Promise<UserEntity>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updateMe(body?: UpdateUserCommand | undefined): Promise<boolean>;

    /**
     * @return OK
     */
    getMe(): Promise<UserEntity>;

    /**
     * @param body (optional) 
     * @return OK
     */
    updateTaxInfo(userId: string, body?: UpdateTaxSettingsCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    searchUsers(body?: GetUsersListQuery | undefined): Promise<UserEntity[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    balanceOperation(body?: BalanceOperationCommand | undefined): Promise<CommandResult>;

    /**
     * @return OK
     */
    getWallet(walletId: string): Promise<WalletEntity>;

    /**
     * @return OK
     */
    getMyWallet(): Promise<WalletEntity>;

    /**
     * @param body (optional) 
     * @return OK
     */
    blockWallet(body?: BlockWalletCommand | undefined): Promise<CommandResult>;

    /**
     * @return OK
     */
    getPaymentMethods(): Promise<PaymentMethodDto[]>;

    /**
     * @return OK
     */
    getPaymentMethodsByUser(userId: string): Promise<PaymentMethodDto[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    addPaymentMethod(body?: AddPaymentMethodCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    startSession(body?: StartWorkSessionCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    submitSession(body?: SubmitWorkSessionCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    endSession(body?: EndWorkSessionCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    approveSession(body?: ApproveWorkSessionCommand | undefined): Promise<CommandResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    reactSession(body?: ReactToWorkSessionCommand | undefined): Promise<CommandResult>;

    /**
     * @return OK
     */
    getSession(id: string): Promise<WorkSessionEntity>;

    /**
     * @param body (optional) 
     * @return OK
     */
    getSessionList(body?: GetWorkSessionListQuery | undefined): Promise<WorkSessionEntity[]>;
}

export class Client implements IClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body?: LoginUserSchema | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return OK
     */
    logout(): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    register(body?: RegisterUserSchema | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return OK
     */
    externalLogin(provider: string): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/external-login/{provider}";
        if (provider === undefined || provider === null)
            throw new Error("The parameter 'provider' must be defined.");
        url_ = url_.replace("{provider}", encodeURIComponent("" + provider));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExternalLogin(_response);
        });
    }

    protected processExternalLogin(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    externalLoginCallback(): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/external-login-callback";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExternalLoginCallback(_response);
        });
    }

    protected processExternalLoginCallback(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    sendResetPasswordCode(body?: SendResetCodeCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/auth/send-reset-code";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendResetPasswordCode(_response);
        });
    }

    protected processSendResetPasswordCode(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    resetPassword(body?: ResetPasswordCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/auth/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createCategory(body?: CreateCategoryCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/category/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCategory(_response);
        });
    }

    protected processCreateCategory(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateCategory(body?: UpdateCategoryCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/category/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCategory(_response);
        });
    }

    protected processUpdateCategory(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return OK
     */
    deleteCategory(categoryId: string): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/category/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCategory(_response);
        });
    }

    protected processDeleteCategory(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param searchQuery (optional) 
     * @return OK
     */
    getCategories(searchQuery?: string | undefined): Promise<CategoryEntity[]> {
        let url_ = this.baseUrl + "/api/category/list?";
        if (searchQuery === null)
            throw new Error("The parameter 'searchQuery' cannot be null.");
        else if (searchQuery !== undefined)
            url_ += "searchQuery=" + encodeURIComponent("" + searchQuery) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCategories(_response);
        });
    }

    protected processGetCategories(response: Response): Promise<CategoryEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CategoryEntity[]>(null as any);
    }

    /**
     * @return OK
     */
    getChats(): Promise<ChatEntity[]> {
        let url_ = this.baseUrl + "/api/chat/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetChats(_response);
        });
    }

    protected processGetChats(response: Response): Promise<ChatEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChatEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChatEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createChat(body?: CreateChatDto | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/chat/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateChat(_response);
        });
    }

    protected processCreateChat(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    closeChat(body?: CloseChatDto | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/chat/close";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCloseChat(_response);
        });
    }

    protected processCloseChat(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    bookmarkChat(body?: BookmarkChatDto | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/chat/bookmark";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBookmarkChat(_response);
        });
    }

    protected processBookmarkChat(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateChat(body?: UpdateChatDto | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/chat/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateChat(_response);
        });
    }

    protected processUpdateChat(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    markAsRead(body?: MarkAsReadDto | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/chat/mark-as-read";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMarkAsRead(_response);
        });
    }

    protected processMarkAsRead(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    inviteMember(body?: InviteMemberDto | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/chat/invite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInviteMember(_response);
        });
    }

    protected processInviteMember(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    kickMember(body?: KickMemberDto | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/chat/kick";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKickMember(_response);
        });
    }

    protected processKickMember(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return OK
     */
    getChat(chatId: string): Promise<ChatEntity> {
        let url_ = this.baseUrl + "/api/chat/{chatId}";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined.");
        url_ = url_.replace("{chatId}", encodeURIComponent("" + chatId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetChat(_response);
        });
    }

    protected processGetChat(response: Response): Promise<ChatEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChatEntity>(null as any);
    }

    /**
     * @return OK
     */
    getChatUnreadCounter(chatId: string): Promise<number> {
        let url_ = this.baseUrl + "/api/chat/{chatId}/unread";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined.");
        url_ = url_.replace("{chatId}", encodeURIComponent("" + chatId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetChatUnreadCounter(_response);
        });
    }

    protected processGetChatUnreadCounter(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @return OK
     */
    getUnreadCounter(): Promise<number> {
        let url_ = this.baseUrl + "/api/chat/unread";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUnreadCounter(_response);
        });
    }

    protected processGetUnreadCounter(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @return OK
     */
    getClientOrderInfo(userId: string): Promise<ClientJobInfo> {
        let url_ = this.baseUrl + "/api/client-profile/order-info/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetClientOrderInfo(_response);
        });
    }

    protected processGetClientOrderInfo(response: Response): Promise<ClientJobInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientJobInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientJobInfo>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createClientProfile(body?: CreateClientProfileCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/client-profile/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateClientProfile(_response);
        });
    }

    protected processCreateClientProfile(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    suspendClientProfile(body?: SuspendClientProfileCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/client-profile/suspend";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSuspendClientProfile(_response);
        });
    }

    protected processSuspendClientProfile(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateClientProfile(body?: UpdateClientProfileCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/client-profile/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateClientProfile(_response);
        });
    }

    protected processUpdateClientProfile(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createContest(body?: CreateContestCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateContest(_response);
        });
    }

    protected processCreateContest(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    approveContest(body?: ApproveContestCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApproveContest(_response);
        });
    }

    protected processApproveContest(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    startContest(body?: StartContestCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/start";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartContest(_response);
        });
    }

    protected processStartContest(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    endContest(body?: EndContestCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/end";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEndContest(_response);
        });
    }

    protected processEndContest(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteContest(body?: DeleteContestCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteContest(_response);
        });
    }

    protected processDeleteContest(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    selectContestWinner(body?: SelectContestWinnerCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/select-winner";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSelectContestWinner(_response);
        });
    }

    protected processSelectContestWinner(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    submitContestEntry(body?: SubmitContestEntryCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/submit-entry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubmitContestEntry(_response);
        });
    }

    protected processSubmitContestEntry(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteContestEntry(body?: DeleteContestEntryCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/delete-entry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteContestEntry(_response);
        });
    }

    protected processDeleteContestEntry(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateContest(body?: UpdateContestCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contest/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateContest(_response);
        });
    }

    protected processUpdateContest(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return OK
     */
    getContest(id: string): Promise<ContestEntity> {
        let url_ = this.baseUrl + "/api/contest/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContest(_response);
        });
    }

    protected processGetContest(response: Response): Promise<ContestEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContestEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContestEntity>(null as any);
    }

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return OK
     */
    getContestList(start?: number | undefined, end?: number | undefined): Promise<ContestEntity[]> {
        let url_ = this.baseUrl + "/api/contest/list?";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent("" + end) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContestList(_response);
        });
    }

    protected processGetContestList(response: Response): Promise<ContestEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContestEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContestEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createContract(body?: CreateContractCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateContract(_response);
        });
    }

    protected processCreateContract(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    clientAcceptFinishContract(body?: ClientAcceptFinishContractCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/client-accept-finish";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClientAcceptFinishContract(_response);
        });
    }

    protected processClientAcceptFinishContract(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    clientCloseContract(body?: ClientCloseContractCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/client-close";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClientCloseContract(_response);
        });
    }

    protected processClientCloseContract(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    clientRejectContractCompletion(body?: ClientRejectContractCompletionCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/client-reject-completion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClientRejectContractCompletion(_response);
        });
    }

    protected processClientRejectContractCompletion(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    freelancerAcceptContract(body?: FreelancerAcceptContractCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/freelancer-accept";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFreelancerAcceptContract(_response);
        });
    }

    protected processFreelancerAcceptContract(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    freelancerFinishContract(body?: FreelancerFinishContractCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/freelancer-finish";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFreelancerFinishContract(_response);
        });
    }

    protected processFreelancerFinishContract(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    acceptDispute(body?: AcceptDisputeCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/accept-dispute";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAcceptDispute(_response);
        });
    }

    protected processAcceptDispute(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    initiateDispute(body?: InitiateDisputeCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/initiate-dispute";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInitiateDispute(_response);
        });
    }

    protected processInitiateDispute(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    resolveDispute(body?: ResolveDisputeCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/resolve-dispute";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResolveDispute(_response);
        });
    }

    protected processResolveDispute(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    forceContractCancel(body?: ForceContractCancelCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/force-cancel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForceContractCancel(_response);
        });
    }

    protected processForceContractCancel(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return OK
     */
    getContract(id: string): Promise<ContractEntity> {
        let url_ = this.baseUrl + "/api/contract/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContract(_response);
        });
    }

    protected processGetContract(response: Response): Promise<ContractEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractEntity>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getContractsList(body?: GetContractsListQuery | undefined): Promise<ContractEntity[]> {
        let url_ = this.baseUrl + "/api/contract/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContractsList(_response);
        });
    }

    protected processGetContractsList(response: Response): Promise<ContractEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContractEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addBonusToContract(body?: AddBonusToContractCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/contract/bonus/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddBonusToContract(_response);
        });
    }

    protected processAddBonusToContract(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return OK
     */
    getBonuses(contractId: string): Promise<BonusEntity[]> {
        let url_ = this.baseUrl + "/api/contract/{contractId}/bonuses";
        if (contractId === undefined || contractId === null)
            throw new Error("The parameter 'contractId' must be defined.");
        url_ = url_.replace("{contractId}", encodeURIComponent("" + contractId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBonuses(_response);
        });
    }

    protected processGetBonuses(response: Response): Promise<BonusEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BonusEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BonusEntity[]>(null as any);
    }

    /**
     * @param file (optional) 
     * @return OK
     */
    uploadFile(file?: FileParameter | undefined): Promise<FileEntity> {
        let url_ = this.baseUrl + "/api/files/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadFile(_response);
        });
    }

    protected processUploadFile(response: Response): Promise<FileEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileEntity>(null as any);
    }

    /**
     * @return OK
     */
    downloadFile(fileId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/files/download/{fileId}";
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownloadFile(_response);
        });
    }

    protected processDownloadFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createFreelancerProfile(body?: CreateFreelancerProfileCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/freelancer-profile/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateFreelancerProfile(_response);
        });
    }

    protected processCreateFreelancerProfile(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateFreelancerProfile(body?: UpdateFreelancerProfileCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/freelancer-profile/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateFreelancerProfile(_response);
        });
    }

    protected processUpdateFreelancerProfile(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    hideFreelancerProfile(body?: HideFreelancerProfileCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/freelancer-profile/hide";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHideFreelancerProfile(_response);
        });
    }

    protected processHideFreelancerProfile(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return OK
     */
    getFreelancerProfile(userId: string): Promise<FreelancerProfileEntity> {
        let url_ = this.baseUrl + "/api/freelancer-profile/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFreelancerProfile(_response);
        });
    }

    protected processGetFreelancerProfile(response: Response): Promise<FreelancerProfileEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FreelancerProfileEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FreelancerProfileEntity>(null as any);
    }

    /**
     * @return OK
     */
    getMyFreelancerStats(): Promise<FreelancerStatsDto> {
        let url_ = this.baseUrl + "/api/freelancer-profile/stats";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMyFreelancerStats(_response);
        });
    }

    protected processGetMyFreelancerStats(response: Response): Promise<FreelancerStatsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FreelancerStatsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FreelancerStatsDto>(null as any);
    }

    /**
     * @return OK
     */
    getFreelancerStats(userId: string): Promise<FreelancerStatsDto> {
        let url_ = this.baseUrl + "/api/freelancer-profile/{userId}/stats";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFreelancerStats(_response);
        });
    }

    protected processGetFreelancerStats(response: Response): Promise<FreelancerStatsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FreelancerStatsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FreelancerStatsDto>(null as any);
    }

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @param skills (optional) 
     * @param minCost (optional) 
     * @param maxCost (optional) 
     * @param minReviews (optional) 
     * @param maxReviews (optional) 
     * @return OK
     */
    getFreelancerProfileList(start?: number | undefined, end?: number | undefined, skills?: string[] | undefined, minCost?: number | undefined, maxCost?: number | undefined, minReviews?: number | undefined, maxReviews?: number | undefined): Promise<FreelancerProfileEntity[]> {
        let url_ = this.baseUrl + "/api/freelancer-profile/list?";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent("" + end) + "&";
        if (skills === null)
            throw new Error("The parameter 'skills' cannot be null.");
        else if (skills !== undefined)
            skills && skills.forEach(item => { url_ += "skills=" + encodeURIComponent("" + item) + "&"; });
        if (minCost === null)
            throw new Error("The parameter 'minCost' cannot be null.");
        else if (minCost !== undefined)
            url_ += "minCost=" + encodeURIComponent("" + minCost) + "&";
        if (maxCost === null)
            throw new Error("The parameter 'maxCost' cannot be null.");
        else if (maxCost !== undefined)
            url_ += "maxCost=" + encodeURIComponent("" + maxCost) + "&";
        if (minReviews === null)
            throw new Error("The parameter 'minReviews' cannot be null.");
        else if (minReviews !== undefined)
            url_ += "minReviews=" + encodeURIComponent("" + minReviews) + "&";
        if (maxReviews === null)
            throw new Error("The parameter 'maxReviews' cannot be null.");
        else if (maxReviews !== undefined)
            url_ += "maxReviews=" + encodeURIComponent("" + maxReviews) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFreelancerProfileList(_response);
        });
    }

    protected processGetFreelancerProfileList(response: Response): Promise<FreelancerProfileEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FreelancerProfileEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FreelancerProfileEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createFreelancerTeam(body?: CreateFreelancerTeamCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/freelancer-team/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateFreelancerTeam(_response);
        });
    }

    protected processCreateFreelancerTeam(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateFreelancerTeam(body?: UpdateFreelancerTeamCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/freelancer-team/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateFreelancerTeam(_response);
        });
    }

    protected processUpdateFreelancerTeam(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteFreelancerTeam(body?: DeleteFreelancerTeamCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/freelancer-team/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteFreelancerTeam(_response);
        });
    }

    protected processDeleteFreelancerTeam(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return OK
     */
    getFreelancerTeams(): Promise<FreelancerTeamEntity[]> {
        let url_ = this.baseUrl + "/api/freelancer-team/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFreelancerTeams(_response);
        });
    }

    protected processGetFreelancerTeams(response: Response): Promise<FreelancerTeamEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FreelancerTeamEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FreelancerTeamEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createJob(body?: CreateJobCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateJob(_response);
        });
    }

    protected processCreateJob(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    reactToSentJob(body?: ReactToSentJobCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/react-sent-job";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReactToSentJob(_response);
        });
    }

    protected processReactToSentJob(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    sentDraftToMod(body?: SendDraftJobToModerationCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/sent-draft-to-mod";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSentDraftToMod(_response);
        });
    }

    protected processSentDraftToMod(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateJob(body?: UpdateJobCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateJob(_response);
        });
    }

    protected processUpdateJob(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteJob(body?: DeleteJobCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteJob(_response);
        });
    }

    protected processDeleteJob(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return OK
     */
    getJob(id: string): Promise<JobDetails> {
        let url_ = this.baseUrl + "/api/job/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetJob(_response);
        });
    }

    protected processGetJob(response: Response): Promise<JobDetails> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobDetails.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JobDetails>(null as any);
    }

    /**
     * @return OK
     */
    getRawJob(id: string): Promise<JobEntity> {
        let url_ = this.baseUrl + "/api/job/{id}/raw";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRawJob(_response);
        });
    }

    protected processGetRawJob(response: Response): Promise<JobEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JobEntity>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getJobsList(body?: GetJobsListQuery | undefined): Promise<JobEntity[]> {
        let url_ = this.baseUrl + "/api/job/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetJobsList(_response);
        });
    }

    protected processGetJobsList(response: Response): Promise<JobEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JobEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JobEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    bookmarkJob(body?: BookmarkJobCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/bookmark";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBookmarkJob(_response);
        });
    }

    protected processBookmarkJob(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    hideJob(body?: HideJobCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/hide";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHideJob(_response);
        });
    }

    protected processHideJob(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    submitProposal(body?: SubmitProposalCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/submit-proposal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubmitProposal(_response);
        });
    }

    protected processSubmitProposal(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateProposal(body?: UpdateProposalCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/update-proposal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProposal(_response);
        });
    }

    protected processUpdateProposal(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    withdrawProposal(body?: WithdrawProposalCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/withdraw-proposal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWithdrawProposal(_response);
        });
    }

    protected processWithdrawProposal(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param start (optional) 
     * @param ends (optional) 
     * @return OK
     */
    getBookmarksList(start?: number | undefined, ends?: number | undefined): Promise<BookmarkedJobEntity[]> {
        let url_ = this.baseUrl + "/api/job/bookmarks?";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "Start=" + encodeURIComponent("" + start) + "&";
        if (ends === null)
            throw new Error("The parameter 'ends' cannot be null.");
        else if (ends !== undefined)
            url_ += "Ends=" + encodeURIComponent("" + ends) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBookmarksList(_response);
        });
    }

    protected processGetBookmarksList(response: Response): Promise<BookmarkedJobEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BookmarkedJobEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BookmarkedJobEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    reactToProposal(body?: ReactToProposalCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/react-to-proposal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReactToProposal(_response);
        });
    }

    protected processReactToProposal(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param jobId (optional) 
     * @param status (optional) 
     * @return OK
     */
    getProposalsList(jobId?: string | undefined, status?: Status | undefined): Promise<ProposalEntity[]> {
        let url_ = this.baseUrl + "/api/job/proposals?";
        if (jobId === null)
            throw new Error("The parameter 'jobId' cannot be null.");
        else if (jobId !== undefined)
            url_ += "JobId=" + encodeURIComponent("" + jobId) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProposalsList(_response);
        });
    }

    protected processGetProposalsList(response: Response): Promise<ProposalEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProposalEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProposalEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    startChatWithFreelancer(body?: StartChatWithFreelancerCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/job/start-chat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartChatWithFreelancer(_response);
        });
    }

    protected processStartChatWithFreelancer(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param starts (optional) 
     * @param ends (optional) 
     * @return OK
     */
    getMessages(chatId: string, starts?: number | undefined, ends?: number | undefined): Promise<MessageEntity[]> {
        let url_ = this.baseUrl + "/api/message/list?";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined and cannot be null.");
        else
            url_ += "ChatId=" + encodeURIComponent("" + chatId) + "&";
        if (starts === null)
            throw new Error("The parameter 'starts' cannot be null.");
        else if (starts !== undefined)
            url_ += "Starts=" + encodeURIComponent("" + starts) + "&";
        if (ends === null)
            throw new Error("The parameter 'ends' cannot be null.");
        else if (ends !== undefined)
            url_ += "Ends=" + encodeURIComponent("" + ends) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMessages(_response);
        });
    }

    protected processGetMessages(response: Response): Promise<MessageEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MessageEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MessageEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    sendMessage(body?: SendMessageDto | undefined): Promise<MessageEntity> {
        let url_ = this.baseUrl + "/api/message/send";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendMessage(_response);
        });
    }

    protected processSendMessage(response: Response): Promise<MessageEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MessageEntity>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateMessage(body?: UpdateMessageDto | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/message/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateMessage(_response);
        });
    }

    protected processUpdateMessage(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteMessage(body?: DeleteMessageDto | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/message/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteMessage(_response);
        });
    }

    protected processDeleteMessage(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    pinMessage(body?: PinMessageDto | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/message/pin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPinMessage(_response);
        });
    }

    protected processPinMessage(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return OK
     */
    getThreadMessages(messageId: string): Promise<MessageThreadDto[]> {
        let url_ = this.baseUrl + "/api/message/{messageId}/thread";
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetThreadMessages(_response);
        });
    }

    protected processGetThreadMessages(response: Response): Promise<MessageThreadDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MessageThreadDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MessageThreadDto[]>(null as any);
    }

    /**
     * @param start (optional) 
     * @param ends (optional) 
     * @return OK
     */
    getNotifications(userId: string, start?: number | undefined, ends?: number | undefined): Promise<NotificationEntity[]> {
        let url_ = this.baseUrl + "/api/notification/user/{userId}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "Start=" + encodeURIComponent("" + start) + "&";
        if (ends === null)
            throw new Error("The parameter 'ends' cannot be null.");
        else if (ends !== undefined)
            url_ += "Ends=" + encodeURIComponent("" + ends) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNotifications(_response);
        });
    }

    protected processGetNotifications(response: Response): Promise<NotificationEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NotificationEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createNotification(body?: CreateNotificationCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/notification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateNotification(_response);
        });
    }

    protected processCreateNotification(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    hideNotifications(body?: HideNotificationsCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/notification/hide";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHideNotifications(_response);
        });
    }

    protected processHideNotifications(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createPortfolioProject(body?: AddPortfolioProjectCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/portfolio-project/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreatePortfolioProject(_response);
        });
    }

    protected processCreatePortfolioProject(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updatePortfolioProject(body?: UpdatePortfolioProjectCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/portfolio-project/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdatePortfolioProject(_response);
        });
    }

    protected processUpdatePortfolioProject(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deletePortfolioProject(body?: DeletePortfolioProjectCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/portfolio-project/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeletePortfolioProject(_response);
        });
    }

    protected processDeletePortfolioProject(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return OK
     */
    getPortfolioProjects(userId: string): Promise<PortfolioProjectEntity[]> {
        let url_ = this.baseUrl + "/api/portfolio-project/list/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPortfolioProjects(_response);
        });
    }

    protected processGetPortfolioProjects(response: Response): Promise<PortfolioProjectEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PortfolioProjectEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PortfolioProjectEntity[]>(null as any);
    }

    /**
     * @return OK
     */
    getMyPortfolioProjects(): Promise<PortfolioProjectEntity[]> {
        let url_ = this.baseUrl + "/api/portfolio-project/list/my";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMyPortfolioProjects(_response);
        });
    }

    protected processGetMyPortfolioProjects(response: Response): Promise<PortfolioProjectEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PortfolioProjectEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PortfolioProjectEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getUserFinancesSummary(body?: GetFinanceSummaryQuery | undefined): Promise<FinanceSummaryDto> {
        let url_ = this.baseUrl + "/finances-summary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserFinancesSummary(_response);
        });
    }

    protected processGetUserFinancesSummary(response: Response): Promise<FinanceSummaryDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FinanceSummaryDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FinanceSummaryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createSkills(body?: CreateSkillsCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/skill/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSkills(_response);
        });
    }

    protected processCreateSkills(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateSkills(body?: UpdateSkillsCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/skill/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSkills(_response);
        });
    }

    protected processUpdateSkills(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteSkills(body?: DeleteSkillsCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/skill/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSkills(_response);
        });
    }

    protected processDeleteSkills(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param searchQuery (optional) 
     * @return OK
     */
    getSkills(searchQuery?: string | undefined): Promise<SkillModel[]> {
        let url_ = this.baseUrl + "/api/skill/list?";
        if (searchQuery === null)
            throw new Error("The parameter 'searchQuery' cannot be null.");
        else if (searchQuery !== undefined)
            url_ += "searchQuery=" + encodeURIComponent("" + searchQuery) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSkills(_response);
        });
    }

    protected processGetSkills(response: Response): Promise<SkillModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SkillModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SkillModel[]>(null as any);
    }

    /**
     * @return OK
     */
    blockUser(userId: string): Promise<boolean> {
        let url_ = this.baseUrl + "/api/stuff/user/{userId}/block";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBlockUser(_response);
        });
    }

    protected processBlockUser(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    warnUser(userId: string, body?: WarnUserScheme | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/stuff/user/{userId}/warn";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWarnUser(_response);
        });
    }

    protected processWarnUser(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createTicket(body?: CreateTicketDto | undefined): Promise<TicketEntity> {
        let url_ = this.baseUrl + "/api/stuff/ticket";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTicket(_response);
        });
    }

    protected processCreateTicket(response: Response): Promise<TicketEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TicketEntity>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getTickets(body?: GetTicketsDto | undefined): Promise<TicketEntity[]> {
        let url_ = this.baseUrl + "/api/stuff/ticket/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTickets(_response);
        });
    }

    protected processGetTickets(response: Response): Promise<TicketEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TicketEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TicketEntity[]>(null as any);
    }

    /**
     * @return OK
     */
    getTicket(ticketId: string): Promise<TicketEntity> {
        let url_ = this.baseUrl + "/api/stuff/ticket/{ticketId}";
        if (ticketId === undefined || ticketId === null)
            throw new Error("The parameter 'ticketId' must be defined.");
        url_ = url_.replace("{ticketId}", encodeURIComponent("" + ticketId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTicket(_response);
        });
    }

    protected processGetTicket(response: Response): Promise<TicketEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TicketEntity>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createNews(body?: CreateNewsDto | undefined): Promise<NewsEntity> {
        let url_ = this.baseUrl + "/api/stuff";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateNews(_response);
        });
    }

    protected processCreateNews(response: Response): Promise<NewsEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NewsEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NewsEntity>(null as any);
    }

    /**
     * @param start (optional) 
     * @param ends (optional) 
     * @param includeHidden (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param changeNotes (optional) 
     * @return OK
     */
    getNewsList(start?: number | undefined, ends?: number | undefined, includeHidden?: boolean | undefined, startDate?: Date | undefined, endDate?: Date | undefined, changeNotes?: boolean | undefined): Promise<NewsEntity[]> {
        let url_ = this.baseUrl + "/api/stuff?";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "Start=" + encodeURIComponent("" + start) + "&";
        if (ends === null)
            throw new Error("The parameter 'ends' cannot be null.");
        else if (ends !== undefined)
            url_ += "Ends=" + encodeURIComponent("" + ends) + "&";
        if (includeHidden === null)
            throw new Error("The parameter 'includeHidden' cannot be null.");
        else if (includeHidden !== undefined)
            url_ += "IncludeHidden=" + encodeURIComponent("" + includeHidden) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (changeNotes === null)
            throw new Error("The parameter 'changeNotes' cannot be null.");
        else if (changeNotes !== undefined)
            url_ += "ChangeNotes=" + encodeURIComponent("" + changeNotes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNewsList(_response);
        });
    }

    protected processGetNewsList(response: Response): Promise<NewsEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NewsEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NewsEntity[]>(null as any);
    }

    /**
     * @return OK
     */
    getNewsById(newsId: string): Promise<NewsEntity> {
        let url_ = this.baseUrl + "/api/stuff/{newsId}";
        if (newsId === undefined || newsId === null)
            throw new Error("The parameter 'newsId' must be defined.");
        url_ = url_.replace("{newsId}", encodeURIComponent("" + newsId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNewsById(_response);
        });
    }

    protected processGetNewsById(response: Response): Promise<NewsEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NewsEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NewsEntity>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateNews(newsId: string, body?: UpdateNewsDto | undefined): Promise<NewsEntity> {
        let url_ = this.baseUrl + "/api/stuff/{newsId}";
        if (newsId === undefined || newsId === null)
            throw new Error("The parameter 'newsId' must be defined.");
        url_ = url_.replace("{newsId}", encodeURIComponent("" + newsId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateNews(_response);
        });
    }

    protected processUpdateNews(response: Response): Promise<NewsEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NewsEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NewsEntity>(null as any);
    }

    /**
     * @return No Content
     */
    deleteNews(newsId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/stuff/{newsId}";
        if (newsId === undefined || newsId === null)
            throw new Error("The parameter 'newsId' must be defined.");
        url_ = url_.replace("{newsId}", encodeURIComponent("" + newsId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteNews(_response);
        });
    }

    protected processDeleteNews(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createTask(body?: CreateTaskCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/task/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTask(_response);
        });
    }

    protected processCreateTask(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    completeTask(body?: CompleteTaskCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/task/complete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompleteTask(_response);
        });
    }

    protected processCompleteTask(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    reactToTask(body?: ReactToTaskCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/task/react";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReactToTask(_response);
        });
    }

    protected processReactToTask(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateTask(body?: UpdateTaskCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/task/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTask(_response);
        });
    }

    protected processUpdateTask(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteTask(body?: DeleteTaskCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/task/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTask(_response);
        });
    }

    protected processDeleteTask(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return OK
     */
    getTasks(contractId: string, start?: number | undefined, end?: number | undefined): Promise<TransactionEntity[]> {
        let url_ = this.baseUrl + "/api/task/list/{contractId}?";
        if (contractId === undefined || contractId === null)
            throw new Error("The parameter 'contractId' must be defined.");
        url_ = url_.replace("{contractId}", encodeURIComponent("" + contractId));
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent("" + end) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTasks(_response);
        });
    }

    protected processGetTasks(response: Response): Promise<TransactionEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TransactionEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransactionEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    handleTransaction(body?: HandleTransactionCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/transaction/handle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHandleTransaction(_response);
        });
    }

    protected processHandleTransaction(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getTransactionsList(body?: GetTransactionsListQuery | undefined): Promise<TransactionEntity[]> {
        let url_ = this.baseUrl + "/api/transaction/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTransactionsList(_response);
        });
    }

    protected processGetTransactionsList(response: Response): Promise<TransactionEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TransactionEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransactionEntity[]>(null as any);
    }

    /**
     * @return OK
     */
    getTransactionProviders(): Promise<TransactionProviderEntity[]> {
        let url_ = this.baseUrl + "/api/transaction/providers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTransactionProviders(_response);
        });
    }

    protected processGetTransactionProviders(response: Response): Promise<TransactionProviderEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TransactionProviderEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransactionProviderEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    handleGatewayWebhook(body?: GatewayResultCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/transaction/gateway-webhook";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHandleGatewayWebhook(_response);
        });
    }

    protected processHandleGatewayWebhook(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    refundTransaction(body?: RefundTransactionCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/transaction/refund";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefundTransaction(_response);
        });
    }

    protected processRefundTransaction(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    startPaymentFlow(body?: StartPaymentFlowCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/transaction/start";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartPaymentFlow(_response);
        });
    }

    protected processStartPaymentFlow(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createSetupIntent(body?: CreateSetupIntentCommand | undefined): Promise<CardSetupDetails> {
        let url_ = this.baseUrl + "/api/transaction/setup-intent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSetupIntent(_response);
        });
    }

    protected processCreateSetupIntent(response: Response): Promise<CardSetupDetails> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CardSetupDetails.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CardSetupDetails>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateUser(userId: string, body?: UpdateUserCommand | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/user/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return OK
     */
    getUserById(userId: string): Promise<UserEntity> {
        let url_ = this.baseUrl + "/api/user/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserById(_response);
        });
    }

    protected processGetUserById(response: Response): Promise<UserEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserEntity>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateMe(body?: UpdateUserCommand | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/user/me";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateMe(_response);
        });
    }

    protected processUpdateMe(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return OK
     */
    getMe(): Promise<UserEntity> {
        let url_ = this.baseUrl + "/api/user/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMe(_response);
        });
    }

    protected processGetMe(response: Response): Promise<UserEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserEntity>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateTaxInfo(userId: string, body?: UpdateTaxSettingsCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/user/{userId}/taxinfo";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTaxInfo(_response);
        });
    }

    protected processUpdateTaxInfo(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    searchUsers(body?: GetUsersListQuery | undefined): Promise<UserEntity[]> {
        let url_ = this.baseUrl + "/api/user/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchUsers(_response);
        });
    }

    protected processSearchUsers(response: Response): Promise<UserEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserEntity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    balanceOperation(body?: BalanceOperationCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/wallet/balance-operation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBalanceOperation(_response);
        });
    }

    protected processBalanceOperation(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return OK
     */
    getWallet(walletId: string): Promise<WalletEntity> {
        let url_ = this.baseUrl + "/api/wallet/{walletId}";
        if (walletId === undefined || walletId === null)
            throw new Error("The parameter 'walletId' must be defined.");
        url_ = url_.replace("{walletId}", encodeURIComponent("" + walletId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWallet(_response);
        });
    }

    protected processGetWallet(response: Response): Promise<WalletEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WalletEntity>(null as any);
    }

    /**
     * @return OK
     */
    getMyWallet(): Promise<WalletEntity> {
        let url_ = this.baseUrl + "/api/wallet/my";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMyWallet(_response);
        });
    }

    protected processGetMyWallet(response: Response): Promise<WalletEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WalletEntity>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    blockWallet(body?: BlockWalletCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/wallet/block";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBlockWallet(_response);
        });
    }

    protected processBlockWallet(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return OK
     */
    getPaymentMethods(): Promise<PaymentMethodDto[]> {
        let url_ = this.baseUrl + "/api/wallet/payment-methods";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPaymentMethods(_response);
        });
    }

    protected processGetPaymentMethods(response: Response): Promise<PaymentMethodDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentMethodDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentMethodDto[]>(null as any);
    }

    /**
     * @return OK
     */
    getPaymentMethodsByUser(userId: string): Promise<PaymentMethodDto[]> {
        let url_ = this.baseUrl + "/api/wallet/payment-methods/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPaymentMethodsByUser(_response);
        });
    }

    protected processGetPaymentMethodsByUser(response: Response): Promise<PaymentMethodDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentMethodDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentMethodDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addPaymentMethod(body?: AddPaymentMethodCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/wallet/payment-methos";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddPaymentMethod(_response);
        });
    }

    protected processAddPaymentMethod(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    startSession(body?: StartWorkSessionCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/work-session/start";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartSession(_response);
        });
    }

    protected processStartSession(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    submitSession(body?: SubmitWorkSessionCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/work-session/submit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubmitSession(_response);
        });
    }

    protected processSubmitSession(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    endSession(body?: EndWorkSessionCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/work-session/end";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEndSession(_response);
        });
    }

    protected processEndSession(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    approveSession(body?: ApproveWorkSessionCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/work-session/approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApproveSession(_response);
        });
    }

    protected processApproveSession(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    reactSession(body?: ReactToWorkSessionCommand | undefined): Promise<CommandResult> {
        let url_ = this.baseUrl + "/api/work-session/react";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReactSession(_response);
        });
    }

    protected processReactSession(response: Response): Promise<CommandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommandResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommandResult>(null as any);
    }

    /**
     * @return OK
     */
    getSession(id: string): Promise<WorkSessionEntity> {
        let url_ = this.baseUrl + "/api/work-session/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSession(_response);
        });
    }

    protected processGetSession(response: Response): Promise<WorkSessionEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkSessionEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkSessionEntity>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getSessionList(body?: GetWorkSessionListQuery | undefined): Promise<WorkSessionEntity[]> {
        let url_ = this.baseUrl + "/api/work-session/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSessionList(_response);
        });
    }

    protected processGetSessionList(response: Response): Promise<WorkSessionEntity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkSessionEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkSessionEntity[]>(null as any);
    }
}

export class AcceptDisputeCommand implements IAcceptDisputeCommand {
    disputeId?: string;

    constructor(data?: IAcceptDisputeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disputeId = _data["disputeId"];
        }
    }

    static fromJS(data: any): AcceptDisputeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptDisputeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disputeId"] = this.disputeId;
        return data;
    }
}

export interface IAcceptDisputeCommand {
    disputeId?: string;
}

export class ActivitySummaryDto implements IActivitySummaryDto {
    activityId!: string;
    description!: string;
    count!: number;

    constructor(data?: IActivitySummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityId = _data["activityId"];
            this.description = _data["description"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): ActivitySummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivitySummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityId"] = this.activityId;
        data["description"] = this.description;
        data["count"] = this.count;
        return data;
    }
}

export interface IActivitySummaryDto {
    activityId: string;
    description: string;
    count: number;
}

export class AddBonusToContractCommand implements IAddBonusToContractCommand {
    contractId?: string;
    amountValue?: number;
    currency?: AddBonusToContractCommandCurrency;
    description?: string | undefined;
    type?: AddBonusToContractCommandType;

    constructor(data?: IAddBonusToContractCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractId = _data["contractId"];
            this.amountValue = _data["amountValue"];
            this.currency = _data["currency"];
            this.description = _data["description"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): AddBonusToContractCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddBonusToContractCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractId"] = this.contractId;
        data["amountValue"] = this.amountValue;
        data["currency"] = this.currency;
        data["description"] = this.description;
        data["type"] = this.type;
        return data;
    }
}

export interface IAddBonusToContractCommand {
    contractId?: string;
    amountValue?: number;
    currency?: AddBonusToContractCommandCurrency;
    description?: string | undefined;
    type?: AddBonusToContractCommandType;
}

export class AddPaymentMethodCommand implements IAddPaymentMethodCommand {
    providerId?: string;
    paymentMethodToken?: string | undefined;
    makeDefault?: boolean;

    constructor(data?: IAddPaymentMethodCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.providerId = _data["providerId"];
            this.paymentMethodToken = _data["paymentMethodToken"];
            this.makeDefault = _data["makeDefault"];
        }
    }

    static fromJS(data: any): AddPaymentMethodCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddPaymentMethodCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["providerId"] = this.providerId;
        data["paymentMethodToken"] = this.paymentMethodToken;
        data["makeDefault"] = this.makeDefault;
        return data;
    }
}

export interface IAddPaymentMethodCommand {
    providerId?: string;
    paymentMethodToken?: string | undefined;
    makeDefault?: boolean;
}

export class AddPortfolioProjectCommand implements IAddPortfolioProjectCommand {
    name?: string | undefined;
    userRole?: string | undefined;
    skills?: string[] | undefined;
    description?: string | undefined;
    files?: CreateFileDto[] | undefined;

    constructor(data?: IAddPortfolioProjectCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.userRole = _data["userRole"];
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(item);
            }
            this.description = _data["description"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(CreateFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddPortfolioProjectCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddPortfolioProjectCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["userRole"] = this.userRole;
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item);
        }
        data["description"] = this.description;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAddPortfolioProjectCommand {
    name?: string | undefined;
    userRole?: string | undefined;
    skills?: string[] | undefined;
    description?: string | undefined;
    files?: CreateFileDto[] | undefined;
}

export class ApproveContestCommand implements IApproveContestCommand {
    contestId?: string;

    constructor(data?: IApproveContestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contestId = _data["contestId"];
        }
    }

    static fromJS(data: any): ApproveContestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveContestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contestId"] = this.contestId;
        return data;
    }
}

export interface IApproveContestCommand {
    contestId?: string;
}

export class ApproveWorkSessionCommand implements IApproveWorkSessionCommand {
    sessionId?: string;

    constructor(data?: IApproveWorkSessionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sessionId = _data["sessionId"];
        }
    }

    static fromJS(data: any): ApproveWorkSessionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveWorkSessionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionId"] = this.sessionId;
        return data;
    }
}

export interface IApproveWorkSessionCommand {
    sessionId?: string;
}

export class BalanceOperationCommand implements IBalanceOperationCommand {
    readonly walletId!: string;
    balance!: Money;
    readonly balanceOperationType?: BalanceOperationCommandBalanceOperationType;

    constructor(data?: IBalanceOperationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.balance = new Money();
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).walletId = _data["walletId"];
            this.balance = _data["balance"] ? Money.fromJS(_data["balance"]) : new Money();
            (<any>this).balanceOperationType = _data["balanceOperationType"];
        }
    }

    static fromJS(data: any): BalanceOperationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceOperationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["walletId"] = this.walletId;
        data["balance"] = this.balance ? this.balance.toJSON() : <any>undefined;
        data["balanceOperationType"] = this.balanceOperationType;
        return data;
    }
}

export interface IBalanceOperationCommand {
    walletId: string;
    balance: Money;
    balanceOperationType?: BalanceOperationCommandBalanceOperationType;
}

export class BankDetails implements IBankDetails {
    bic!: string;
    accountNumber!: string;
    bankName!: string;

    constructor(data?: IBankDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bic = _data["bic"];
            this.accountNumber = _data["accountNumber"];
            this.bankName = _data["bankName"];
        }
    }

    static fromJS(data: any): BankDetails {
        data = typeof data === 'object' ? data : {};
        let result = new BankDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bic"] = this.bic;
        data["accountNumber"] = this.accountNumber;
        data["bankName"] = this.bankName;
        return data;
    }
}

export interface IBankDetails {
    bic: string;
    accountNumber: string;
    bankName: string;
}

export class BlockWalletCommand implements IBlockWalletCommand {
    walletId!: string;
    reason!: BlockWalletCommandReason;

    constructor(data?: IBlockWalletCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.walletId = _data["walletId"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): BlockWalletCommand {
        data = typeof data === 'object' ? data : {};
        let result = new BlockWalletCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["walletId"] = this.walletId;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IBlockWalletCommand {
    walletId: string;
    reason: BlockWalletCommandReason;
}

export class BonusEntity implements IBonusEntity {
    contract?: ContractEntity;
    contractId?: string;
    amount?: Money;
    description?: string | undefined;
    type?: BonusEntityType;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: IBonusEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contract = _data["contract"] ? ContractEntity.fromJS(_data["contract"]) : <any>undefined;
            this.contractId = _data["contractId"];
            this.amount = _data["amount"] ? Money.fromJS(_data["amount"]) : <any>undefined;
            this.description = _data["description"];
            this.type = _data["type"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BonusEntity {
        data = typeof data === 'object' ? data : {};
        let result = new BonusEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contract"] = this.contract ? this.contract.toJSON() : <any>undefined;
        data["contractId"] = this.contractId;
        data["amount"] = this.amount ? this.amount.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["type"] = this.type;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IBonusEntity {
    contract?: ContractEntity;
    contractId?: string;
    amount?: Money;
    description?: string | undefined;
    type?: BonusEntityType;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class BookmarkChatDto implements IBookmarkChatDto {
    chatId?: string;

    constructor(data?: IBookmarkChatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatId = _data["chatId"];
        }
    }

    static fromJS(data: any): BookmarkChatDto {
        data = typeof data === 'object' ? data : {};
        let result = new BookmarkChatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatId"] = this.chatId;
        return data;
    }
}

export interface IBookmarkChatDto {
    chatId?: string;
}

export class BookmarkJobCommand implements IBookmarkJobCommand {
    jobId?: string;

    constructor(data?: IBookmarkJobCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
        }
    }

    static fromJS(data: any): BookmarkJobCommand {
        data = typeof data === 'object' ? data : {};
        let result = new BookmarkJobCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        return data;
    }
}

export interface IBookmarkJobCommand {
    jobId?: string;
}

export class BookmarkedJobEntity implements IBookmarkedJobEntity {
    jobId!: string;
    job!: JobEntity;
    userId!: string;
    user!: UserEntity;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: IBookmarkedJobEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.job = new JobEntity();
            this.user = new UserEntity();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
            this.job = _data["job"] ? JobEntity.fromJS(_data["job"]) : new JobEntity();
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserEntity.fromJS(_data["user"]) : new UserEntity();
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BookmarkedJobEntity {
        data = typeof data === 'object' ? data : {};
        let result = new BookmarkedJobEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        data["job"] = this.job ? this.job.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IBookmarkedJobEntity {
    jobId: string;
    job: JobEntity;
    userId: string;
    user: UserEntity;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class CardSetupDetails implements ICardSetupDetails {
    success?: boolean;
    providerSetupId?: string | undefined;
    clientSecretForWidget?: string | undefined;
    redirectUrlForProviderPage?: string | undefined;
    errorMessage?: string | undefined;

    constructor(data?: ICardSetupDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.providerSetupId = _data["providerSetupId"];
            this.clientSecretForWidget = _data["clientSecretForWidget"];
            this.redirectUrlForProviderPage = _data["redirectUrlForProviderPage"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): CardSetupDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CardSetupDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["providerSetupId"] = this.providerSetupId;
        data["clientSecretForWidget"] = this.clientSecretForWidget;
        data["redirectUrlForProviderPage"] = this.redirectUrlForProviderPage;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface ICardSetupDetails {
    success?: boolean;
    providerSetupId?: string | undefined;
    clientSecretForWidget?: string | undefined;
    redirectUrlForProviderPage?: string | undefined;
    errorMessage?: string | undefined;
}

export class CategoryEntity implements ICategoryEntity {
    name?: string | undefined;
    slug?: string | undefined;
    parentCategoryId?: string | undefined;
    parentCategory?: CategoryEntity;
    subCategories?: CategoryEntity[] | undefined;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: ICategoryEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.parentCategory = _data["parentCategory"] ? CategoryEntity.fromJS(_data["parentCategory"]) : <any>undefined;
            if (Array.isArray(_data["subCategories"])) {
                this.subCategories = [] as any;
                for (let item of _data["subCategories"])
                    this.subCategories!.push(CategoryEntity.fromJS(item));
            }
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CategoryEntity {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["parentCategoryId"] = this.parentCategoryId;
        data["parentCategory"] = this.parentCategory ? this.parentCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.subCategories)) {
            data["subCategories"] = [];
            for (let item of this.subCategories)
                data["subCategories"].push(item.toJSON());
        }
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ICategoryEntity {
    name?: string | undefined;
    slug?: string | undefined;
    parentCategoryId?: string | undefined;
    parentCategory?: CategoryEntity;
    subCategories?: CategoryEntity[] | undefined;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class ChatEntity implements IChatEntity {
    readonly ownerId?: string;
    owner?: UserEntity;
    participants?: UserEntity[] | undefined;
    name?: string | undefined;
    type?: ChatEntityType;
    isArchived?: boolean;
    isTextingAllowed?: boolean;
    finishedAt?: Date | undefined;
    contracts?: ContractEntity[] | undefined;
    readRecords?: MessageReadEntity[] | undefined;
    messages?: MessageEntity[] | undefined;
    lastMessage?: MessageEntity;
    currentUserBookmarked?: boolean;
    currentUserNotificationsDisabled?: boolean;
    currentUserUnreadMessagesCount?: number;
    jobs?: JobEntity[] | undefined;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: IChatEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).ownerId = _data["ownerId"];
            this.owner = _data["owner"] ? UserEntity.fromJS(_data["owner"]) : <any>undefined;
            if (Array.isArray(_data["participants"])) {
                this.participants = [] as any;
                for (let item of _data["participants"])
                    this.participants!.push(UserEntity.fromJS(item));
            }
            this.name = _data["name"];
            this.type = _data["type"];
            this.isArchived = _data["isArchived"];
            this.isTextingAllowed = _data["isTextingAllowed"];
            this.finishedAt = _data["finishedAt"] ? new Date(_data["finishedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["contracts"])) {
                this.contracts = [] as any;
                for (let item of _data["contracts"])
                    this.contracts!.push(ContractEntity.fromJS(item));
            }
            if (Array.isArray(_data["readRecords"])) {
                this.readRecords = [] as any;
                for (let item of _data["readRecords"])
                    this.readRecords!.push(MessageReadEntity.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(MessageEntity.fromJS(item));
            }
            this.lastMessage = _data["lastMessage"] ? MessageEntity.fromJS(_data["lastMessage"]) : <any>undefined;
            this.currentUserBookmarked = _data["currentUserBookmarked"];
            this.currentUserNotificationsDisabled = _data["currentUserNotificationsDisabled"];
            this.currentUserUnreadMessagesCount = _data["currentUserUnreadMessagesCount"];
            if (Array.isArray(_data["jobs"])) {
                this.jobs = [] as any;
                for (let item of _data["jobs"])
                    this.jobs!.push(JobEntity.fromJS(item));
            }
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ChatEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ChatEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerId"] = this.ownerId;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        if (Array.isArray(this.participants)) {
            data["participants"] = [];
            for (let item of this.participants)
                data["participants"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["type"] = this.type;
        data["isArchived"] = this.isArchived;
        data["isTextingAllowed"] = this.isTextingAllowed;
        data["finishedAt"] = this.finishedAt ? this.finishedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.contracts)) {
            data["contracts"] = [];
            for (let item of this.contracts)
                data["contracts"].push(item.toJSON());
        }
        if (Array.isArray(this.readRecords)) {
            data["readRecords"] = [];
            for (let item of this.readRecords)
                data["readRecords"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["lastMessage"] = this.lastMessage ? this.lastMessage.toJSON() : <any>undefined;
        data["currentUserBookmarked"] = this.currentUserBookmarked;
        data["currentUserNotificationsDisabled"] = this.currentUserNotificationsDisabled;
        data["currentUserUnreadMessagesCount"] = this.currentUserUnreadMessagesCount;
        if (Array.isArray(this.jobs)) {
            data["jobs"] = [];
            for (let item of this.jobs)
                data["jobs"].push(item.toJSON());
        }
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IChatEntity {
    ownerId?: string;
    owner?: UserEntity;
    participants?: UserEntity[] | undefined;
    name?: string | undefined;
    type?: ChatEntityType;
    isArchived?: boolean;
    isTextingAllowed?: boolean;
    finishedAt?: Date | undefined;
    contracts?: ContractEntity[] | undefined;
    readRecords?: MessageReadEntity[] | undefined;
    messages?: MessageEntity[] | undefined;
    lastMessage?: MessageEntity;
    currentUserBookmarked?: boolean;
    currentUserNotificationsDisabled?: boolean;
    currentUserUnreadMessagesCount?: number;
    jobs?: JobEntity[] | undefined;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class ClientAcceptFinishContractCommand implements IClientAcceptFinishContractCommand {
    readonly contractId?: string;

    constructor(data?: IClientAcceptFinishContractCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).contractId = _data["contractId"];
        }
    }

    static fromJS(data: any): ClientAcceptFinishContractCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ClientAcceptFinishContractCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractId"] = this.contractId;
        return data;
    }
}

export interface IClientAcceptFinishContractCommand {
    contractId?: string;
}

export class ClientCloseContractCommand implements IClientCloseContractCommand {
    contractId?: string;
    reason?: string | undefined;

    constructor(data?: IClientCloseContractCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractId = _data["contractId"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): ClientCloseContractCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ClientCloseContractCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractId"] = this.contractId;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IClientCloseContractCommand {
    contractId?: string;
    reason?: string | undefined;
}

export class ClientJobInfo implements IClientJobInfo {
    userId?: string;
    name?: string | undefined;
    avatar?: FileEntity;
    isVerified?: boolean;
    activeJobs?: number;
    closedJobs?: number;
    arbitrationJobs?: number;
    activeContracts?: number;
    completedContracts?: number;
    arbitrationContracts?: number;
    registeredAt?: string | undefined;
    lastActiveAt?: string | undefined;
    isPhoneVerified?: boolean;
    hasPremium?: boolean;

    constructor(data?: IClientJobInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.avatar = _data["avatar"] ? FileEntity.fromJS(_data["avatar"]) : <any>undefined;
            this.isVerified = _data["isVerified"];
            this.activeJobs = _data["activeJobs"];
            this.closedJobs = _data["closedJobs"];
            this.arbitrationJobs = _data["arbitrationJobs"];
            this.activeContracts = _data["activeContracts"];
            this.completedContracts = _data["completedContracts"];
            this.arbitrationContracts = _data["arbitrationContracts"];
            this.registeredAt = _data["registeredAt"];
            this.lastActiveAt = _data["lastActiveAt"];
            this.isPhoneVerified = _data["isPhoneVerified"];
            this.hasPremium = _data["hasPremium"];
        }
    }

    static fromJS(data: any): ClientJobInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ClientJobInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["avatar"] = this.avatar ? this.avatar.toJSON() : <any>undefined;
        data["isVerified"] = this.isVerified;
        data["activeJobs"] = this.activeJobs;
        data["closedJobs"] = this.closedJobs;
        data["arbitrationJobs"] = this.arbitrationJobs;
        data["activeContracts"] = this.activeContracts;
        data["completedContracts"] = this.completedContracts;
        data["arbitrationContracts"] = this.arbitrationContracts;
        data["registeredAt"] = this.registeredAt;
        data["lastActiveAt"] = this.lastActiveAt;
        data["isPhoneVerified"] = this.isPhoneVerified;
        data["hasPremium"] = this.hasPremium;
        return data;
    }
}

export interface IClientJobInfo {
    userId?: string;
    name?: string | undefined;
    avatar?: FileEntity;
    isVerified?: boolean;
    activeJobs?: number;
    closedJobs?: number;
    arbitrationJobs?: number;
    activeContracts?: number;
    completedContracts?: number;
    arbitrationContracts?: number;
    registeredAt?: string | undefined;
    lastActiveAt?: string | undefined;
    isPhoneVerified?: boolean;
    hasPremium?: boolean;
}

export class ClientRejectContractCompletionCommand implements IClientRejectContractCompletionCommand {
    contractId?: string;
    reason?: string | undefined;

    constructor(data?: IClientRejectContractCompletionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractId = _data["contractId"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): ClientRejectContractCompletionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ClientRejectContractCompletionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractId"] = this.contractId;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IClientRejectContractCompletionCommand {
    contractId?: string;
    reason?: string | undefined;
}

export class CloseChatDto implements ICloseChatDto {
    chatId?: string;

    constructor(data?: ICloseChatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatId = _data["chatId"];
        }
    }

    static fromJS(data: any): CloseChatDto {
        data = typeof data === 'object' ? data : {};
        let result = new CloseChatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatId"] = this.chatId;
        return data;
    }
}

export interface ICloseChatDto {
    chatId?: string;
}

export class CommandResult implements ICommandResult {
    readonly message?: string | undefined;
    readonly id!: string;
    readonly ids?: string[] | undefined;
    readonly status!: CommandResultStatus;
    readonly isSuccess?: boolean;

    constructor(data?: ICommandResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).message = _data["message"];
            (<any>this).id = _data["id"];
            if (Array.isArray(_data["ids"])) {
                (<any>this).ids = [] as any;
                for (let item of _data["ids"])
                    (<any>this).ids!.push(item);
            }
            (<any>this).status = _data["status"];
            (<any>this).isSuccess = _data["isSuccess"];
        }
    }

    static fromJS(data: any): CommandResult {
        data = typeof data === 'object' ? data : {};
        let result = new CommandResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["id"] = this.id;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["status"] = this.status;
        data["isSuccess"] = this.isSuccess;
        return data;
    }
}

export interface ICommandResult {
    message?: string | undefined;
    id: string;
    ids?: string[] | undefined;
    status: CommandResultStatus;
    isSuccess?: boolean;
}

export class CompleteTaskCommand implements ICompleteTaskCommand {
    taskId?: string;

    constructor(data?: ICompleteTaskCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskId = _data["taskId"];
        }
    }

    static fromJS(data: any): CompleteTaskCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteTaskCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskId"] = this.taskId;
        return data;
    }
}

export interface ICompleteTaskCommand {
    taskId?: string;
}

export class ContestEntity implements IContestEntity {
    employerId?: string;
    employer?: UserEntity;
    title?: string | undefined;
    description?: string | undefined;
    prizePool?: Money;
    startDate?: Date;
    endDate?: Date | undefined;
    status?: ContestEntityStatus;
    winnerEntryId?: string | undefined;
    isResultPublic?: boolean;
    isEntriesPublic?: boolean;
    files?: FileEntity[] | undefined;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: IContestEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employerId = _data["employerId"];
            this.employer = _data["employer"] ? UserEntity.fromJS(_data["employer"]) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            this.prizePool = _data["prizePool"] ? Money.fromJS(_data["prizePool"]) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.winnerEntryId = _data["winnerEntryId"];
            this.isResultPublic = _data["isResultPublic"];
            this.isEntriesPublic = _data["isEntriesPublic"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(FileEntity.fromJS(item));
            }
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContestEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ContestEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employerId"] = this.employerId;
        data["employer"] = this.employer ? this.employer.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["prizePool"] = this.prizePool ? this.prizePool.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["winnerEntryId"] = this.winnerEntryId;
        data["isResultPublic"] = this.isResultPublic;
        data["isEntriesPublic"] = this.isEntriesPublic;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IContestEntity {
    employerId?: string;
    employer?: UserEntity;
    title?: string | undefined;
    description?: string | undefined;
    prizePool?: Money;
    startDate?: Date;
    endDate?: Date | undefined;
    status?: ContestEntityStatus;
    winnerEntryId?: string | undefined;
    isResultPublic?: boolean;
    isEntriesPublic?: boolean;
    files?: FileEntity[] | undefined;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class ContractEntity implements IContractEntity {
    freelancerId?: string;
    freelancer?: UserEntity;
    employerId?: string;
    employer?: UserEntity;
    startDate?: Date;
    endDate?: Date | undefined;
    budget?: Money;
    status?: ContractEntityStatus;
    costPerHour?: Money;
    budgetType?: ContractEntityBudgetType;
    tasks?: TaskEntity[] | undefined;
    workSessions?: WorkSessionEntity[] | undefined;
    readonly totalWorkSessions?: number;
    bonuses?: BonusEntity[] | undefined;
    readonly totalHoursWorked?: number;
    remainingBudget?: Money;
    paymentSchedule?: ContractEntityPaymentSchedule;
    isPaused?: boolean;
    pauseReason?: string | undefined;
    contractTerms?: string | undefined;
    bonus?: number | undefined;
    disputeId?: string | undefined;
    job?: JobEntity;
    jobId?: string;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: IContractEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.freelancerId = _data["freelancerId"];
            this.freelancer = _data["freelancer"] ? UserEntity.fromJS(_data["freelancer"]) : <any>undefined;
            this.employerId = _data["employerId"];
            this.employer = _data["employer"] ? UserEntity.fromJS(_data["employer"]) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.budget = _data["budget"] ? Money.fromJS(_data["budget"]) : <any>undefined;
            this.status = _data["status"];
            this.costPerHour = _data["costPerHour"] ? Money.fromJS(_data["costPerHour"]) : <any>undefined;
            this.budgetType = _data["budgetType"];
            if (Array.isArray(_data["tasks"])) {
                this.tasks = [] as any;
                for (let item of _data["tasks"])
                    this.tasks!.push(TaskEntity.fromJS(item));
            }
            if (Array.isArray(_data["workSessions"])) {
                this.workSessions = [] as any;
                for (let item of _data["workSessions"])
                    this.workSessions!.push(WorkSessionEntity.fromJS(item));
            }
            (<any>this).totalWorkSessions = _data["totalWorkSessions"];
            if (Array.isArray(_data["bonuses"])) {
                this.bonuses = [] as any;
                for (let item of _data["bonuses"])
                    this.bonuses!.push(BonusEntity.fromJS(item));
            }
            (<any>this).totalHoursWorked = _data["totalHoursWorked"];
            this.remainingBudget = _data["remainingBudget"] ? Money.fromJS(_data["remainingBudget"]) : <any>undefined;
            this.paymentSchedule = _data["paymentSchedule"];
            this.isPaused = _data["isPaused"];
            this.pauseReason = _data["pauseReason"];
            this.contractTerms = _data["contractTerms"];
            this.bonus = _data["bonus"];
            this.disputeId = _data["disputeId"];
            this.job = _data["job"] ? JobEntity.fromJS(_data["job"]) : <any>undefined;
            this.jobId = _data["jobId"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContractEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ContractEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["freelancerId"] = this.freelancerId;
        data["freelancer"] = this.freelancer ? this.freelancer.toJSON() : <any>undefined;
        data["employerId"] = this.employerId;
        data["employer"] = this.employer ? this.employer.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["budget"] = this.budget ? this.budget.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["costPerHour"] = this.costPerHour ? this.costPerHour.toJSON() : <any>undefined;
        data["budgetType"] = this.budgetType;
        if (Array.isArray(this.tasks)) {
            data["tasks"] = [];
            for (let item of this.tasks)
                data["tasks"].push(item.toJSON());
        }
        if (Array.isArray(this.workSessions)) {
            data["workSessions"] = [];
            for (let item of this.workSessions)
                data["workSessions"].push(item.toJSON());
        }
        data["totalWorkSessions"] = this.totalWorkSessions;
        if (Array.isArray(this.bonuses)) {
            data["bonuses"] = [];
            for (let item of this.bonuses)
                data["bonuses"].push(item.toJSON());
        }
        data["totalHoursWorked"] = this.totalHoursWorked;
        data["remainingBudget"] = this.remainingBudget ? this.remainingBudget.toJSON() : <any>undefined;
        data["paymentSchedule"] = this.paymentSchedule;
        data["isPaused"] = this.isPaused;
        data["pauseReason"] = this.pauseReason;
        data["contractTerms"] = this.contractTerms;
        data["bonus"] = this.bonus;
        data["disputeId"] = this.disputeId;
        data["job"] = this.job ? this.job.toJSON() : <any>undefined;
        data["jobId"] = this.jobId;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IContractEntity {
    freelancerId?: string;
    freelancer?: UserEntity;
    employerId?: string;
    employer?: UserEntity;
    startDate?: Date;
    endDate?: Date | undefined;
    budget?: Money;
    status?: ContractEntityStatus;
    costPerHour?: Money;
    budgetType?: ContractEntityBudgetType;
    tasks?: TaskEntity[] | undefined;
    workSessions?: WorkSessionEntity[] | undefined;
    totalWorkSessions?: number;
    bonuses?: BonusEntity[] | undefined;
    totalHoursWorked?: number;
    remainingBudget?: Money;
    paymentSchedule?: ContractEntityPaymentSchedule;
    isPaused?: boolean;
    pauseReason?: string | undefined;
    contractTerms?: string | undefined;
    bonus?: number | undefined;
    disputeId?: string | undefined;
    job?: JobEntity;
    jobId?: string;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class ContractSummaryDto implements IContractSummaryDto {
    contractId!: string;
    contractLabel!: string;
    amount!: number;

    constructor(data?: IContractSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractId = _data["contractId"];
            this.contractLabel = _data["contractLabel"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): ContractSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractId"] = this.contractId;
        data["contractLabel"] = this.contractLabel;
        data["amount"] = this.amount;
        return data;
    }
}

export interface IContractSummaryDto {
    contractId: string;
    contractLabel: string;
    amount: number;
}

export class CreateCategoryCommand implements ICreateCategoryCommand {
    name!: string | undefined;
    slug?: string | undefined;
    tags?: string | undefined;
    parentCategoryId?: string | undefined;

    constructor(data?: ICreateCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.tags = _data["tags"];
            this.parentCategoryId = _data["parentCategoryId"];
        }
    }

    static fromJS(data: any): CreateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["tags"] = this.tags;
        data["parentCategoryId"] = this.parentCategoryId;
        return data;
    }
}

export interface ICreateCategoryCommand {
    name: string | undefined;
    slug?: string | undefined;
    tags?: string | undefined;
    parentCategoryId?: string | undefined;
}

export class CreateChatDto implements ICreateChatDto {
    name!: string;
    description?: string | undefined;
    userIds?: string[] | undefined;
    type?: CreateChatDtoType;

    constructor(data?: ICreateChatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CreateChatDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateChatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["type"] = this.type;
        return data;
    }
}

export interface ICreateChatDto {
    name: string;
    description?: string | undefined;
    userIds?: string[] | undefined;
    type?: CreateChatDtoType;
}

export class CreateClientProfileCommand implements ICreateClientProfileCommand {
    companyName!: string;
    companyDescription?: string | undefined;
    companyWebsite?: string | undefined;
    location?: string | undefined;
    companyLogo?: CreateFileDto;
    employerType?: CreateClientProfileCommandEmployerType;
    phoneNumber?: string | undefined;
    userId?: string;

    constructor(data?: ICreateClientProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyName = _data["companyName"];
            this.companyDescription = _data["companyDescription"];
            this.companyWebsite = _data["companyWebsite"];
            this.location = _data["location"];
            this.companyLogo = _data["companyLogo"] ? CreateFileDto.fromJS(_data["companyLogo"]) : <any>undefined;
            this.employerType = _data["employerType"];
            this.phoneNumber = _data["phoneNumber"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): CreateClientProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClientProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["companyDescription"] = this.companyDescription;
        data["companyWebsite"] = this.companyWebsite;
        data["location"] = this.location;
        data["companyLogo"] = this.companyLogo ? this.companyLogo.toJSON() : <any>undefined;
        data["employerType"] = this.employerType;
        data["phoneNumber"] = this.phoneNumber;
        data["userId"] = this.userId;
        return data;
    }
}

export interface ICreateClientProfileCommand {
    companyName: string;
    companyDescription?: string | undefined;
    companyWebsite?: string | undefined;
    location?: string | undefined;
    companyLogo?: CreateFileDto;
    employerType?: CreateClientProfileCommandEmployerType;
    phoneNumber?: string | undefined;
    userId?: string;
}

export class CreateContestCommand implements ICreateContestCommand {
    title!: string;
    description!: string;
    prizePool!: number;
    isResultPublic?: boolean;

    constructor(data?: ICreateContestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.description = _data["description"];
            this.prizePool = _data["prizePool"];
            this.isResultPublic = _data["isResultPublic"];
        }
    }

    static fromJS(data: any): CreateContestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["description"] = this.description;
        data["prizePool"] = this.prizePool;
        data["isResultPublic"] = this.isResultPublic;
        return data;
    }
}

export interface ICreateContestCommand {
    title: string;
    description: string;
    prizePool: number;
    isResultPublic?: boolean;
}

export class CreateContractCommand implements ICreateContractCommand {
    freelancerId?: string;
    jobId?: string;
    budget?: number | undefined;
    costPerHour?: number | undefined;
    budgetType?: CreateContractCommandBudgetType;
    paymentSchedule?: CreateContractCommandPaymentSchedule;
    contractTerms?: string | undefined;
    endDate?: Date | undefined;

    constructor(data?: ICreateContractCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.freelancerId = _data["freelancerId"];
            this.jobId = _data["jobId"];
            this.budget = _data["budget"];
            this.costPerHour = _data["costPerHour"];
            this.budgetType = _data["budgetType"];
            this.paymentSchedule = _data["paymentSchedule"];
            this.contractTerms = _data["contractTerms"];
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateContractCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContractCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["freelancerId"] = this.freelancerId;
        data["jobId"] = this.jobId;
        data["budget"] = this.budget;
        data["costPerHour"] = this.costPerHour;
        data["budgetType"] = this.budgetType;
        data["paymentSchedule"] = this.paymentSchedule;
        data["contractTerms"] = this.contractTerms;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICreateContractCommand {
    freelancerId?: string;
    jobId?: string;
    budget?: number | undefined;
    costPerHour?: number | undefined;
    budgetType?: CreateContractCommandBudgetType;
    paymentSchedule?: CreateContractCommandPaymentSchedule;
    contractTerms?: string | undefined;
    endDate?: Date | undefined;
}

export class CreateFileDto implements ICreateFileDto {
    downloadUrl?: string | undefined;
    fileId?: string | undefined;
    name?: string | undefined;
    mimeType?: string | undefined;
    stream?: string | undefined;

    constructor(data?: ICreateFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.downloadUrl = _data["downloadUrl"];
            this.fileId = _data["fileId"];
            this.name = _data["name"];
            this.mimeType = _data["mimeType"];
            this.stream = _data["stream"];
        }
    }

    static fromJS(data: any): CreateFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["downloadUrl"] = this.downloadUrl;
        data["fileId"] = this.fileId;
        data["name"] = this.name;
        data["mimeType"] = this.mimeType;
        data["stream"] = this.stream;
        return data;
    }
}

export interface ICreateFileDto {
    downloadUrl?: string | undefined;
    fileId?: string | undefined;
    name?: string | undefined;
    mimeType?: string | undefined;
    stream?: string | undefined;
}

export class CreateFreelancerProfileCommand implements ICreateFreelancerProfileCommand {
    userId?: string | undefined;
    experience?: string | undefined;
    hourlyRate?: number;
    resume?: string | undefined;

    constructor(data?: ICreateFreelancerProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.experience = _data["experience"];
            this.hourlyRate = _data["hourlyRate"];
            this.resume = _data["resume"];
        }
    }

    static fromJS(data: any): CreateFreelancerProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFreelancerProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["experience"] = this.experience;
        data["hourlyRate"] = this.hourlyRate;
        data["resume"] = this.resume;
        return data;
    }
}

export interface ICreateFreelancerProfileCommand {
    userId?: string | undefined;
    experience?: string | undefined;
    hourlyRate?: number;
    resume?: string | undefined;
}

export class CreateFreelancerTeamCommand implements ICreateFreelancerTeamCommand {
    name!: string | undefined;
    description?: string | undefined;

    constructor(data?: ICreateFreelancerTeamCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateFreelancerTeamCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFreelancerTeamCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreateFreelancerTeamCommand {
    name: string | undefined;
    description?: string | undefined;
}

export class CreateJobCommand implements ICreateJobCommand {
    title?: string | undefined;
    description?: string | undefined;
    requiredSkillIds?: string[] | undefined;
    categoryId?: string;
    budget?: number | undefined;
    hourlyRate?: number | undefined;
    duration?: number | undefined;
    budgetType?: CreateJobCommandBudgetType;
    level?: CreateJobCommandLevel;
    expirationDate?: Date | undefined;
    files?: CreateFileDto[] | undefined;

    constructor(data?: ICreateJobCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["requiredSkillIds"])) {
                this.requiredSkillIds = [] as any;
                for (let item of _data["requiredSkillIds"])
                    this.requiredSkillIds!.push(item);
            }
            this.categoryId = _data["categoryId"];
            this.budget = _data["budget"];
            this.hourlyRate = _data["hourlyRate"];
            this.duration = _data["duration"];
            this.budgetType = _data["budgetType"];
            this.level = _data["level"];
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(CreateFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateJobCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateJobCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.requiredSkillIds)) {
            data["requiredSkillIds"] = [];
            for (let item of this.requiredSkillIds)
                data["requiredSkillIds"].push(item);
        }
        data["categoryId"] = this.categoryId;
        data["budget"] = this.budget;
        data["hourlyRate"] = this.hourlyRate;
        data["duration"] = this.duration;
        data["budgetType"] = this.budgetType;
        data["level"] = this.level;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateJobCommand {
    title?: string | undefined;
    description?: string | undefined;
    requiredSkillIds?: string[] | undefined;
    categoryId?: string;
    budget?: number | undefined;
    hourlyRate?: number | undefined;
    duration?: number | undefined;
    budgetType?: CreateJobCommandBudgetType;
    level?: CreateJobCommandLevel;
    expirationDate?: Date | undefined;
    files?: CreateFileDto[] | undefined;
}

export class CreateNewsDto implements ICreateNewsDto {
    title?: string | undefined;
    text?: string | undefined;
    publishTime?: Date;
    files?: CreateFileDto[] | undefined;
    changeNotes?: boolean;

    constructor(data?: ICreateNewsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.text = _data["text"];
            this.publishTime = _data["publishTime"] ? new Date(_data["publishTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(CreateFileDto.fromJS(item));
            }
            this.changeNotes = _data["changeNotes"];
        }
    }

    static fromJS(data: any): CreateNewsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNewsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["text"] = this.text;
        data["publishTime"] = this.publishTime ? this.publishTime.toISOString() : <any>undefined;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["changeNotes"] = this.changeNotes;
        return data;
    }
}

export interface ICreateNewsDto {
    title?: string | undefined;
    text?: string | undefined;
    publishTime?: Date;
    files?: CreateFileDto[] | undefined;
    changeNotes?: boolean;
}

export class CreateNotificationCommand implements ICreateNotificationCommand {
    title!: string;
    text!: string;
    data!: { [key: string]: string; };
    userId?: string | undefined;
    role?: CreateNotificationCommandRole | undefined;
    type?: CreateNotificationCommandType | undefined;

    constructor(data?: ICreateNotificationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.text = _data["text"];
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
            this.userId = _data["userId"];
            this.role = _data["role"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CreateNotificationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNotificationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["text"] = this.text;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        data["userId"] = this.userId;
        data["role"] = this.role;
        data["type"] = this.type;
        return data;
    }
}

export interface ICreateNotificationCommand {
    title: string;
    text: string;
    data: { [key: string]: string; };
    userId?: string | undefined;
    role?: CreateNotificationCommandRole | undefined;
    type?: CreateNotificationCommandType | undefined;
}

export class CreateSetupIntentCommand implements ICreateSetupIntentCommand {
    providerId!: string;
    systemId?: string | undefined;
    returnUrl!: string;
    metadata?: { [key: string]: string; } | undefined;

    constructor(data?: ICreateSetupIntentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.providerId = _data["providerId"];
            this.systemId = _data["systemId"];
            this.returnUrl = _data["returnUrl"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
        }
    }

    static fromJS(data: any): CreateSetupIntentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSetupIntentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["providerId"] = this.providerId;
        data["systemId"] = this.systemId;
        data["returnUrl"] = this.returnUrl;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        return data;
    }
}

export interface ICreateSetupIntentCommand {
    providerId: string;
    systemId?: string | undefined;
    returnUrl: string;
    metadata?: { [key: string]: string; } | undefined;
}

export class CreateSkillsCommand implements ICreateSkillsCommand {
    skillNames?: string[] | undefined;

    constructor(data?: ICreateSkillsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["skillNames"])) {
                this.skillNames = [] as any;
                for (let item of _data["skillNames"])
                    this.skillNames!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateSkillsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSkillsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.skillNames)) {
            data["skillNames"] = [];
            for (let item of this.skillNames)
                data["skillNames"].push(item);
        }
        return data;
    }
}

export interface ICreateSkillsCommand {
    skillNames?: string[] | undefined;
}

export class CreateTaskCommand implements ICreateTaskCommand {
    contractId?: string;
    title?: string | undefined;
    description?: string | undefined;
    priority?: number;

    constructor(data?: ICreateTaskCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractId = _data["contractId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.priority = _data["priority"];
        }
    }

    static fromJS(data: any): CreateTaskCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTaskCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractId"] = this.contractId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["priority"] = this.priority;
        return data;
    }
}

export interface ICreateTaskCommand {
    contractId?: string;
    title?: string | undefined;
    description?: string | undefined;
    priority?: number;
}

export class CreateTicketDto implements ICreateTicketDto {
    subject!: string;
    text!: string;
    files?: CreateFileDto[] | undefined;
    priorityScore?: number;
    linkedDisputeId?: string | undefined;
    title?: string | undefined;

    constructor(data?: ICreateTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subject = _data["subject"];
            this.text = _data["text"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(CreateFileDto.fromJS(item));
            }
            this.priorityScore = _data["priorityScore"];
            this.linkedDisputeId = _data["linkedDisputeId"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["text"] = this.text;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["priorityScore"] = this.priorityScore;
        data["linkedDisputeId"] = this.linkedDisputeId;
        data["title"] = this.title;
        return data;
    }
}

export interface ICreateTicketDto {
    subject: string;
    text: string;
    files?: CreateFileDto[] | undefined;
    priorityScore?: number;
    linkedDisputeId?: string | undefined;
    title?: string | undefined;
}

export class DailyPointDto implements IDailyPointDto {
    date!: Date;
    amount!: number;

    constructor(data?: IDailyPointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): DailyPointDto {
        data = typeof data === 'object' ? data : {};
        let result = new DailyPointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data;
    }
}

export interface IDailyPointDto {
    date: Date;
    amount: number;
}

export class DeleteContestCommand implements IDeleteContestCommand {
    contestId?: string;

    constructor(data?: IDeleteContestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contestId = _data["contestId"];
        }
    }

    static fromJS(data: any): DeleteContestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteContestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contestId"] = this.contestId;
        return data;
    }
}

export interface IDeleteContestCommand {
    contestId?: string;
}

export class DeleteContestEntryCommand implements IDeleteContestEntryCommand {
    contestEntryId?: string;

    constructor(data?: IDeleteContestEntryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contestEntryId = _data["contestEntryId"];
        }
    }

    static fromJS(data: any): DeleteContestEntryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteContestEntryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contestEntryId"] = this.contestEntryId;
        return data;
    }
}

export interface IDeleteContestEntryCommand {
    contestEntryId?: string;
}

export class DeleteFreelancerTeamCommand implements IDeleteFreelancerTeamCommand {
    teamId?: string;

    constructor(data?: IDeleteFreelancerTeamCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.teamId = _data["teamId"];
        }
    }

    static fromJS(data: any): DeleteFreelancerTeamCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteFreelancerTeamCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teamId"] = this.teamId;
        return data;
    }
}

export interface IDeleteFreelancerTeamCommand {
    teamId?: string;
}

export class DeleteJobCommand implements IDeleteJobCommand {
    jobId?: string;

    constructor(data?: IDeleteJobCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
        }
    }

    static fromJS(data: any): DeleteJobCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteJobCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        return data;
    }
}

export interface IDeleteJobCommand {
    jobId?: string;
}

export class DeleteMessageDto implements IDeleteMessageDto {
    messgeId?: string;

    constructor(data?: IDeleteMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.messgeId = _data["messgeId"];
        }
    }

    static fromJS(data: any): DeleteMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["messgeId"] = this.messgeId;
        return data;
    }
}

export interface IDeleteMessageDto {
    messgeId?: string;
}

export class DeletePortfolioProjectCommand implements IDeletePortfolioProjectCommand {
    projectId?: string;

    constructor(data?: IDeletePortfolioProjectCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): DeletePortfolioProjectCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeletePortfolioProjectCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        return data;
    }
}

export interface IDeletePortfolioProjectCommand {
    projectId?: string;
}

export class DeleteSkillsCommand implements IDeleteSkillsCommand {
    skillIds?: string[] | undefined;
    skillNames?: string[] | undefined;

    constructor(data?: IDeleteSkillsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["skillIds"])) {
                this.skillIds = [] as any;
                for (let item of _data["skillIds"])
                    this.skillIds!.push(item);
            }
            if (Array.isArray(_data["skillNames"])) {
                this.skillNames = [] as any;
                for (let item of _data["skillNames"])
                    this.skillNames!.push(item);
            }
        }
    }

    static fromJS(data: any): DeleteSkillsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteSkillsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.skillIds)) {
            data["skillIds"] = [];
            for (let item of this.skillIds)
                data["skillIds"].push(item);
        }
        if (Array.isArray(this.skillNames)) {
            data["skillNames"] = [];
            for (let item of this.skillNames)
                data["skillNames"].push(item);
        }
        return data;
    }
}

export interface IDeleteSkillsCommand {
    skillIds?: string[] | undefined;
    skillNames?: string[] | undefined;
}

export class DeleteTaskCommand implements IDeleteTaskCommand {
    taskId?: string;

    constructor(data?: IDeleteTaskCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskId = _data["taskId"];
        }
    }

    static fromJS(data: any): DeleteTaskCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteTaskCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskId"] = this.taskId;
        return data;
    }
}

export interface IDeleteTaskCommand {
    taskId?: string;
}

export class EarningsSectionDto implements IEarningsSectionDto {
    fixed!: FixedEarnDto[];
    hourly!: WorkSessionSummaryDto[];

    constructor(data?: IEarningsSectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.fixed = [];
            this.hourly = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fixed"])) {
                this.fixed = [] as any;
                for (let item of _data["fixed"])
                    this.fixed!.push(FixedEarnDto.fromJS(item));
            }
            if (Array.isArray(_data["hourly"])) {
                this.hourly = [] as any;
                for (let item of _data["hourly"])
                    this.hourly!.push(WorkSessionSummaryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EarningsSectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new EarningsSectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fixed)) {
            data["fixed"] = [];
            for (let item of this.fixed)
                data["fixed"].push(item.toJSON());
        }
        if (Array.isArray(this.hourly)) {
            data["hourly"] = [];
            for (let item of this.hourly)
                data["hourly"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEarningsSectionDto {
    fixed: FixedEarnDto[];
    hourly: WorkSessionSummaryDto[];
}

export class EndContestCommand implements IEndContestCommand {
    contestId?: string;

    constructor(data?: IEndContestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contestId = _data["contestId"];
        }
    }

    static fromJS(data: any): EndContestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EndContestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contestId"] = this.contestId;
        return data;
    }
}

export interface IEndContestCommand {
    contestId?: string;
}

export class EndWorkSessionCommand implements IEndWorkSessionCommand {
    sessionId?: string;
    selectedFiles?: CreateFileDto[] | undefined;

    constructor(data?: IEndWorkSessionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sessionId = _data["sessionId"];
            if (Array.isArray(_data["selectedFiles"])) {
                this.selectedFiles = [] as any;
                for (let item of _data["selectedFiles"])
                    this.selectedFiles!.push(CreateFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EndWorkSessionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EndWorkSessionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionId"] = this.sessionId;
        if (Array.isArray(this.selectedFiles)) {
            data["selectedFiles"] = [];
            for (let item of this.selectedFiles)
                data["selectedFiles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEndWorkSessionCommand {
    sessionId?: string;
    selectedFiles?: CreateFileDto[] | undefined;
}

export class FeeContext implements IFeeContext {
    readonly isContractCancellation?: boolean;
    readonly isAdminOverride?: boolean;

    constructor(data?: IFeeContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isContractCancellation = _data["isContractCancellation"];
            (<any>this).isAdminOverride = _data["isAdminOverride"];
        }
    }

    static fromJS(data: any): FeeContext {
        data = typeof data === 'object' ? data : {};
        let result = new FeeContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isContractCancellation"] = this.isContractCancellation;
        data["isAdminOverride"] = this.isAdminOverride;
        return data;
    }
}

export interface IFeeContext {
    isContractCancellation?: boolean;
    isAdminOverride?: boolean;
}

export class FileEntity implements IFileEntity {
    id!: string;
    createdAt!: Date;
    fileName!: string;
    filePath!: string;
    mimeType!: string;
    size?: number;

    constructor(data?: IFileEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.fileName = _data["fileName"];
            this.filePath = _data["filePath"];
            this.mimeType = _data["mimeType"];
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): FileEntity {
        data = typeof data === 'object' ? data : {};
        let result = new FileEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["fileName"] = this.fileName;
        data["filePath"] = this.filePath;
        data["mimeType"] = this.mimeType;
        data["size"] = this.size;
        return data;
    }
}

export interface IFileEntity {
    id: string;
    createdAt: Date;
    fileName: string;
    filePath: string;
    mimeType: string;
    size?: number;
}

export class FinanceSummaryDto implements IFinanceSummaryDto {
    month!: number;
    year!: number;
    currency!: string;
    generatedAt!: Date;
    totalEarn!: TotalsDto;
    topContracts!: ContractSummaryDto[];
    topActivities!: ActivitySummaryDto[];
    earnings!: EarningsSectionDto;
    dailyBreakdown!: DailyPointDto[];
    avgHourlyRate!: number;
    daysWorked!: number;
    bestDay?: Date | undefined;
    bestDayAmount!: number;

    constructor(data?: IFinanceSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.totalEarn = new TotalsDto();
            this.topContracts = [];
            this.topActivities = [];
            this.earnings = new EarningsSectionDto();
            this.dailyBreakdown = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.month = _data["month"];
            this.year = _data["year"];
            this.currency = _data["currency"];
            this.generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
            this.totalEarn = _data["totalEarn"] ? TotalsDto.fromJS(_data["totalEarn"]) : new TotalsDto();
            if (Array.isArray(_data["topContracts"])) {
                this.topContracts = [] as any;
                for (let item of _data["topContracts"])
                    this.topContracts!.push(ContractSummaryDto.fromJS(item));
            }
            if (Array.isArray(_data["topActivities"])) {
                this.topActivities = [] as any;
                for (let item of _data["topActivities"])
                    this.topActivities!.push(ActivitySummaryDto.fromJS(item));
            }
            this.earnings = _data["earnings"] ? EarningsSectionDto.fromJS(_data["earnings"]) : new EarningsSectionDto();
            if (Array.isArray(_data["dailyBreakdown"])) {
                this.dailyBreakdown = [] as any;
                for (let item of _data["dailyBreakdown"])
                    this.dailyBreakdown!.push(DailyPointDto.fromJS(item));
            }
            this.avgHourlyRate = _data["avgHourlyRate"];
            this.daysWorked = _data["daysWorked"];
            this.bestDay = _data["bestDay"] ? new Date(_data["bestDay"].toString()) : <any>undefined;
            this.bestDayAmount = _data["bestDayAmount"];
        }
    }

    static fromJS(data: any): FinanceSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new FinanceSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["month"] = this.month;
        data["year"] = this.year;
        data["currency"] = this.currency;
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        data["totalEarn"] = this.totalEarn ? this.totalEarn.toJSON() : <any>undefined;
        if (Array.isArray(this.topContracts)) {
            data["topContracts"] = [];
            for (let item of this.topContracts)
                data["topContracts"].push(item.toJSON());
        }
        if (Array.isArray(this.topActivities)) {
            data["topActivities"] = [];
            for (let item of this.topActivities)
                data["topActivities"].push(item.toJSON());
        }
        data["earnings"] = this.earnings ? this.earnings.toJSON() : <any>undefined;
        if (Array.isArray(this.dailyBreakdown)) {
            data["dailyBreakdown"] = [];
            for (let item of this.dailyBreakdown)
                data["dailyBreakdown"].push(item.toJSON());
        }
        data["avgHourlyRate"] = this.avgHourlyRate;
        data["daysWorked"] = this.daysWorked;
        data["bestDay"] = this.bestDay ? this.bestDay.toISOString() : <any>undefined;
        data["bestDayAmount"] = this.bestDayAmount;
        return data;
    }
}

export interface IFinanceSummaryDto {
    month: number;
    year: number;
    currency: string;
    generatedAt: Date;
    totalEarn: TotalsDto;
    topContracts: ContractSummaryDto[];
    topActivities: ActivitySummaryDto[];
    earnings: EarningsSectionDto;
    dailyBreakdown: DailyPointDto[];
    avgHourlyRate: number;
    daysWorked: number;
    bestDay?: Date | undefined;
    bestDayAmount: number;
}

export class FixedEarnDto implements IFixedEarnDto {
    contractId!: string;
    contractLabel!: string;
    amount!: number;

    constructor(data?: IFixedEarnDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractId = _data["contractId"];
            this.contractLabel = _data["contractLabel"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): FixedEarnDto {
        data = typeof data === 'object' ? data : {};
        let result = new FixedEarnDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractId"] = this.contractId;
        data["contractLabel"] = this.contractLabel;
        data["amount"] = this.amount;
        return data;
    }
}

export interface IFixedEarnDto {
    contractId: string;
    contractLabel: string;
    amount: number;
}

export class ForceContractCancelCommand implements IForceContractCancelCommand {
    contractId?: string;
    reason?: string | undefined;

    constructor(data?: IForceContractCancelCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractId = _data["contractId"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): ForceContractCancelCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ForceContractCancelCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractId"] = this.contractId;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IForceContractCancelCommand {
    contractId?: string;
    reason?: string | undefined;
}

export class FreelancerAcceptContractCommand implements IFreelancerAcceptContractCommand {
    contractId?: string;

    constructor(data?: IFreelancerAcceptContractCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractId = _data["contractId"];
        }
    }

    static fromJS(data: any): FreelancerAcceptContractCommand {
        data = typeof data === 'object' ? data : {};
        let result = new FreelancerAcceptContractCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractId"] = this.contractId;
        return data;
    }
}

export interface IFreelancerAcceptContractCommand {
    contractId?: string;
}

export class FreelancerFinishContractCommand implements IFreelancerFinishContractCommand {
    contractId?: string;

    constructor(data?: IFreelancerFinishContractCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractId = _data["contractId"];
        }
    }

    static fromJS(data: any): FreelancerFinishContractCommand {
        data = typeof data === 'object' ? data : {};
        let result = new FreelancerFinishContractCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractId"] = this.contractId;
        return data;
    }
}

export interface IFreelancerFinishContractCommand {
    contractId?: string;
}

export class FreelancerProfileEntity implements IFreelancerProfileEntity {
    userId?: string;
    user?: UserEntity;
    skills?: SkillEntity[] | undefined;
    experience?: string | undefined;
    portfolioProjects?: PortfolioProjectEntity[] | undefined;
    resume?: string | undefined;
    costPerHour?: number;
    availability?: FreelancerProfileEntityAvailability;
    rating?: number;
    isHidden?: boolean;
    reviews?: JobReviewEntity[] | undefined;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: IFreelancerProfileEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserEntity.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(SkillEntity.fromJS(item));
            }
            this.experience = _data["experience"];
            if (Array.isArray(_data["portfolioProjects"])) {
                this.portfolioProjects = [] as any;
                for (let item of _data["portfolioProjects"])
                    this.portfolioProjects!.push(PortfolioProjectEntity.fromJS(item));
            }
            this.resume = _data["resume"];
            this.costPerHour = _data["costPerHour"];
            this.availability = _data["availability"];
            this.rating = _data["rating"];
            this.isHidden = _data["isHidden"];
            if (Array.isArray(_data["reviews"])) {
                this.reviews = [] as any;
                for (let item of _data["reviews"])
                    this.reviews!.push(JobReviewEntity.fromJS(item));
            }
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FreelancerProfileEntity {
        data = typeof data === 'object' ? data : {};
        let result = new FreelancerProfileEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item.toJSON());
        }
        data["experience"] = this.experience;
        if (Array.isArray(this.portfolioProjects)) {
            data["portfolioProjects"] = [];
            for (let item of this.portfolioProjects)
                data["portfolioProjects"].push(item.toJSON());
        }
        data["resume"] = this.resume;
        data["costPerHour"] = this.costPerHour;
        data["availability"] = this.availability;
        data["rating"] = this.rating;
        data["isHidden"] = this.isHidden;
        if (Array.isArray(this.reviews)) {
            data["reviews"] = [];
            for (let item of this.reviews)
                data["reviews"].push(item.toJSON());
        }
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IFreelancerProfileEntity {
    userId?: string;
    user?: UserEntity;
    skills?: SkillEntity[] | undefined;
    experience?: string | undefined;
    portfolioProjects?: PortfolioProjectEntity[] | undefined;
    resume?: string | undefined;
    costPerHour?: number;
    availability?: FreelancerProfileEntityAvailability;
    rating?: number;
    isHidden?: boolean;
    reviews?: JobReviewEntity[] | undefined;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class FreelancerStatsDto implements IFreelancerStatsDto {
    earningsLast12Months?: number;
    jobSuccessScore?: number;
    profileViews?: ProfileViewDto[] | undefined;
    proposals?: ProposalsDto;
    longTermClients?: number;
    shortTermClients?: number;

    constructor(data?: IFreelancerStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.earningsLast12Months = _data["earningsLast12Months"];
            this.jobSuccessScore = _data["jobSuccessScore"];
            if (Array.isArray(_data["profileViews"])) {
                this.profileViews = [] as any;
                for (let item of _data["profileViews"])
                    this.profileViews!.push(ProfileViewDto.fromJS(item));
            }
            this.proposals = _data["proposals"] ? ProposalsDto.fromJS(_data["proposals"]) : <any>undefined;
            this.longTermClients = _data["longTermClients"];
            this.shortTermClients = _data["shortTermClients"];
        }
    }

    static fromJS(data: any): FreelancerStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new FreelancerStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["earningsLast12Months"] = this.earningsLast12Months;
        data["jobSuccessScore"] = this.jobSuccessScore;
        if (Array.isArray(this.profileViews)) {
            data["profileViews"] = [];
            for (let item of this.profileViews)
                data["profileViews"].push(item.toJSON());
        }
        data["proposals"] = this.proposals ? this.proposals.toJSON() : <any>undefined;
        data["longTermClients"] = this.longTermClients;
        data["shortTermClients"] = this.shortTermClients;
        return data;
    }
}

export interface IFreelancerStatsDto {
    earningsLast12Months?: number;
    jobSuccessScore?: number;
    profileViews?: ProfileViewDto[] | undefined;
    proposals?: ProposalsDto;
    longTermClients?: number;
    shortTermClients?: number;
}

export class FreelancerTeamEntity implements IFreelancerTeamEntity {
    name?: string | undefined;
    participants?: UserEntity[] | undefined;
    readonly closed?: boolean;
    readonly closedReason?: string | undefined;
    avatarId?: string;
    avatar?: FileEntity;
    owner?: UserEntity;
    ownerId?: string;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: IFreelancerTeamEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["participants"])) {
                this.participants = [] as any;
                for (let item of _data["participants"])
                    this.participants!.push(UserEntity.fromJS(item));
            }
            (<any>this).closed = _data["closed"];
            (<any>this).closedReason = _data["closedReason"];
            this.avatarId = _data["avatarId"];
            this.avatar = _data["avatar"] ? FileEntity.fromJS(_data["avatar"]) : <any>undefined;
            this.owner = _data["owner"] ? UserEntity.fromJS(_data["owner"]) : <any>undefined;
            this.ownerId = _data["ownerId"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FreelancerTeamEntity {
        data = typeof data === 'object' ? data : {};
        let result = new FreelancerTeamEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.participants)) {
            data["participants"] = [];
            for (let item of this.participants)
                data["participants"].push(item.toJSON());
        }
        data["closed"] = this.closed;
        data["closedReason"] = this.closedReason;
        data["avatarId"] = this.avatarId;
        data["avatar"] = this.avatar ? this.avatar.toJSON() : <any>undefined;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["ownerId"] = this.ownerId;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IFreelancerTeamEntity {
    name?: string | undefined;
    participants?: UserEntity[] | undefined;
    closed?: boolean;
    closedReason?: string | undefined;
    avatarId?: string;
    avatar?: FileEntity;
    owner?: UserEntity;
    ownerId?: string;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class GatewayResultCommand implements IGatewayResultCommand {
    success!: boolean;
    gatewayTransactionId!: string;
    internalTransactionId!: string;
    customId?: string | undefined;
    amount!: number;
    fee!: number;
    currency!: GatewayResultCommandCurrency;
    status?: string | undefined;
    failureReason?: string | undefined;
    metadata?: { [key: string]: string; } | undefined;

    constructor(data?: IGatewayResultCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.gatewayTransactionId = _data["gatewayTransactionId"];
            this.internalTransactionId = _data["internalTransactionId"];
            this.customId = _data["customId"];
            this.amount = _data["amount"];
            this.fee = _data["fee"];
            this.currency = _data["currency"];
            this.status = _data["status"];
            this.failureReason = _data["failureReason"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
        }
    }

    static fromJS(data: any): GatewayResultCommand {
        data = typeof data === 'object' ? data : {};
        let result = new GatewayResultCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["gatewayTransactionId"] = this.gatewayTransactionId;
        data["internalTransactionId"] = this.internalTransactionId;
        data["customId"] = this.customId;
        data["amount"] = this.amount;
        data["fee"] = this.fee;
        data["currency"] = this.currency;
        data["status"] = this.status;
        data["failureReason"] = this.failureReason;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        return data;
    }
}

export interface IGatewayResultCommand {
    success: boolean;
    gatewayTransactionId: string;
    internalTransactionId: string;
    customId?: string | undefined;
    amount: number;
    fee: number;
    currency: GatewayResultCommandCurrency;
    status?: string | undefined;
    failureReason?: string | undefined;
    metadata?: { [key: string]: string; } | undefined;
}

export class GetContractsListQuery implements IGetContractsListQuery {
    userId?: string | undefined;
    isClient?: boolean | undefined;
    status?: GetContractsListQueryStatus | undefined;
    start?: number;
    ends?: number;

    constructor(data?: IGetContractsListQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.isClient = _data["isClient"];
            this.status = _data["status"];
            this.start = _data["start"];
            this.ends = _data["ends"];
        }
    }

    static fromJS(data: any): GetContractsListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetContractsListQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["isClient"] = this.isClient;
        data["status"] = this.status;
        data["start"] = this.start;
        data["ends"] = this.ends;
        return data;
    }
}

export interface IGetContractsListQuery {
    userId?: string | undefined;
    isClient?: boolean | undefined;
    status?: GetContractsListQueryStatus | undefined;
    start?: number;
    ends?: number;
}

export class GetFinanceSummaryQuery implements IGetFinanceSummaryQuery {
    readonly month?: number;
    readonly year?: number;
    readonly userId?: string | undefined;

    constructor(data?: IGetFinanceSummaryQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).month = _data["month"];
            (<any>this).year = _data["year"];
            (<any>this).userId = _data["userId"];
        }
    }

    static fromJS(data: any): GetFinanceSummaryQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetFinanceSummaryQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["month"] = this.month;
        data["year"] = this.year;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IGetFinanceSummaryQuery {
    month?: number;
    year?: number;
    userId?: string | undefined;
}

export class GetJobsListQuery implements IGetJobsListQuery {
    start?: number;
    ends?: number;
    search?: string | undefined;
    categoryId?: string | undefined;
    levels?: Levels[] | undefined;
    isHourly?: boolean | undefined;
    minBudget?: number | undefined;
    maxBudget?: number | undefined;
    minHourlyRate?: number | undefined;
    maxHourlyRate?: number | undefined;
    minProposals?: number | undefined;
    maxProposals?: number | undefined;
    minDurationDays?: number | undefined;
    maxDurationDays?: number | undefined;
    employerLocation?: GetJobsListQueryEmployerLocation | undefined;
    statuses?: Statuses[] | undefined;
    sortType?: GetJobsListQuerySortType | undefined;
    sortOption?: GetJobsListQuerySortOption | undefined;
    clientId?: string | undefined;
    freelancerId?: string | undefined;
    recommended?: boolean | undefined;

    constructor(data?: IGetJobsListQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start = _data["start"];
            this.ends = _data["ends"];
            this.search = _data["search"];
            this.categoryId = _data["categoryId"];
            if (Array.isArray(_data["levels"])) {
                this.levels = [] as any;
                for (let item of _data["levels"])
                    this.levels!.push(item);
            }
            this.isHourly = _data["isHourly"];
            this.minBudget = _data["minBudget"];
            this.maxBudget = _data["maxBudget"];
            this.minHourlyRate = _data["minHourlyRate"];
            this.maxHourlyRate = _data["maxHourlyRate"];
            this.minProposals = _data["minProposals"];
            this.maxProposals = _data["maxProposals"];
            this.minDurationDays = _data["minDurationDays"];
            this.maxDurationDays = _data["maxDurationDays"];
            this.employerLocation = _data["employerLocation"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(item);
            }
            this.sortType = _data["sortType"];
            this.sortOption = _data["sortOption"];
            this.clientId = _data["clientId"];
            this.freelancerId = _data["freelancerId"];
            this.recommended = _data["recommended"];
        }
    }

    static fromJS(data: any): GetJobsListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetJobsListQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start;
        data["ends"] = this.ends;
        data["search"] = this.search;
        data["categoryId"] = this.categoryId;
        if (Array.isArray(this.levels)) {
            data["levels"] = [];
            for (let item of this.levels)
                data["levels"].push(item);
        }
        data["isHourly"] = this.isHourly;
        data["minBudget"] = this.minBudget;
        data["maxBudget"] = this.maxBudget;
        data["minHourlyRate"] = this.minHourlyRate;
        data["maxHourlyRate"] = this.maxHourlyRate;
        data["minProposals"] = this.minProposals;
        data["maxProposals"] = this.maxProposals;
        data["minDurationDays"] = this.minDurationDays;
        data["maxDurationDays"] = this.maxDurationDays;
        data["employerLocation"] = this.employerLocation;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item);
        }
        data["sortType"] = this.sortType;
        data["sortOption"] = this.sortOption;
        data["clientId"] = this.clientId;
        data["freelancerId"] = this.freelancerId;
        data["recommended"] = this.recommended;
        return data;
    }
}

export interface IGetJobsListQuery {
    start?: number;
    ends?: number;
    search?: string | undefined;
    categoryId?: string | undefined;
    levels?: Levels[] | undefined;
    isHourly?: boolean | undefined;
    minBudget?: number | undefined;
    maxBudget?: number | undefined;
    minHourlyRate?: number | undefined;
    maxHourlyRate?: number | undefined;
    minProposals?: number | undefined;
    maxProposals?: number | undefined;
    minDurationDays?: number | undefined;
    maxDurationDays?: number | undefined;
    employerLocation?: GetJobsListQueryEmployerLocation | undefined;
    statuses?: Statuses[] | undefined;
    sortType?: GetJobsListQuerySortType | undefined;
    sortOption?: GetJobsListQuerySortOption | undefined;
    clientId?: string | undefined;
    freelancerId?: string | undefined;
    recommended?: boolean | undefined;
}

export class GetTicketsDto implements IGetTicketsDto {
    userId?: string | undefined;
    subject?: string | undefined;
    isAssignedToMe?: boolean | undefined;
    start?: number;
    ends?: number;

    constructor(data?: IGetTicketsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.subject = _data["subject"];
            this.isAssignedToMe = _data["isAssignedToMe"];
            this.start = _data["start"];
            this.ends = _data["ends"];
        }
    }

    static fromJS(data: any): GetTicketsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["subject"] = this.subject;
        data["isAssignedToMe"] = this.isAssignedToMe;
        data["start"] = this.start;
        data["ends"] = this.ends;
        return data;
    }
}

export interface IGetTicketsDto {
    userId?: string | undefined;
    subject?: string | undefined;
    isAssignedToMe?: boolean | undefined;
    start?: number;
    ends?: number;
}

export class GetTransactionsListQuery implements IGetTransactionsListQuery {
    start?: number;
    ends?: number;
    fromDate?: Date | undefined;
    toDate?: Date | undefined;
    operation?: GetTransactionsListQueryOperation | undefined;
    flow?: GetTransactionsListQueryFlow | undefined;
    transactionProvider?: string | undefined;
    walletId?: string | undefined;
    priceRange?: number[] | undefined;
    status?: GetTransactionsListQueryStatus | undefined;

    constructor(data?: IGetTransactionsListQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start = _data["start"];
            this.ends = _data["ends"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.operation = _data["operation"];
            this.flow = _data["flow"];
            this.transactionProvider = _data["transactionProvider"];
            this.walletId = _data["walletId"];
            if (Array.isArray(_data["priceRange"])) {
                this.priceRange = [] as any;
                for (let item of _data["priceRange"])
                    this.priceRange!.push(item);
            }
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): GetTransactionsListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetTransactionsListQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start;
        data["ends"] = this.ends;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["operation"] = this.operation;
        data["flow"] = this.flow;
        data["transactionProvider"] = this.transactionProvider;
        data["walletId"] = this.walletId;
        if (Array.isArray(this.priceRange)) {
            data["priceRange"] = [];
            for (let item of this.priceRange)
                data["priceRange"].push(item);
        }
        data["status"] = this.status;
        return data;
    }
}

export interface IGetTransactionsListQuery {
    start?: number;
    ends?: number;
    fromDate?: Date | undefined;
    toDate?: Date | undefined;
    operation?: GetTransactionsListQueryOperation | undefined;
    flow?: GetTransactionsListQueryFlow | undefined;
    transactionProvider?: string | undefined;
    walletId?: string | undefined;
    priceRange?: number[] | undefined;
    status?: GetTransactionsListQueryStatus | undefined;
}

export class GetUsersListQuery implements IGetUsersListQuery {
    searchTerm?: string | undefined;
    role?: GetUsersListQueryRole | undefined;
    advancedFilters?: string | undefined;
    start?: number;
    ends?: number;

    constructor(data?: IGetUsersListQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchTerm = _data["searchTerm"];
            this.role = _data["role"];
            this.advancedFilters = _data["advancedFilters"];
            this.start = _data["start"];
            this.ends = _data["ends"];
        }
    }

    static fromJS(data: any): GetUsersListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetUsersListQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchTerm"] = this.searchTerm;
        data["role"] = this.role;
        data["advancedFilters"] = this.advancedFilters;
        data["start"] = this.start;
        data["ends"] = this.ends;
        return data;
    }
}

export interface IGetUsersListQuery {
    searchTerm?: string | undefined;
    role?: GetUsersListQueryRole | undefined;
    advancedFilters?: string | undefined;
    start?: number;
    ends?: number;
}

export class GetWorkSessionListQuery implements IGetWorkSessionListQuery {
    userId?: string | undefined;
    contractId?: string | undefined;
    start?: number;
    ends?: number;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    status?: GetWorkSessionListQueryStatus | undefined;

    constructor(data?: IGetWorkSessionListQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.contractId = _data["contractId"];
            this.start = _data["start"];
            this.ends = _data["ends"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): GetWorkSessionListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetWorkSessionListQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["contractId"] = this.contractId;
        data["start"] = this.start;
        data["ends"] = this.ends;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data;
    }
}

export interface IGetWorkSessionListQuery {
    userId?: string | undefined;
    contractId?: string | undefined;
    start?: number;
    ends?: number;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    status?: GetWorkSessionListQueryStatus | undefined;
}

export class HandleTransactionCommand implements IHandleTransactionCommand {
    transactionId!: string;

    constructor(data?: IHandleTransactionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionId = _data["transactionId"];
        }
    }

    static fromJS(data: any): HandleTransactionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new HandleTransactionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        return data;
    }
}

export interface IHandleTransactionCommand {
    transactionId: string;
}

export class HideFreelancerProfileCommand implements IHideFreelancerProfileCommand {
    userId?: string;

    constructor(data?: IHideFreelancerProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): HideFreelancerProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new HideFreelancerProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        return data;
    }
}

export interface IHideFreelancerProfileCommand {
    userId?: string;
}

export class HideJobCommand implements IHideJobCommand {
    jobId?: string;

    constructor(data?: IHideJobCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
        }
    }

    static fromJS(data: any): HideJobCommand {
        data = typeof data === 'object' ? data : {};
        let result = new HideJobCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        return data;
    }
}

export interface IHideJobCommand {
    jobId?: string;
}

export class HideNotificationsCommand implements IHideNotificationsCommand {
    notificationIds?: string[] | undefined;

    constructor(data?: IHideNotificationsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["notificationIds"])) {
                this.notificationIds = [] as any;
                for (let item of _data["notificationIds"])
                    this.notificationIds!.push(item);
            }
        }
    }

    static fromJS(data: any): HideNotificationsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new HideNotificationsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.notificationIds)) {
            data["notificationIds"] = [];
            for (let item of this.notificationIds)
                data["notificationIds"].push(item);
        }
        return data;
    }
}

export interface IHideNotificationsCommand {
    notificationIds?: string[] | undefined;
}

export class InitiateDisputeCommand implements IInitiateDisputeCommand {
    contractId?: string;
    reason?: string | undefined;

    constructor(data?: IInitiateDisputeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractId = _data["contractId"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): InitiateDisputeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new InitiateDisputeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractId"] = this.contractId;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IInitiateDisputeCommand {
    contractId?: string;
    reason?: string | undefined;
}

export class InviteMemberDto implements IInviteMemberDto {
    chatId?: string;
    userId?: string;
    owner?: boolean;

    constructor(data?: IInviteMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatId = _data["chatId"];
            this.userId = _data["userId"];
            this.owner = _data["owner"];
        }
    }

    static fromJS(data: any): InviteMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new InviteMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatId"] = this.chatId;
        data["userId"] = this.userId;
        data["owner"] = this.owner;
        return data;
    }
}

export interface IInviteMemberDto {
    chatId?: string;
    userId?: string;
    owner?: boolean;
}

export class JobDetails implements IJobDetails {
    jobId?: string;
    title?: string | undefined;
    description?: string | undefined;
    status?: JobDetailsStatus;
    budget?: Money;
    currency?: JobDetailsCurrency;
    category?: string | undefined;
    categorySlug?: string | undefined;
    skills?: string[] | undefined;
    languages?: string[] | undefined;
    clientName?: string | undefined;
    clientAvatarUrl?: string | undefined;
    isClientVerified?: boolean;
    createdAt?: Date;
    deadline?: Date | undefined;
    responsesRangeMin?: number;
    responsesRangeMax?: number;
    dailyResponsesMin?: number;
    dailyResponsesMax?: number;
    confirmedResponses?: number;
    views?: number;

    constructor(data?: IJobDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.budget = _data["budget"] ? Money.fromJS(_data["budget"]) : <any>undefined;
            this.currency = _data["currency"];
            this.category = _data["category"];
            this.categorySlug = _data["categorySlug"];
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(item);
            }
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(item);
            }
            this.clientName = _data["clientName"];
            this.clientAvatarUrl = _data["clientAvatarUrl"];
            this.isClientVerified = _data["isClientVerified"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.deadline = _data["deadline"] ? new Date(_data["deadline"].toString()) : <any>undefined;
            this.responsesRangeMin = _data["responsesRangeMin"];
            this.responsesRangeMax = _data["responsesRangeMax"];
            this.dailyResponsesMin = _data["dailyResponsesMin"];
            this.dailyResponsesMax = _data["dailyResponsesMax"];
            this.confirmedResponses = _data["confirmedResponses"];
            this.views = _data["views"];
        }
    }

    static fromJS(data: any): JobDetails {
        data = typeof data === 'object' ? data : {};
        let result = new JobDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["status"] = this.status;
        data["budget"] = this.budget ? this.budget.toJSON() : <any>undefined;
        data["currency"] = this.currency;
        data["category"] = this.category;
        data["categorySlug"] = this.categorySlug;
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item);
        }
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item);
        }
        data["clientName"] = this.clientName;
        data["clientAvatarUrl"] = this.clientAvatarUrl;
        data["isClientVerified"] = this.isClientVerified;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["deadline"] = this.deadline ? this.deadline.toISOString() : <any>undefined;
        data["responsesRangeMin"] = this.responsesRangeMin;
        data["responsesRangeMax"] = this.responsesRangeMax;
        data["dailyResponsesMin"] = this.dailyResponsesMin;
        data["dailyResponsesMax"] = this.dailyResponsesMax;
        data["confirmedResponses"] = this.confirmedResponses;
        data["views"] = this.views;
        return data;
    }
}

export interface IJobDetails {
    jobId?: string;
    title?: string | undefined;
    description?: string | undefined;
    status?: JobDetailsStatus;
    budget?: Money;
    currency?: JobDetailsCurrency;
    category?: string | undefined;
    categorySlug?: string | undefined;
    skills?: string[] | undefined;
    languages?: string[] | undefined;
    clientName?: string | undefined;
    clientAvatarUrl?: string | undefined;
    isClientVerified?: boolean;
    createdAt?: Date;
    deadline?: Date | undefined;
    responsesRangeMin?: number;
    responsesRangeMax?: number;
    dailyResponsesMin?: number;
    dailyResponsesMax?: number;
    confirmedResponses?: number;
    views?: number;
}

export class JobEntity implements IJobEntity {
    employerId?: string;
    employer?: UserEntity;
    title?: string | undefined;
    description?: string | undefined;
    requiredSkills?: SkillEntity[] | undefined;
    category?: CategoryEntity;
    categoryId?: string;
    payout?: Money;
    expirationDate?: Date | undefined;
    duration?: number | undefined;
    status?: JobEntityStatus;
    proposals?: ProposalEntity[] | undefined;
    level?: JobEntityLevel;
    budgetType?: JobEntityBudgetType;
    publicationDate?: Date | undefined;
    paymentVerified?: boolean;
    readonly contractId?: string | undefined;
    readonly files?: FileEntity[] | undefined;
    isHidden?: boolean;
    chats?: ChatEntity[] | undefined;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: IJobEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employerId = _data["employerId"];
            this.employer = _data["employer"] ? UserEntity.fromJS(_data["employer"]) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["requiredSkills"])) {
                this.requiredSkills = [] as any;
                for (let item of _data["requiredSkills"])
                    this.requiredSkills!.push(SkillEntity.fromJS(item));
            }
            this.category = _data["category"] ? CategoryEntity.fromJS(_data["category"]) : <any>undefined;
            this.categoryId = _data["categoryId"];
            this.payout = _data["payout"] ? Money.fromJS(_data["payout"]) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            this.status = _data["status"];
            if (Array.isArray(_data["proposals"])) {
                this.proposals = [] as any;
                for (let item of _data["proposals"])
                    this.proposals!.push(ProposalEntity.fromJS(item));
            }
            this.level = _data["level"];
            this.budgetType = _data["budgetType"];
            this.publicationDate = _data["publicationDate"] ? new Date(_data["publicationDate"].toString()) : <any>undefined;
            this.paymentVerified = _data["paymentVerified"];
            (<any>this).contractId = _data["contractId"];
            if (Array.isArray(_data["files"])) {
                (<any>this).files = [] as any;
                for (let item of _data["files"])
                    (<any>this).files!.push(FileEntity.fromJS(item));
            }
            this.isHidden = _data["isHidden"];
            if (Array.isArray(_data["chats"])) {
                this.chats = [] as any;
                for (let item of _data["chats"])
                    this.chats!.push(ChatEntity.fromJS(item));
            }
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): JobEntity {
        data = typeof data === 'object' ? data : {};
        let result = new JobEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employerId"] = this.employerId;
        data["employer"] = this.employer ? this.employer.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.requiredSkills)) {
            data["requiredSkills"] = [];
            for (let item of this.requiredSkills)
                data["requiredSkills"].push(item.toJSON());
        }
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["payout"] = this.payout ? this.payout.toJSON() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["duration"] = this.duration;
        data["status"] = this.status;
        if (Array.isArray(this.proposals)) {
            data["proposals"] = [];
            for (let item of this.proposals)
                data["proposals"].push(item.toJSON());
        }
        data["level"] = this.level;
        data["budgetType"] = this.budgetType;
        data["publicationDate"] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
        data["paymentVerified"] = this.paymentVerified;
        data["contractId"] = this.contractId;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["isHidden"] = this.isHidden;
        if (Array.isArray(this.chats)) {
            data["chats"] = [];
            for (let item of this.chats)
                data["chats"].push(item.toJSON());
        }
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IJobEntity {
    employerId?: string;
    employer?: UserEntity;
    title?: string | undefined;
    description?: string | undefined;
    requiredSkills?: SkillEntity[] | undefined;
    category?: CategoryEntity;
    categoryId?: string;
    payout?: Money;
    expirationDate?: Date | undefined;
    duration?: number | undefined;
    status?: JobEntityStatus;
    proposals?: ProposalEntity[] | undefined;
    level?: JobEntityLevel;
    budgetType?: JobEntityBudgetType;
    publicationDate?: Date | undefined;
    paymentVerified?: boolean;
    contractId?: string | undefined;
    files?: FileEntity[] | undefined;
    isHidden?: boolean;
    chats?: ChatEntity[] | undefined;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class JobReviewEntity implements IJobReviewEntity {
    reviewerId!: string;
    reviewer!: UserEntity;
    targetId!: string;
    target!: UserEntity;
    jobId!: string;
    job!: JobEntity;
    readonly rating!: number;
    comment!: string;
    reviewDate!: Date;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: IJobReviewEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.reviewer = new UserEntity();
            this.target = new UserEntity();
            this.job = new JobEntity();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reviewerId = _data["reviewerId"];
            this.reviewer = _data["reviewer"] ? UserEntity.fromJS(_data["reviewer"]) : new UserEntity();
            this.targetId = _data["targetId"];
            this.target = _data["target"] ? UserEntity.fromJS(_data["target"]) : new UserEntity();
            this.jobId = _data["jobId"];
            this.job = _data["job"] ? JobEntity.fromJS(_data["job"]) : new JobEntity();
            (<any>this).rating = _data["rating"];
            this.comment = _data["comment"];
            this.reviewDate = _data["reviewDate"] ? new Date(_data["reviewDate"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): JobReviewEntity {
        data = typeof data === 'object' ? data : {};
        let result = new JobReviewEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewerId"] = this.reviewerId;
        data["reviewer"] = this.reviewer ? this.reviewer.toJSON() : <any>undefined;
        data["targetId"] = this.targetId;
        data["target"] = this.target ? this.target.toJSON() : <any>undefined;
        data["jobId"] = this.jobId;
        data["job"] = this.job ? this.job.toJSON() : <any>undefined;
        data["rating"] = this.rating;
        data["comment"] = this.comment;
        data["reviewDate"] = this.reviewDate ? this.reviewDate.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IJobReviewEntity {
    reviewerId: string;
    reviewer: UserEntity;
    targetId: string;
    target: UserEntity;
    jobId: string;
    job: JobEntity;
    rating: number;
    comment: string;
    reviewDate: Date;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class KickMemberDto implements IKickMemberDto {
    chatId?: string;
    userId?: string;

    constructor(data?: IKickMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatId = _data["chatId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): KickMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new KickMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatId"] = this.chatId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IKickMemberDto {
    chatId?: string;
    userId?: string;
}

export class LoginUserSchema implements ILoginUserSchema {
    email!: string;
    password!: string;
    rememberMe?: boolean;

    constructor(data?: ILoginUserSchema) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.rememberMe = _data["rememberMe"];
        }
    }

    static fromJS(data: any): LoginUserSchema {
        data = typeof data === 'object' ? data : {};
        let result = new LoginUserSchema();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        return data;
    }
}

export interface ILoginUserSchema {
    email: string;
    password: string;
    rememberMe?: boolean;
}

export class MarkAsReadDto implements IMarkAsReadDto {
    chatId?: string;

    constructor(data?: IMarkAsReadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatId = _data["chatId"];
        }
    }

    static fromJS(data: any): MarkAsReadDto {
        data = typeof data === 'object' ? data : {};
        let result = new MarkAsReadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatId"] = this.chatId;
        return data;
    }
}

export interface IMarkAsReadDto {
    chatId?: string;
}

export class MessageEntity implements IMessageEntity {
    senderId?: string;
    sender?: UserEntity;
    text?: string | undefined;
    isDeleted?: boolean;
    chatId?: string;
    sentDate?: Date;
    isPinned?: boolean;
    replyedToMessageId?: string | undefined;
    files?: FileEntity[] | undefined;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: IMessageEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.senderId = _data["senderId"];
            this.sender = _data["sender"] ? UserEntity.fromJS(_data["sender"]) : <any>undefined;
            this.text = _data["text"];
            this.isDeleted = _data["isDeleted"];
            this.chatId = _data["chatId"];
            this.sentDate = _data["sentDate"] ? new Date(_data["sentDate"].toString()) : <any>undefined;
            this.isPinned = _data["isPinned"];
            this.replyedToMessageId = _data["replyedToMessageId"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(FileEntity.fromJS(item));
            }
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MessageEntity {
        data = typeof data === 'object' ? data : {};
        let result = new MessageEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["senderId"] = this.senderId;
        data["sender"] = this.sender ? this.sender.toJSON() : <any>undefined;
        data["text"] = this.text;
        data["isDeleted"] = this.isDeleted;
        data["chatId"] = this.chatId;
        data["sentDate"] = this.sentDate ? this.sentDate.toISOString() : <any>undefined;
        data["isPinned"] = this.isPinned;
        data["replyedToMessageId"] = this.replyedToMessageId;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IMessageEntity {
    senderId?: string;
    sender?: UserEntity;
    text?: string | undefined;
    isDeleted?: boolean;
    chatId?: string;
    sentDate?: Date;
    isPinned?: boolean;
    replyedToMessageId?: string | undefined;
    files?: FileEntity[] | undefined;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class MessageReadEntity implements IMessageReadEntity {
    readonly readById?: string;
    readBy?: UserEntity;
    readonly chatId?: string;
    readonly readAt?: Date;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: IMessageReadEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).readById = _data["readById"];
            this.readBy = _data["readBy"] ? UserEntity.fromJS(_data["readBy"]) : <any>undefined;
            (<any>this).chatId = _data["chatId"];
            (<any>this).readAt = _data["readAt"] ? new Date(_data["readAt"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MessageReadEntity {
        data = typeof data === 'object' ? data : {};
        let result = new MessageReadEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["readById"] = this.readById;
        data["readBy"] = this.readBy ? this.readBy.toJSON() : <any>undefined;
        data["chatId"] = this.chatId;
        data["readAt"] = this.readAt ? this.readAt.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IMessageReadEntity {
    readById?: string;
    readBy?: UserEntity;
    chatId?: string;
    readAt?: Date;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class MessageThreadDto implements IMessageThreadDto {
    messageId?: string;
    replyToId?: string;

    constructor(data?: IMessageThreadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.messageId = _data["messageId"];
            this.replyToId = _data["replyToId"];
        }
    }

    static fromJS(data: any): MessageThreadDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageThreadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["messageId"] = this.messageId;
        data["replyToId"] = this.replyToId;
        return data;
    }
}

export interface IMessageThreadDto {
    messageId?: string;
    replyToId?: string;
}

export class Money implements IMoney {
    amount!: number;
    currency!: MoneyCurrency;

    constructor(data?: IMoney) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.currency = _data["currency"];
        }
    }

    static fromJS(data: any): Money {
        data = typeof data === 'object' ? data : {};
        let result = new Money();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["currency"] = this.currency;
        return data;
    }
}

export interface IMoney {
    amount: number;
    currency: MoneyCurrency;
}

export class NewsEntity implements INewsEntity {
    text!: string;
    attachments?: FileEntity[] | undefined;
    title!: string;
    isHidden!: boolean;
    publishTime!: Date;
    changeNotes!: boolean;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: INewsEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(FileEntity.fromJS(item));
            }
            this.title = _data["title"];
            this.isHidden = _data["isHidden"];
            this.publishTime = _data["publishTime"] ? new Date(_data["publishTime"].toString()) : <any>undefined;
            this.changeNotes = _data["changeNotes"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NewsEntity {
        data = typeof data === 'object' ? data : {};
        let result = new NewsEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        data["title"] = this.title;
        data["isHidden"] = this.isHidden;
        data["publishTime"] = this.publishTime ? this.publishTime.toISOString() : <any>undefined;
        data["changeNotes"] = this.changeNotes;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface INewsEntity {
    text: string;
    attachments?: FileEntity[] | undefined;
    title: string;
    isHidden: boolean;
    publishTime: Date;
    changeNotes: boolean;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class NotificationEntity implements INotificationEntity {
    title!: string;
    text!: string;
    fromUserId?: string | undefined;
    toUserId!: string;
    type!: NotificationEntityType;
    data?: string | undefined;
    hidden!: boolean;
    icon?: FileEntity;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: INotificationEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.text = _data["text"];
            this.fromUserId = _data["fromUserId"];
            this.toUserId = _data["toUserId"];
            this.type = _data["type"];
            this.data = _data["data"];
            this.hidden = _data["hidden"];
            this.icon = _data["icon"] ? FileEntity.fromJS(_data["icon"]) : <any>undefined;
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NotificationEntity {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["text"] = this.text;
        data["fromUserId"] = this.fromUserId;
        data["toUserId"] = this.toUserId;
        data["type"] = this.type;
        data["data"] = this.data;
        data["hidden"] = this.hidden;
        data["icon"] = this.icon ? this.icon.toJSON() : <any>undefined;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface INotificationEntity {
    title: string;
    text: string;
    fromUserId?: string | undefined;
    toUserId: string;
    type: NotificationEntityType;
    data?: string | undefined;
    hidden: boolean;
    icon?: FileEntity;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class NotificationSettings implements INotificationSettings {
    readonly desktopNotificationsEnabled?: boolean;
    readonly desktopBadgeCountEnabled?: boolean;
    readonly webNotificationsEnabled?: boolean;
    readonly webBadgeCountEnabled?: boolean;
    readonly emailNotificationsEnabled?: boolean;
    readonly emailWhenOfflineEnabled?: boolean;
    readonly pushNotificationsEnabled?: boolean;
    readonly pushWhenOfflineEnabled?: boolean;
    readonly dailySummaryEmailEnabled?: boolean;
    readonly doNotDisturbStart?: string | undefined;
    readonly doNotDisturbEnd?: string | undefined;
    readonly preferredLanguage?: string | undefined;

    constructor(data?: INotificationSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).desktopNotificationsEnabled = _data["desktopNotificationsEnabled"];
            (<any>this).desktopBadgeCountEnabled = _data["desktopBadgeCountEnabled"];
            (<any>this).webNotificationsEnabled = _data["webNotificationsEnabled"];
            (<any>this).webBadgeCountEnabled = _data["webBadgeCountEnabled"];
            (<any>this).emailNotificationsEnabled = _data["emailNotificationsEnabled"];
            (<any>this).emailWhenOfflineEnabled = _data["emailWhenOfflineEnabled"];
            (<any>this).pushNotificationsEnabled = _data["pushNotificationsEnabled"];
            (<any>this).pushWhenOfflineEnabled = _data["pushWhenOfflineEnabled"];
            (<any>this).dailySummaryEmailEnabled = _data["dailySummaryEmailEnabled"];
            (<any>this).doNotDisturbStart = _data["doNotDisturbStart"];
            (<any>this).doNotDisturbEnd = _data["doNotDisturbEnd"];
            (<any>this).preferredLanguage = _data["preferredLanguage"];
        }
    }

    static fromJS(data: any): NotificationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["desktopNotificationsEnabled"] = this.desktopNotificationsEnabled;
        data["desktopBadgeCountEnabled"] = this.desktopBadgeCountEnabled;
        data["webNotificationsEnabled"] = this.webNotificationsEnabled;
        data["webBadgeCountEnabled"] = this.webBadgeCountEnabled;
        data["emailNotificationsEnabled"] = this.emailNotificationsEnabled;
        data["emailWhenOfflineEnabled"] = this.emailWhenOfflineEnabled;
        data["pushNotificationsEnabled"] = this.pushNotificationsEnabled;
        data["pushWhenOfflineEnabled"] = this.pushWhenOfflineEnabled;
        data["dailySummaryEmailEnabled"] = this.dailySummaryEmailEnabled;
        data["doNotDisturbStart"] = this.doNotDisturbStart;
        data["doNotDisturbEnd"] = this.doNotDisturbEnd;
        data["preferredLanguage"] = this.preferredLanguage;
        return data;
    }
}

export interface INotificationSettings {
    desktopNotificationsEnabled?: boolean;
    desktopBadgeCountEnabled?: boolean;
    webNotificationsEnabled?: boolean;
    webBadgeCountEnabled?: boolean;
    emailNotificationsEnabled?: boolean;
    emailWhenOfflineEnabled?: boolean;
    pushNotificationsEnabled?: boolean;
    pushWhenOfflineEnabled?: boolean;
    dailySummaryEmailEnabled?: boolean;
    doNotDisturbStart?: string | undefined;
    doNotDisturbEnd?: string | undefined;
    preferredLanguage?: string | undefined;
}

export class PaymentMethodDto implements IPaymentMethodDto {
    id?: string;
    providerId?: string;
    brand?: string | undefined;
    maskedPan?: string | undefined;
    expMonth?: number;
    expYear?: number;
    isDefault?: boolean;

    constructor(data?: IPaymentMethodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.providerId = _data["providerId"];
            this.brand = _data["brand"];
            this.maskedPan = _data["maskedPan"];
            this.expMonth = _data["expMonth"];
            this.expYear = _data["expYear"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): PaymentMethodDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["providerId"] = this.providerId;
        data["brand"] = this.brand;
        data["maskedPan"] = this.maskedPan;
        data["expMonth"] = this.expMonth;
        data["expYear"] = this.expYear;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IPaymentMethodDto {
    id?: string;
    providerId?: string;
    brand?: string | undefined;
    maskedPan?: string | undefined;
    expMonth?: number;
    expYear?: number;
    isDefault?: boolean;
}

export class PaymentSystemEntity implements IPaymentSystemEntity {
    name!: string;
    isActive?: boolean;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: IPaymentSystemEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PaymentSystemEntity {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentSystemEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IPaymentSystemEntity {
    name: string;
    isActive?: boolean;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class PinMessageDto implements IPinMessageDto {
    messageId?: string;

    constructor(data?: IPinMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.messageId = _data["messageId"];
        }
    }

    static fromJS(data: any): PinMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new PinMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["messageId"] = this.messageId;
        return data;
    }
}

export interface IPinMessageDto {
    messageId?: string;
}

export class PortfolioProjectEntity implements IPortfolioProjectEntity {
    name?: string | undefined;
    userRole?: string | undefined;
    skills?: SkillEntity[] | undefined;
    description?: string | undefined;
    images?: FileEntity[] | undefined;
    hidden?: boolean;
    userId?: string;
    user?: UserEntity;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: IPortfolioProjectEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.userRole = _data["userRole"];
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(SkillEntity.fromJS(item));
            }
            this.description = _data["description"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(FileEntity.fromJS(item));
            }
            this.hidden = _data["hidden"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserEntity.fromJS(_data["user"]) : <any>undefined;
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PortfolioProjectEntity {
        data = typeof data === 'object' ? data : {};
        let result = new PortfolioProjectEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["userRole"] = this.userRole;
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item.toJSON());
        }
        data["description"] = this.description;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["hidden"] = this.hidden;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IPortfolioProjectEntity {
    name?: string | undefined;
    userRole?: string | undefined;
    skills?: SkillEntity[] | undefined;
    description?: string | undefined;
    images?: FileEntity[] | undefined;
    hidden?: boolean;
    userId?: string;
    user?: UserEntity;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class ProfileViewDto implements IProfileViewDto {
    date?: string | undefined;
    count?: number;

    constructor(data?: IProfileViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): ProfileViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["count"] = this.count;
        return data;
    }
}

export interface IProfileViewDto {
    date?: string | undefined;
    count?: number;
}

export class ProposalEntity implements IProposalEntity {
    jobId?: string;
    job?: JobEntity;
    freelancerId?: string;
    freelancer?: UserEntity;
    proposedRate?: number;
    coverLetter?: string | undefined;
    status?: ProposalEntityStatus;
    files?: FileEntity[] | undefined;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: IProposalEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
            this.job = _data["job"] ? JobEntity.fromJS(_data["job"]) : <any>undefined;
            this.freelancerId = _data["freelancerId"];
            this.freelancer = _data["freelancer"] ? UserEntity.fromJS(_data["freelancer"]) : <any>undefined;
            this.proposedRate = _data["proposedRate"];
            this.coverLetter = _data["coverLetter"];
            this.status = _data["status"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(FileEntity.fromJS(item));
            }
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProposalEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ProposalEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        data["job"] = this.job ? this.job.toJSON() : <any>undefined;
        data["freelancerId"] = this.freelancerId;
        data["freelancer"] = this.freelancer ? this.freelancer.toJSON() : <any>undefined;
        data["proposedRate"] = this.proposedRate;
        data["coverLetter"] = this.coverLetter;
        data["status"] = this.status;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IProposalEntity {
    jobId?: string;
    job?: JobEntity;
    freelancerId?: string;
    freelancer?: UserEntity;
    proposedRate?: number;
    coverLetter?: string | undefined;
    status?: ProposalEntityStatus;
    files?: FileEntity[] | undefined;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class ProposalsDto implements IProposalsDto {
    sent?: number;
    viewed?: number;
    hires?: number;

    constructor(data?: IProposalsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sent = _data["sent"];
            this.viewed = _data["viewed"];
            this.hires = _data["hires"];
        }
    }

    static fromJS(data: any): ProposalsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProposalsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sent"] = this.sent;
        data["viewed"] = this.viewed;
        data["hires"] = this.hires;
        return data;
    }
}

export interface IProposalsDto {
    sent?: number;
    viewed?: number;
    hires?: number;
}

export class ReactToProposalCommand implements IReactToProposalCommand {
    proposalId?: string;
    reaction?: ReactToProposalCommandReaction;

    constructor(data?: IReactToProposalCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.proposalId = _data["proposalId"];
            this.reaction = _data["reaction"];
        }
    }

    static fromJS(data: any): ReactToProposalCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ReactToProposalCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["proposalId"] = this.proposalId;
        data["reaction"] = this.reaction;
        return data;
    }
}

export interface IReactToProposalCommand {
    proposalId?: string;
    reaction?: ReactToProposalCommandReaction;
}

export class ReactToSentJobCommand implements IReactToSentJobCommand {
    jobId?: string;
    reaction?: ReactToSentJobCommandReaction;

    constructor(data?: IReactToSentJobCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
            this.reaction = _data["reaction"];
        }
    }

    static fromJS(data: any): ReactToSentJobCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ReactToSentJobCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        data["reaction"] = this.reaction;
        return data;
    }
}

export interface IReactToSentJobCommand {
    jobId?: string;
    reaction?: ReactToSentJobCommandReaction;
}

export class ReactToTaskCommand implements IReactToTaskCommand {
    taskId?: string;
    approve?: boolean;
    newTitle?: string | undefined;
    newDescription?: string | undefined;

    constructor(data?: IReactToTaskCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskId = _data["taskId"];
            this.approve = _data["approve"];
            this.newTitle = _data["newTitle"];
            this.newDescription = _data["newDescription"];
        }
    }

    static fromJS(data: any): ReactToTaskCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ReactToTaskCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskId"] = this.taskId;
        data["approve"] = this.approve;
        data["newTitle"] = this.newTitle;
        data["newDescription"] = this.newDescription;
        return data;
    }
}

export interface IReactToTaskCommand {
    taskId?: string;
    approve?: boolean;
    newTitle?: string | undefined;
    newDescription?: string | undefined;
}

export class ReactToWorkSessionCommand implements IReactToWorkSessionCommand {
    workSessionId?: string;
    isApproved?: boolean;
    clientComment?: string | undefined;

    constructor(data?: IReactToWorkSessionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workSessionId = _data["workSessionId"];
            this.isApproved = _data["isApproved"];
            this.clientComment = _data["clientComment"];
        }
    }

    static fromJS(data: any): ReactToWorkSessionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ReactToWorkSessionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workSessionId"] = this.workSessionId;
        data["isApproved"] = this.isApproved;
        data["clientComment"] = this.clientComment;
        return data;
    }
}

export interface IReactToWorkSessionCommand {
    workSessionId?: string;
    isApproved?: boolean;
    clientComment?: string | undefined;
}

export class RefundTransactionCommand implements IRefundTransactionCommand {
    transactionId!: string;
    isContractCancellation?: boolean;

    constructor(data?: IRefundTransactionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionId = _data["transactionId"];
            this.isContractCancellation = _data["isContractCancellation"];
        }
    }

    static fromJS(data: any): RefundTransactionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RefundTransactionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        data["isContractCancellation"] = this.isContractCancellation;
        return data;
    }
}

export interface IRefundTransactionCommand {
    transactionId: string;
    isContractCancellation?: boolean;
}

export class RegisterUserSchema implements IRegisterUserSchema {
    name!: string;
    surname!: string;
    phone?: string | undefined;
    password!: string;
    email!: string;
    country!: RegisterUserSchemaCountry;
    type!: RegisterUserSchemaType;
    rememberMe?: boolean;

    constructor(data?: IRegisterUserSchema) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.phone = _data["phone"];
            this.password = _data["password"];
            this.email = _data["email"];
            this.country = _data["country"];
            this.type = _data["type"];
            this.rememberMe = _data["rememberMe"];
        }
    }

    static fromJS(data: any): RegisterUserSchema {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserSchema();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["phone"] = this.phone;
        data["password"] = this.password;
        data["email"] = this.email;
        data["country"] = this.country;
        data["type"] = this.type;
        data["rememberMe"] = this.rememberMe;
        return data;
    }
}

export interface IRegisterUserSchema {
    name: string;
    surname: string;
    phone?: string | undefined;
    password: string;
    email: string;
    country: RegisterUserSchemaCountry;
    type: RegisterUserSchemaType;
    rememberMe?: boolean;
}

export class ResetPasswordCommand implements IResetPasswordCommand {
    code!: string;
    email!: string;
    newPassword!: string;

    constructor(data?: IResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.email = _data["email"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["email"] = this.email;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IResetPasswordCommand {
    code: string;
    email: string;
    newPassword: string;
}

export class ResolveDisputeCommand implements IResolveDisputeCommand {
    disputeId?: string;
    strategy?: ResolveDisputeCommandStrategy;
    moderatorComment?: string | undefined;
    blockFreelancerWallet?: boolean;
    blockClientWallet?: boolean;
    blockFreelancerOrders?: boolean;
    blockUntil?: Date | undefined;

    constructor(data?: IResolveDisputeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disputeId = _data["disputeId"];
            this.strategy = _data["strategy"];
            this.moderatorComment = _data["moderatorComment"];
            this.blockFreelancerWallet = _data["blockFreelancerWallet"];
            this.blockClientWallet = _data["blockClientWallet"];
            this.blockFreelancerOrders = _data["blockFreelancerOrders"];
            this.blockUntil = _data["blockUntil"] ? new Date(_data["blockUntil"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ResolveDisputeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveDisputeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disputeId"] = this.disputeId;
        data["strategy"] = this.strategy;
        data["moderatorComment"] = this.moderatorComment;
        data["blockFreelancerWallet"] = this.blockFreelancerWallet;
        data["blockClientWallet"] = this.blockClientWallet;
        data["blockFreelancerOrders"] = this.blockFreelancerOrders;
        data["blockUntil"] = this.blockUntil ? this.blockUntil.toISOString() : <any>undefined;
        return data;
    }
}

export interface IResolveDisputeCommand {
    disputeId?: string;
    strategy?: ResolveDisputeCommandStrategy;
    moderatorComment?: string | undefined;
    blockFreelancerWallet?: boolean;
    blockClientWallet?: boolean;
    blockFreelancerOrders?: boolean;
    blockUntil?: Date | undefined;
}

export class SelectContestWinnerCommand implements ISelectContestWinnerCommand {
    contestId!: string;
    entryId!: string;

    constructor(data?: ISelectContestWinnerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contestId = _data["contestId"];
            this.entryId = _data["entryId"];
        }
    }

    static fromJS(data: any): SelectContestWinnerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SelectContestWinnerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contestId"] = this.contestId;
        data["entryId"] = this.entryId;
        return data;
    }
}

export interface ISelectContestWinnerCommand {
    contestId: string;
    entryId: string;
}

export class SendDraftJobToModerationCommand implements ISendDraftJobToModerationCommand {
    jobId?: string;

    constructor(data?: ISendDraftJobToModerationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
        }
    }

    static fromJS(data: any): SendDraftJobToModerationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendDraftJobToModerationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        return data;
    }
}

export interface ISendDraftJobToModerationCommand {
    jobId?: string;
}

export class SendMessageDto implements ISendMessageDto {
    chatId!: string;
    text?: string | undefined;
    files?: CreateFileDto[] | undefined;
    replyToMsg?: string | undefined;

    constructor(data?: ISendMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatId = _data["chatId"];
            this.text = _data["text"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(CreateFileDto.fromJS(item));
            }
            this.replyToMsg = _data["replyToMsg"];
        }
    }

    static fromJS(data: any): SendMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatId"] = this.chatId;
        data["text"] = this.text;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["replyToMsg"] = this.replyToMsg;
        return data;
    }
}

export interface ISendMessageDto {
    chatId: string;
    text?: string | undefined;
    files?: CreateFileDto[] | undefined;
    replyToMsg?: string | undefined;
}

export class SendResetCodeCommand implements ISendResetCodeCommand {
    email!: string;

    constructor(data?: ISendResetCodeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): SendResetCodeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendResetCodeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface ISendResetCodeCommand {
    email: string;
}

export class SkillEntity implements ISkillEntity {
    name?: string | undefined;
    jobs?: JobEntity[] | undefined;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: ISkillEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["jobs"])) {
                this.jobs = [] as any;
                for (let item of _data["jobs"])
                    this.jobs!.push(JobEntity.fromJS(item));
            }
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SkillEntity {
        data = typeof data === 'object' ? data : {};
        let result = new SkillEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.jobs)) {
            data["jobs"] = [];
            for (let item of this.jobs)
                data["jobs"].push(item.toJSON());
        }
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ISkillEntity {
    name?: string | undefined;
    jobs?: JobEntity[] | undefined;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class SkillModel implements ISkillModel {
    id?: string;
    name?: string | undefined;

    constructor(data?: ISkillModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SkillModel {
        data = typeof data === 'object' ? data : {};
        let result = new SkillModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ISkillModel {
    id?: string;
    name?: string | undefined;
}

export class StartChatWithFreelancerCommand implements IStartChatWithFreelancerCommand {
    proposalId?: string;
    jobId?: string;

    constructor(data?: IStartChatWithFreelancerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.proposalId = _data["proposalId"];
            this.jobId = _data["jobId"];
        }
    }

    static fromJS(data: any): StartChatWithFreelancerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new StartChatWithFreelancerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["proposalId"] = this.proposalId;
        data["jobId"] = this.jobId;
        return data;
    }
}

export interface IStartChatWithFreelancerCommand {
    proposalId?: string;
    jobId?: string;
}

export class StartContestCommand implements IStartContestCommand {
    contestId?: string;

    constructor(data?: IStartContestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contestId = _data["contestId"];
        }
    }

    static fromJS(data: any): StartContestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new StartContestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contestId"] = this.contestId;
        return data;
    }
}

export interface IStartContestCommand {
    contestId?: string;
}

export class StartPaymentFlowCommand implements IStartPaymentFlowCommand {
    amount?: Money;
    flow?: StartPaymentFlowCommandFlow;
    type?: StartPaymentFlowCommandType;
    providerId?: string;
    paymentMethodId?: string | undefined;
    oneTimeToken?: string | undefined;

    constructor(data?: IStartPaymentFlowCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"] ? Money.fromJS(_data["amount"]) : <any>undefined;
            this.flow = _data["flow"];
            this.type = _data["type"];
            this.providerId = _data["providerId"];
            this.paymentMethodId = _data["paymentMethodId"];
            this.oneTimeToken = _data["oneTimeToken"];
        }
    }

    static fromJS(data: any): StartPaymentFlowCommand {
        data = typeof data === 'object' ? data : {};
        let result = new StartPaymentFlowCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount ? this.amount.toJSON() : <any>undefined;
        data["flow"] = this.flow;
        data["type"] = this.type;
        data["providerId"] = this.providerId;
        data["paymentMethodId"] = this.paymentMethodId;
        data["oneTimeToken"] = this.oneTimeToken;
        return data;
    }
}

export interface IStartPaymentFlowCommand {
    amount?: Money;
    flow?: StartPaymentFlowCommandFlow;
    type?: StartPaymentFlowCommandType;
    providerId?: string;
    paymentMethodId?: string | undefined;
    oneTimeToken?: string | undefined;
}

export class StartWorkSessionCommand implements IStartWorkSessionCommand {
    contractId?: string;

    constructor(data?: IStartWorkSessionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractId = _data["contractId"];
        }
    }

    static fromJS(data: any): StartWorkSessionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new StartWorkSessionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractId"] = this.contractId;
        return data;
    }
}

export interface IStartWorkSessionCommand {
    contractId?: string;
}

export class SubmitContestEntryCommand implements ISubmitContestEntryCommand {
    contestId?: string;
    description?: string | undefined;
    submissionFiles?: CreateFileDto[] | undefined;

    constructor(data?: ISubmitContestEntryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contestId = _data["contestId"];
            this.description = _data["description"];
            if (Array.isArray(_data["submissionFiles"])) {
                this.submissionFiles = [] as any;
                for (let item of _data["submissionFiles"])
                    this.submissionFiles!.push(CreateFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubmitContestEntryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitContestEntryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contestId"] = this.contestId;
        data["description"] = this.description;
        if (Array.isArray(this.submissionFiles)) {
            data["submissionFiles"] = [];
            for (let item of this.submissionFiles)
                data["submissionFiles"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISubmitContestEntryCommand {
    contestId?: string;
    description?: string | undefined;
    submissionFiles?: CreateFileDto[] | undefined;
}

export class SubmitProposalCommand implements ISubmitProposalCommand {
    jobId?: string;
    coverLetter?: string | undefined;
    proposedRate?: number | undefined;

    constructor(data?: ISubmitProposalCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
            this.coverLetter = _data["coverLetter"];
            this.proposedRate = _data["proposedRate"];
        }
    }

    static fromJS(data: any): SubmitProposalCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitProposalCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        data["coverLetter"] = this.coverLetter;
        data["proposedRate"] = this.proposedRate;
        return data;
    }
}

export interface ISubmitProposalCommand {
    jobId?: string;
    coverLetter?: string | undefined;
    proposedRate?: number | undefined;
}

export class SubmitWorkSessionCommand implements ISubmitWorkSessionCommand {
    sessionId?: string;

    constructor(data?: ISubmitWorkSessionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sessionId = _data["sessionId"];
        }
    }

    static fromJS(data: any): SubmitWorkSessionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitWorkSessionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionId"] = this.sessionId;
        return data;
    }
}

export interface ISubmitWorkSessionCommand {
    sessionId?: string;
}

export class SuspendClientProfileCommand implements ISuspendClientProfileCommand {
    clientId?: string;
    reason?: string | undefined;

    constructor(data?: ISuspendClientProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): SuspendClientProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SuspendClientProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["reason"] = this.reason;
        return data;
    }
}

export interface ISuspendClientProfileCommand {
    clientId?: string;
    reason?: string | undefined;
}

export class TaskEntity implements ITaskEntity {
    contractId?: string;
    contract?: ContractEntity;
    readonly taskTitle?: string | undefined;
    readonly taskDescription?: string | undefined;
    readonly status?: string | undefined;
    readonly priority?: number;
    readonly creationDate?: Date;
    readonly completionDate?: Date | undefined;
    readonly isCompleted?: boolean;
    readonly isApproved?: boolean;
    readonly isInRevision?: boolean;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: ITaskEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractId = _data["contractId"];
            this.contract = _data["contract"] ? ContractEntity.fromJS(_data["contract"]) : <any>undefined;
            (<any>this).taskTitle = _data["taskTitle"];
            (<any>this).taskDescription = _data["taskDescription"];
            (<any>this).status = _data["status"];
            (<any>this).priority = _data["priority"];
            (<any>this).creationDate = _data["creationDate"] ? new Date(_data["creationDate"].toString()) : <any>undefined;
            (<any>this).completionDate = _data["completionDate"] ? new Date(_data["completionDate"].toString()) : <any>undefined;
            (<any>this).isCompleted = _data["isCompleted"];
            (<any>this).isApproved = _data["isApproved"];
            (<any>this).isInRevision = _data["isInRevision"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TaskEntity {
        data = typeof data === 'object' ? data : {};
        let result = new TaskEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractId"] = this.contractId;
        data["contract"] = this.contract ? this.contract.toJSON() : <any>undefined;
        data["taskTitle"] = this.taskTitle;
        data["taskDescription"] = this.taskDescription;
        data["status"] = this.status;
        data["priority"] = this.priority;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["completionDate"] = this.completionDate ? this.completionDate.toISOString() : <any>undefined;
        data["isCompleted"] = this.isCompleted;
        data["isApproved"] = this.isApproved;
        data["isInRevision"] = this.isInRevision;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ITaskEntity {
    contractId?: string;
    contract?: ContractEntity;
    taskTitle?: string | undefined;
    taskDescription?: string | undefined;
    status?: string | undefined;
    priority?: number;
    creationDate?: Date;
    completionDate?: Date | undefined;
    isCompleted?: boolean;
    isApproved?: boolean;
    isInRevision?: boolean;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class TaxInformation implements ITaxInformation {
    countryIso!: string;
    localIdNumber!: string;
    legalStatus!: TaxInformationLegalStatus;
    taxRegime!: TaxInformationTaxRegime;
    vatRegistered?: boolean;
    vatNumber?: string | undefined;
    bankDetails!: BankDetails;

    constructor(data?: ITaxInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bankDetails = new BankDetails();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryIso = _data["countryIso"];
            this.localIdNumber = _data["localIdNumber"];
            this.legalStatus = _data["legalStatus"];
            this.taxRegime = _data["taxRegime"];
            this.vatRegistered = _data["vatRegistered"];
            this.vatNumber = _data["vatNumber"];
            this.bankDetails = _data["bankDetails"] ? BankDetails.fromJS(_data["bankDetails"]) : new BankDetails();
        }
    }

    static fromJS(data: any): TaxInformation {
        data = typeof data === 'object' ? data : {};
        let result = new TaxInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryIso"] = this.countryIso;
        data["localIdNumber"] = this.localIdNumber;
        data["legalStatus"] = this.legalStatus;
        data["taxRegime"] = this.taxRegime;
        data["vatRegistered"] = this.vatRegistered;
        data["vatNumber"] = this.vatNumber;
        data["bankDetails"] = this.bankDetails ? this.bankDetails.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITaxInformation {
    countryIso: string;
    localIdNumber: string;
    legalStatus: TaxInformationLegalStatus;
    taxRegime: TaxInformationTaxRegime;
    vatRegistered?: boolean;
    vatNumber?: string | undefined;
    bankDetails: BankDetails;
}

export class TicketCommentEntity implements ITicketCommentEntity {
    createdBy!: UserEntity;
    text!: string;
    parentCommentId?: string | undefined;
    isDeleted!: boolean;
    ticketId!: string;
    files!: FileEntity[];
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: ITicketCommentEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new UserEntity();
            this.files = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"] ? UserEntity.fromJS(_data["createdBy"]) : new UserEntity();
            this.text = _data["text"];
            this.parentCommentId = _data["parentCommentId"];
            this.isDeleted = _data["isDeleted"];
            this.ticketId = _data["ticketId"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(FileEntity.fromJS(item));
            }
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TicketCommentEntity {
        data = typeof data === 'object' ? data : {};
        let result = new TicketCommentEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["text"] = this.text;
        data["parentCommentId"] = this.parentCommentId;
        data["isDeleted"] = this.isDeleted;
        data["ticketId"] = this.ticketId;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ITicketCommentEntity {
    createdBy: UserEntity;
    text: string;
    parentCommentId?: string | undefined;
    isDeleted: boolean;
    ticketId: string;
    files: FileEntity[];
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class TicketEntity implements ITicketEntity {
    text!: string;
    subject!: string;
    files?: FileEntity[] | undefined;
    answeredCommentId?: string | undefined;
    readonly status!: TicketEntityStatus;
    assignedUser?: UserEntity;
    readonly assignedUserId?: string | undefined;
    readonly comments?: TicketCommentEntity[] | undefined;
    readonly closedById?: string | undefined;
    createdBy?: UserEntity;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: ITicketEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.subject = _data["subject"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(FileEntity.fromJS(item));
            }
            this.answeredCommentId = _data["answeredCommentId"];
            (<any>this).status = _data["status"];
            this.assignedUser = _data["assignedUser"] ? UserEntity.fromJS(_data["assignedUser"]) : <any>undefined;
            (<any>this).assignedUserId = _data["assignedUserId"];
            if (Array.isArray(_data["comments"])) {
                (<any>this).comments = [] as any;
                for (let item of _data["comments"])
                    (<any>this).comments!.push(TicketCommentEntity.fromJS(item));
            }
            (<any>this).closedById = _data["closedById"];
            this.createdBy = _data["createdBy"] ? UserEntity.fromJS(_data["createdBy"]) : <any>undefined;
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TicketEntity {
        data = typeof data === 'object' ? data : {};
        let result = new TicketEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["subject"] = this.subject;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["answeredCommentId"] = this.answeredCommentId;
        data["status"] = this.status;
        data["assignedUser"] = this.assignedUser ? this.assignedUser.toJSON() : <any>undefined;
        data["assignedUserId"] = this.assignedUserId;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        data["closedById"] = this.closedById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ITicketEntity {
    text: string;
    subject: string;
    files?: FileEntity[] | undefined;
    answeredCommentId?: string | undefined;
    status: TicketEntityStatus;
    assignedUser?: UserEntity;
    assignedUserId?: string | undefined;
    comments?: TicketCommentEntity[] | undefined;
    closedById?: string | undefined;
    createdBy?: UserEntity;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class TotalsDto implements ITotalsDto {
    hourlyAmount!: number;
    manualAmount!: number;
    fixedAmount!: number;
    platformFee!: number;
    taxWithheld!: number;
    netAmount!: number;

    constructor(data?: ITotalsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hourlyAmount = _data["hourlyAmount"];
            this.manualAmount = _data["manualAmount"];
            this.fixedAmount = _data["fixedAmount"];
            this.platformFee = _data["platformFee"];
            this.taxWithheld = _data["taxWithheld"];
            this.netAmount = _data["netAmount"];
        }
    }

    static fromJS(data: any): TotalsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TotalsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hourlyAmount"] = this.hourlyAmount;
        data["manualAmount"] = this.manualAmount;
        data["fixedAmount"] = this.fixedAmount;
        data["platformFee"] = this.platformFee;
        data["taxWithheld"] = this.taxWithheld;
        data["netAmount"] = this.netAmount;
        return data;
    }
}

export interface ITotalsDto {
    hourlyAmount: number;
    manualAmount: number;
    fixedAmount: number;
    platformFee: number;
    taxWithheld: number;
    netAmount: number;
}

export class TransactionEntity implements ITransactionEntity {
    readonly walletId?: string;
    antoganistTransactionId?: string | undefined;
    rawAmount?: Money;
    netAmount?: Money;
    appliedFee?: Money;
    readonly status?: TransactionEntityStatus;
    readonly type?: TransactionEntityType;
    readonly flow?: TransactionEntityFlow;
    props?: TransactionPropsEntity;
    readonly frozenUntil?: Date | undefined;
    readonly comment?: string | undefined;
    completedAt?: Date | undefined;
    provider?: TransactionProviderEntity;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: ITransactionEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).walletId = _data["walletId"];
            this.antoganistTransactionId = _data["antoganistTransactionId"];
            this.rawAmount = _data["rawAmount"] ? Money.fromJS(_data["rawAmount"]) : <any>undefined;
            this.netAmount = _data["netAmount"] ? Money.fromJS(_data["netAmount"]) : <any>undefined;
            this.appliedFee = _data["appliedFee"] ? Money.fromJS(_data["appliedFee"]) : <any>undefined;
            (<any>this).status = _data["status"];
            (<any>this).type = _data["type"];
            (<any>this).flow = _data["flow"];
            this.props = _data["props"] ? TransactionPropsEntity.fromJS(_data["props"]) : <any>undefined;
            (<any>this).frozenUntil = _data["frozenUntil"] ? new Date(_data["frozenUntil"].toString()) : <any>undefined;
            (<any>this).comment = _data["comment"];
            this.completedAt = _data["completedAt"] ? new Date(_data["completedAt"].toString()) : <any>undefined;
            this.provider = _data["provider"] ? TransactionProviderEntity.fromJS(_data["provider"]) : <any>undefined;
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TransactionEntity {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["walletId"] = this.walletId;
        data["antoganistTransactionId"] = this.antoganistTransactionId;
        data["rawAmount"] = this.rawAmount ? this.rawAmount.toJSON() : <any>undefined;
        data["netAmount"] = this.netAmount ? this.netAmount.toJSON() : <any>undefined;
        data["appliedFee"] = this.appliedFee ? this.appliedFee.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["type"] = this.type;
        data["flow"] = this.flow;
        data["props"] = this.props ? this.props.toJSON() : <any>undefined;
        data["frozenUntil"] = this.frozenUntil ? this.frozenUntil.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["completedAt"] = this.completedAt ? this.completedAt.toISOString() : <any>undefined;
        data["provider"] = this.provider ? this.provider.toJSON() : <any>undefined;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ITransactionEntity {
    walletId?: string;
    antoganistTransactionId?: string | undefined;
    rawAmount?: Money;
    netAmount?: Money;
    appliedFee?: Money;
    status?: TransactionEntityStatus;
    type?: TransactionEntityType;
    flow?: TransactionEntityFlow;
    props?: TransactionPropsEntity;
    frozenUntil?: Date | undefined;
    comment?: string | undefined;
    completedAt?: Date | undefined;
    provider?: TransactionProviderEntity;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class TransactionPropsEntity implements ITransactionPropsEntity {
    readonly paymentUrl?: string | undefined;
    readonly successUrl?: string | undefined;
    readonly paymentGateway?: string | undefined;
    readonly providerPaymentId?: string | undefined;
    feeContext?: FeeContext;

    constructor(data?: ITransactionPropsEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).paymentUrl = _data["paymentUrl"];
            (<any>this).successUrl = _data["successUrl"];
            (<any>this).paymentGateway = _data["paymentGateway"];
            (<any>this).providerPaymentId = _data["providerPaymentId"];
            this.feeContext = _data["feeContext"] ? FeeContext.fromJS(_data["feeContext"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TransactionPropsEntity {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionPropsEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentUrl"] = this.paymentUrl;
        data["successUrl"] = this.successUrl;
        data["paymentGateway"] = this.paymentGateway;
        data["providerPaymentId"] = this.providerPaymentId;
        data["feeContext"] = this.feeContext ? this.feeContext.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITransactionPropsEntity {
    paymentUrl?: string | undefined;
    successUrl?: string | undefined;
    paymentGateway?: string | undefined;
    providerPaymentId?: string | undefined;
    feeContext?: FeeContext;
}

export class TransactionProviderEntity implements ITransactionProviderEntity {
    name!: string;
    feePercent!: number;
    systems!: PaymentSystemEntity[];
    logo!: FileEntity;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: ITransactionProviderEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.systems = [];
            this.logo = new FileEntity();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.feePercent = _data["feePercent"];
            if (Array.isArray(_data["systems"])) {
                this.systems = [] as any;
                for (let item of _data["systems"])
                    this.systems!.push(PaymentSystemEntity.fromJS(item));
            }
            this.logo = _data["logo"] ? FileEntity.fromJS(_data["logo"]) : new FileEntity();
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TransactionProviderEntity {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionProviderEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["feePercent"] = this.feePercent;
        if (Array.isArray(this.systems)) {
            data["systems"] = [];
            for (let item of this.systems)
                data["systems"].push(item.toJSON());
        }
        data["logo"] = this.logo ? this.logo.toJSON() : <any>undefined;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ITransactionProviderEntity {
    name: string;
    feePercent: number;
    systems: PaymentSystemEntity[];
    logo: FileEntity;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class UpdateCategoryCommand implements IUpdateCategoryCommand {
    categoryId?: string;
    name?: string | undefined;

    constructor(data?: IUpdateCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateCategoryCommand {
    categoryId?: string;
    name?: string | undefined;
}

export class UpdateChatDto implements IUpdateChatDto {
    chatId!: string;
    name?: string | undefined;
    isTextingAllowed?: boolean | undefined;
    isArchived?: boolean | undefined;

    constructor(data?: IUpdateChatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatId = _data["chatId"];
            this.name = _data["name"];
            this.isTextingAllowed = _data["isTextingAllowed"];
            this.isArchived = _data["isArchived"];
        }
    }

    static fromJS(data: any): UpdateChatDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateChatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatId"] = this.chatId;
        data["name"] = this.name;
        data["isTextingAllowed"] = this.isTextingAllowed;
        data["isArchived"] = this.isArchived;
        return data;
    }
}

export interface IUpdateChatDto {
    chatId: string;
    name?: string | undefined;
    isTextingAllowed?: boolean | undefined;
    isArchived?: boolean | undefined;
}

export class UpdateClientProfileCommand implements IUpdateClientProfileCommand {
    clientId?: string;
    companyName?: string | undefined;
    companyDescription?: string | undefined;
    companyWebsite?: string | undefined;
    location?: string | undefined;
    companyLogo?: CreateFileDto;
    employerType?: UpdateClientProfileCommandEmployerType | undefined;
    phoneNumber?: string | undefined;

    constructor(data?: IUpdateClientProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.companyName = _data["companyName"];
            this.companyDescription = _data["companyDescription"];
            this.companyWebsite = _data["companyWebsite"];
            this.location = _data["location"];
            this.companyLogo = _data["companyLogo"] ? CreateFileDto.fromJS(_data["companyLogo"]) : <any>undefined;
            this.employerType = _data["employerType"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): UpdateClientProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["companyName"] = this.companyName;
        data["companyDescription"] = this.companyDescription;
        data["companyWebsite"] = this.companyWebsite;
        data["location"] = this.location;
        data["companyLogo"] = this.companyLogo ? this.companyLogo.toJSON() : <any>undefined;
        data["employerType"] = this.employerType;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface IUpdateClientProfileCommand {
    clientId?: string;
    companyName?: string | undefined;
    companyDescription?: string | undefined;
    companyWebsite?: string | undefined;
    location?: string | undefined;
    companyLogo?: CreateFileDto;
    employerType?: UpdateClientProfileCommandEmployerType | undefined;
    phoneNumber?: string | undefined;
}

export class UpdateContestCommand implements IUpdateContestCommand {
    contestId?: string;
    title?: string | undefined;
    description?: string | undefined;
    prizePool?: number | undefined;

    constructor(data?: IUpdateContestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contestId = _data["contestId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.prizePool = _data["prizePool"];
        }
    }

    static fromJS(data: any): UpdateContestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contestId"] = this.contestId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["prizePool"] = this.prizePool;
        return data;
    }
}

export interface IUpdateContestCommand {
    contestId?: string;
    title?: string | undefined;
    description?: string | undefined;
    prizePool?: number | undefined;
}

export class UpdateFreelancerProfileCommand implements IUpdateFreelancerProfileCommand {
    skills?: string[] | undefined;
    experience?: string | undefined;
    resume?: string | undefined;
    hourlyRate?: number | undefined;
    availability?: UpdateFreelancerProfileCommandAvailability | undefined;

    constructor(data?: IUpdateFreelancerProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(item);
            }
            this.experience = _data["experience"];
            this.resume = _data["resume"];
            this.hourlyRate = _data["hourlyRate"];
            this.availability = _data["availability"];
        }
    }

    static fromJS(data: any): UpdateFreelancerProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFreelancerProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item);
        }
        data["experience"] = this.experience;
        data["resume"] = this.resume;
        data["hourlyRate"] = this.hourlyRate;
        data["availability"] = this.availability;
        return data;
    }
}

export interface IUpdateFreelancerProfileCommand {
    skills?: string[] | undefined;
    experience?: string | undefined;
    resume?: string | undefined;
    hourlyRate?: number | undefined;
    availability?: UpdateFreelancerProfileCommandAvailability | undefined;
}

export class UpdateFreelancerTeamCommand implements IUpdateFreelancerTeamCommand {
    teamId?: string;
    name?: string | undefined;
    avatarFile?: CreateFileDto;
    closed?: boolean | undefined;
    closedReason?: string | undefined;

    constructor(data?: IUpdateFreelancerTeamCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.teamId = _data["teamId"];
            this.name = _data["name"];
            this.avatarFile = _data["avatarFile"] ? CreateFileDto.fromJS(_data["avatarFile"]) : <any>undefined;
            this.closed = _data["closed"];
            this.closedReason = _data["closedReason"];
        }
    }

    static fromJS(data: any): UpdateFreelancerTeamCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFreelancerTeamCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teamId"] = this.teamId;
        data["name"] = this.name;
        data["avatarFile"] = this.avatarFile ? this.avatarFile.toJSON() : <any>undefined;
        data["closed"] = this.closed;
        data["closedReason"] = this.closedReason;
        return data;
    }
}

export interface IUpdateFreelancerTeamCommand {
    teamId?: string;
    name?: string | undefined;
    avatarFile?: CreateFileDto;
    closed?: boolean | undefined;
    closedReason?: string | undefined;
}

export class UpdateJobCommand implements IUpdateJobCommand {
    jobId?: string;
    title?: string | undefined;
    description?: string | undefined;
    requiredSkillIds?: string[] | undefined;
    categoryId?: string | undefined;
    budget?: number | undefined;
    hourlyRate?: number | undefined;
    expirationDate?: Date | undefined;
    duration?: number | undefined;
    files?: CreateFileDto[] | undefined;

    constructor(data?: IUpdateJobCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["requiredSkillIds"])) {
                this.requiredSkillIds = [] as any;
                for (let item of _data["requiredSkillIds"])
                    this.requiredSkillIds!.push(item);
            }
            this.categoryId = _data["categoryId"];
            this.budget = _data["budget"];
            this.hourlyRate = _data["hourlyRate"];
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(CreateFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateJobCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateJobCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.requiredSkillIds)) {
            data["requiredSkillIds"] = [];
            for (let item of this.requiredSkillIds)
                data["requiredSkillIds"].push(item);
        }
        data["categoryId"] = this.categoryId;
        data["budget"] = this.budget;
        data["hourlyRate"] = this.hourlyRate;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["duration"] = this.duration;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateJobCommand {
    jobId?: string;
    title?: string | undefined;
    description?: string | undefined;
    requiredSkillIds?: string[] | undefined;
    categoryId?: string | undefined;
    budget?: number | undefined;
    hourlyRate?: number | undefined;
    expirationDate?: Date | undefined;
    duration?: number | undefined;
    files?: CreateFileDto[] | undefined;
}

export class UpdateMessageDto implements IUpdateMessageDto {
    messageId?: string;
    text?: string | undefined;
    files?: CreateFileDto[] | undefined;

    constructor(data?: IUpdateMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.messageId = _data["messageId"];
            this.text = _data["text"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(CreateFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["messageId"] = this.messageId;
        data["text"] = this.text;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateMessageDto {
    messageId?: string;
    text?: string | undefined;
    files?: CreateFileDto[] | undefined;
}

export class UpdateNewsDto implements IUpdateNewsDto {
    newsId?: string;
    title?: string | undefined;
    text?: string | undefined;
    publishTime?: Date | undefined;
    isHidden?: boolean | undefined;
    newFiles?: CreateFileDto[] | undefined;
    changeNotes?: boolean | undefined;

    constructor(data?: IUpdateNewsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newsId = _data["newsId"];
            this.title = _data["title"];
            this.text = _data["text"];
            this.publishTime = _data["publishTime"] ? new Date(_data["publishTime"].toString()) : <any>undefined;
            this.isHidden = _data["isHidden"];
            if (Array.isArray(_data["newFiles"])) {
                this.newFiles = [] as any;
                for (let item of _data["newFiles"])
                    this.newFiles!.push(CreateFileDto.fromJS(item));
            }
            this.changeNotes = _data["changeNotes"];
        }
    }

    static fromJS(data: any): UpdateNewsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNewsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newsId"] = this.newsId;
        data["title"] = this.title;
        data["text"] = this.text;
        data["publishTime"] = this.publishTime ? this.publishTime.toISOString() : <any>undefined;
        data["isHidden"] = this.isHidden;
        if (Array.isArray(this.newFiles)) {
            data["newFiles"] = [];
            for (let item of this.newFiles)
                data["newFiles"].push(item.toJSON());
        }
        data["changeNotes"] = this.changeNotes;
        return data;
    }
}

export interface IUpdateNewsDto {
    newsId?: string;
    title?: string | undefined;
    text?: string | undefined;
    publishTime?: Date | undefined;
    isHidden?: boolean | undefined;
    newFiles?: CreateFileDto[] | undefined;
    changeNotes?: boolean | undefined;
}

export class UpdatePortfolioProjectCommand implements IUpdatePortfolioProjectCommand {
    projectId?: string;
    name?: string | undefined;
    userRole?: string | undefined;
    skills?: string[] | undefined;
    description?: string | undefined;
    images?: CreateFileDto[] | undefined;
    hidden?: boolean | undefined;

    constructor(data?: IUpdatePortfolioProjectCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.name = _data["name"];
            this.userRole = _data["userRole"];
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(item);
            }
            this.description = _data["description"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(CreateFileDto.fromJS(item));
            }
            this.hidden = _data["hidden"];
        }
    }

    static fromJS(data: any): UpdatePortfolioProjectCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePortfolioProjectCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["name"] = this.name;
        data["userRole"] = this.userRole;
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item);
        }
        data["description"] = this.description;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["hidden"] = this.hidden;
        return data;
    }
}

export interface IUpdatePortfolioProjectCommand {
    projectId?: string;
    name?: string | undefined;
    userRole?: string | undefined;
    skills?: string[] | undefined;
    description?: string | undefined;
    images?: CreateFileDto[] | undefined;
    hidden?: boolean | undefined;
}

export class UpdateProposalCommand implements IUpdateProposalCommand {
    proposalId?: string;
    coverLetter?: string | undefined;
    proposedRate?: number | undefined;

    constructor(data?: IUpdateProposalCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.proposalId = _data["proposalId"];
            this.coverLetter = _data["coverLetter"];
            this.proposedRate = _data["proposedRate"];
        }
    }

    static fromJS(data: any): UpdateProposalCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProposalCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["proposalId"] = this.proposalId;
        data["coverLetter"] = this.coverLetter;
        data["proposedRate"] = this.proposedRate;
        return data;
    }
}

export interface IUpdateProposalCommand {
    proposalId?: string;
    coverLetter?: string | undefined;
    proposedRate?: number | undefined;
}

export class UpdateSkillDto implements IUpdateSkillDto {
    skillId?: string;
    name?: string | undefined;

    constructor(data?: IUpdateSkillDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skillId = _data["skillId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateSkillDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSkillDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skillId"] = this.skillId;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateSkillDto {
    skillId?: string;
    name?: string | undefined;
}

export class UpdateSkillsCommand implements IUpdateSkillsCommand {
    skills?: UpdateSkillDto[] | undefined;

    constructor(data?: IUpdateSkillsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(UpdateSkillDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateSkillsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSkillsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateSkillsCommand {
    skills?: UpdateSkillDto[] | undefined;
}

export class UpdateTaskCommand implements IUpdateTaskCommand {
    taskId?: string;
    title?: string | undefined;
    description?: string | undefined;
    priority?: number | undefined;

    constructor(data?: IUpdateTaskCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskId = _data["taskId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.priority = _data["priority"];
        }
    }

    static fromJS(data: any): UpdateTaskCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTaskCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskId"] = this.taskId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["priority"] = this.priority;
        return data;
    }
}

export interface IUpdateTaskCommand {
    taskId?: string;
    title?: string | undefined;
    description?: string | undefined;
    priority?: number | undefined;
}

export class UpdateTaxSettingsCommand implements IUpdateTaxSettingsCommand {
    userId!: string;
    countryIso!: string;
    localIdNumber!: string;
    legalStatus!: UpdateTaxSettingsCommandLegalStatus;
    taxRegime!: UpdateTaxSettingsCommandTaxRegime;
    vatRegistered?: boolean;
    vatNumber?: string | undefined;
    bankBic!: string;
    bankAccountNumber!: string;
    bankName!: string;

    constructor(data?: IUpdateTaxSettingsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.countryIso = _data["countryIso"];
            this.localIdNumber = _data["localIdNumber"];
            this.legalStatus = _data["legalStatus"];
            this.taxRegime = _data["taxRegime"];
            this.vatRegistered = _data["vatRegistered"];
            this.vatNumber = _data["vatNumber"];
            this.bankBic = _data["bankBic"];
            this.bankAccountNumber = _data["bankAccountNumber"];
            this.bankName = _data["bankName"];
        }
    }

    static fromJS(data: any): UpdateTaxSettingsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTaxSettingsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["countryIso"] = this.countryIso;
        data["localIdNumber"] = this.localIdNumber;
        data["legalStatus"] = this.legalStatus;
        data["taxRegime"] = this.taxRegime;
        data["vatRegistered"] = this.vatRegistered;
        data["vatNumber"] = this.vatNumber;
        data["bankBic"] = this.bankBic;
        data["bankAccountNumber"] = this.bankAccountNumber;
        data["bankName"] = this.bankName;
        return data;
    }
}

export interface IUpdateTaxSettingsCommand {
    userId: string;
    countryIso: string;
    localIdNumber: string;
    legalStatus: UpdateTaxSettingsCommandLegalStatus;
    taxRegime: UpdateTaxSettingsCommandTaxRegime;
    vatRegistered?: boolean;
    vatNumber?: string | undefined;
    bankBic: string;
    bankAccountNumber: string;
    bankName: string;
}

export class UpdateUserCommand implements IUpdateUserCommand {
    userId!: string;
    email?: string | undefined;
    role?: UpdateUserCommandRole | undefined;
    avatar?: CreateFileDto;
    description?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    oldPassword?: string | undefined;
    newPassword?: string | undefined;
    telegramId?: string | undefined;

    constructor(data?: IUpdateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.role = _data["role"];
            this.avatar = _data["avatar"] ? CreateFileDto.fromJS(_data["avatar"]) : <any>undefined;
            this.description = _data["description"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
            this.telegramId = _data["telegramId"];
        }
    }

    static fromJS(data: any): UpdateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["role"] = this.role;
        data["avatar"] = this.avatar ? this.avatar.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        data["telegramId"] = this.telegramId;
        return data;
    }
}

export interface IUpdateUserCommand {
    userId: string;
    email?: string | undefined;
    role?: UpdateUserCommandRole | undefined;
    avatar?: CreateFileDto;
    description?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    oldPassword?: string | undefined;
    newPassword?: string | undefined;
    telegramId?: string | undefined;
}

export class UserEntity implements IUserEntity {
    name!: string;
    surname!: string;
    fullname!: string;
    role!: UserEntityRole;
    type!: UserEntityType;
    email!: string;
    avatar?: FileEntity;
    isOnline!: boolean;
    isSuperadmin!: boolean;
    phone?: string | undefined;
    telegramId?: string | undefined;
    blocked!: boolean;
    location?: UserEntityLocation | undefined;
    readonly isExternalUser!: boolean;
    taxInfo?: TaxInformation;
    notificationSettings?: NotificationSettings;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: IUserEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.fullname = _data["fullname"];
            this.role = _data["role"];
            this.type = _data["type"];
            this.email = _data["email"];
            this.avatar = _data["avatar"] ? FileEntity.fromJS(_data["avatar"]) : <any>undefined;
            this.isOnline = _data["isOnline"];
            this.isSuperadmin = _data["isSuperadmin"];
            this.phone = _data["phone"];
            this.telegramId = _data["telegramId"];
            this.blocked = _data["blocked"];
            this.location = _data["location"];
            (<any>this).isExternalUser = _data["isExternalUser"];
            this.taxInfo = _data["taxInfo"] ? TaxInformation.fromJS(_data["taxInfo"]) : <any>undefined;
            this.notificationSettings = _data["notificationSettings"] ? NotificationSettings.fromJS(_data["notificationSettings"]) : <any>undefined;
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserEntity {
        data = typeof data === 'object' ? data : {};
        let result = new UserEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["fullname"] = this.fullname;
        data["role"] = this.role;
        data["type"] = this.type;
        data["email"] = this.email;
        data["avatar"] = this.avatar ? this.avatar.toJSON() : <any>undefined;
        data["isOnline"] = this.isOnline;
        data["isSuperadmin"] = this.isSuperadmin;
        data["phone"] = this.phone;
        data["telegramId"] = this.telegramId;
        data["blocked"] = this.blocked;
        data["location"] = this.location;
        data["isExternalUser"] = this.isExternalUser;
        data["taxInfo"] = this.taxInfo ? this.taxInfo.toJSON() : <any>undefined;
        data["notificationSettings"] = this.notificationSettings ? this.notificationSettings.toJSON() : <any>undefined;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserEntity {
    name: string;
    surname: string;
    fullname: string;
    role: UserEntityRole;
    type: UserEntityType;
    email: string;
    avatar?: FileEntity;
    isOnline: boolean;
    isSuperadmin: boolean;
    phone?: string | undefined;
    telegramId?: string | undefined;
    blocked: boolean;
    location?: UserEntityLocation | undefined;
    isExternalUser: boolean;
    taxInfo?: TaxInformation;
    notificationSettings?: NotificationSettings;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class WalletEntity implements IWalletEntity {
    readonly userId!: string;
    user!: UserEntity;
    readonly currency!: WalletEntityCurrency;
    frozen!: Money;
    availableBalance!: Money;
    pendingIncome!: Money;
    readonly blocked!: boolean;
    readonly blockReason?: WalletEntityBlockReason;
    rowVersion?: string | undefined;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: IWalletEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEntity();
            this.frozen = new Money();
            this.availableBalance = new Money();
            this.pendingIncome = new Money();
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).userId = _data["userId"];
            this.user = _data["user"] ? UserEntity.fromJS(_data["user"]) : new UserEntity();
            (<any>this).currency = _data["currency"];
            this.frozen = _data["frozen"] ? Money.fromJS(_data["frozen"]) : new Money();
            this.availableBalance = _data["availableBalance"] ? Money.fromJS(_data["availableBalance"]) : new Money();
            this.pendingIncome = _data["pendingIncome"] ? Money.fromJS(_data["pendingIncome"]) : new Money();
            (<any>this).blocked = _data["blocked"];
            (<any>this).blockReason = _data["blockReason"];
            this.rowVersion = _data["rowVersion"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WalletEntity {
        data = typeof data === 'object' ? data : {};
        let result = new WalletEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["currency"] = this.currency;
        data["frozen"] = this.frozen ? this.frozen.toJSON() : <any>undefined;
        data["availableBalance"] = this.availableBalance ? this.availableBalance.toJSON() : <any>undefined;
        data["pendingIncome"] = this.pendingIncome ? this.pendingIncome.toJSON() : <any>undefined;
        data["blocked"] = this.blocked;
        data["blockReason"] = this.blockReason;
        data["rowVersion"] = this.rowVersion;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IWalletEntity {
    userId: string;
    user: UserEntity;
    currency: WalletEntityCurrency;
    frozen: Money;
    availableBalance: Money;
    pendingIncome: Money;
    blocked: boolean;
    blockReason?: WalletEntityBlockReason;
    rowVersion?: string | undefined;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class WarnUserScheme implements IWarnUserScheme {
    reason?: string | undefined;

    constructor(data?: IWarnUserScheme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): WarnUserScheme {
        data = typeof data === 'object' ? data : {};
        let result = new WarnUserScheme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        return data;
    }
}

export interface IWarnUserScheme {
    reason?: string | undefined;
}

export class WithdrawProposalCommand implements IWithdrawProposalCommand {
    proposalId?: string;

    constructor(data?: IWithdrawProposalCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.proposalId = _data["proposalId"];
        }
    }

    static fromJS(data: any): WithdrawProposalCommand {
        data = typeof data === 'object' ? data : {};
        let result = new WithdrawProposalCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["proposalId"] = this.proposalId;
        return data;
    }
}

export interface IWithdrawProposalCommand {
    proposalId?: string;
}

export class WorkSessionEntity implements IWorkSessionEntity {
    files?: FileEntity[] | undefined;
    contractId?: string;
    contract?: ContractEntity;
    freelancerId?: string;
    freelancer?: UserEntity;
    startDate?: Date;
    endDate?: Date | undefined;
    comment?: string | undefined;
    clientComment?: string | undefined;
    submittedAt?: Date | undefined;
    approvedAt?: Date | undefined;
    rejectedAt?: Date | undefined;
    status?: WorkSessionEntityStatus;
    readonly autoApproved?: boolean;
    createdById?: string | undefined;
    createdAt!: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id!: string;

    constructor(data?: IWorkSessionEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(FileEntity.fromJS(item));
            }
            this.contractId = _data["contractId"];
            this.contract = _data["contract"] ? ContractEntity.fromJS(_data["contract"]) : <any>undefined;
            this.freelancerId = _data["freelancerId"];
            this.freelancer = _data["freelancer"] ? UserEntity.fromJS(_data["freelancer"]) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.comment = _data["comment"];
            this.clientComment = _data["clientComment"];
            this.submittedAt = _data["submittedAt"] ? new Date(_data["submittedAt"].toString()) : <any>undefined;
            this.approvedAt = _data["approvedAt"] ? new Date(_data["approvedAt"].toString()) : <any>undefined;
            this.rejectedAt = _data["rejectedAt"] ? new Date(_data["rejectedAt"].toString()) : <any>undefined;
            this.status = _data["status"];
            (<any>this).autoApproved = _data["autoApproved"];
            this.createdById = _data["createdById"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedById = _data["lastModifiedById"];
            this.lastModifiedAt = _data["lastModifiedAt"] ? new Date(_data["lastModifiedAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WorkSessionEntity {
        data = typeof data === 'object' ? data : {};
        let result = new WorkSessionEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["contractId"] = this.contractId;
        data["contract"] = this.contract ? this.contract.toJSON() : <any>undefined;
        data["freelancerId"] = this.freelancerId;
        data["freelancer"] = this.freelancer ? this.freelancer.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["clientComment"] = this.clientComment;
        data["submittedAt"] = this.submittedAt ? this.submittedAt.toISOString() : <any>undefined;
        data["approvedAt"] = this.approvedAt ? this.approvedAt.toISOString() : <any>undefined;
        data["rejectedAt"] = this.rejectedAt ? this.rejectedAt.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["autoApproved"] = this.autoApproved;
        data["createdById"] = this.createdById;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedById"] = this.lastModifiedById;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IWorkSessionEntity {
    files?: FileEntity[] | undefined;
    contractId?: string;
    contract?: ContractEntity;
    freelancerId?: string;
    freelancer?: UserEntity;
    startDate?: Date;
    endDate?: Date | undefined;
    comment?: string | undefined;
    clientComment?: string | undefined;
    submittedAt?: Date | undefined;
    approvedAt?: Date | undefined;
    rejectedAt?: Date | undefined;
    status?: WorkSessionEntityStatus;
    autoApproved?: boolean;
    createdById?: string | undefined;
    createdAt: Date;
    lastModifiedById?: string | undefined;
    lastModifiedAt?: Date | undefined;
    id: string;
}

export class WorkSessionSummaryDto implements IWorkSessionSummaryDto {
    sessionId!: string;
    contractId!: string;
    contractLabel!: string;
    comment!: string;
    hours!: number;
    amount!: number;
    isManual!: boolean;
    startUtc!: Date;
    endUtc?: Date | undefined;

    constructor(data?: IWorkSessionSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sessionId = _data["sessionId"];
            this.contractId = _data["contractId"];
            this.contractLabel = _data["contractLabel"];
            this.comment = _data["comment"];
            this.hours = _data["hours"];
            this.amount = _data["amount"];
            this.isManual = _data["isManual"];
            this.startUtc = _data["startUtc"] ? new Date(_data["startUtc"].toString()) : <any>undefined;
            this.endUtc = _data["endUtc"] ? new Date(_data["endUtc"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): WorkSessionSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkSessionSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionId"] = this.sessionId;
        data["contractId"] = this.contractId;
        data["contractLabel"] = this.contractLabel;
        data["comment"] = this.comment;
        data["hours"] = this.hours;
        data["amount"] = this.amount;
        data["isManual"] = this.isManual;
        data["startUtc"] = this.startUtc ? this.startUtc.toISOString() : <any>undefined;
        data["endUtc"] = this.endUtc ? this.endUtc.toISOString() : <any>undefined;
        return data;
    }
}

export interface IWorkSessionSummaryDto {
    sessionId: string;
    contractId: string;
    contractLabel: string;
    comment: string;
    hours: number;
    amount: number;
    isManual: boolean;
    startUtc: Date;
    endUtc?: Date | undefined;
}

export enum Status {
    Pending = "Pending",
    Accepted = "Accepted",
    Rejected = "Rejected",
    Hidden = "Hidden",
}

export enum AddBonusToContractCommandCurrency {
    RUB = "RUB",
    USD = "USD",
    KZT = "KZT",
    EUR = "EUR",
}

export enum AddBonusToContractCommandType {
    Performance = "Performance",
    Discretionary = "Discretionary",
    Tip = "Tip",
}

export enum BalanceOperationCommandBalanceOperationType {
    Freeze = "Freeze",
    Unfreeze = "Unfreeze",
    PendingIncome = "PendingIncome",
    Deposit = "Deposit",
    Withdrawl = "Withdrawl",
}

export enum BlockWalletCommandReason {
    None = "None",
    FraudSuspicion = "FraudSuspicion",
    LegalIssue = "LegalIssue",
    UserRequest = "UserRequest",
}

export enum BonusEntityType {
    Performance = "Performance",
    Discretionary = "Discretionary",
    Tip = "Tip",
}

export enum ChatEntityType {
    Group = "Group",
    Direct = "Direct",
    Support = "Support",
}

export enum CommandResultStatus {
    Continue = "Continue",
    SwitchingProtocols = "SwitchingProtocols",
    Processing = "Processing",
    EarlyHints = "EarlyHints",
    OK = "OK",
    Created = "Created",
    Accepted = "Accepted",
    NonAuthoritativeInformation = "NonAuthoritativeInformation",
    NoContent = "NoContent",
    ResetContent = "ResetContent",
    PartialContent = "PartialContent",
    MultiStatus = "MultiStatus",
    AlreadyReported = "AlreadyReported",
    IMUsed = "IMUsed",
    MultipleChoices = "MultipleChoices",
    MovedPermanently = "MovedPermanently",
    Found = "Found",
    SeeOther = "SeeOther",
    NotModified = "NotModified",
    UseProxy = "UseProxy",
    Unused = "Unused",
    RedirectKeepVerb = "RedirectKeepVerb",
    PermanentRedirect = "PermanentRedirect",
    BadRequest = "BadRequest",
    Unauthorized = "Unauthorized",
    PaymentRequired = "PaymentRequired",
    Forbidden = "Forbidden",
    NotFound = "NotFound",
    MethodNotAllowed = "MethodNotAllowed",
    NotAcceptable = "NotAcceptable",
    ProxyAuthenticationRequired = "ProxyAuthenticationRequired",
    RequestTimeout = "RequestTimeout",
    Conflict = "Conflict",
    Gone = "Gone",
    LengthRequired = "LengthRequired",
    PreconditionFailed = "PreconditionFailed",
    RequestEntityTooLarge = "RequestEntityTooLarge",
    RequestUriTooLong = "RequestUriTooLong",
    UnsupportedMediaType = "UnsupportedMediaType",
    RequestedRangeNotSatisfiable = "RequestedRangeNotSatisfiable",
    ExpectationFailed = "ExpectationFailed",
    MisdirectedRequest = "MisdirectedRequest",
    UnprocessableEntity = "UnprocessableEntity",
    Locked = "Locked",
    FailedDependency = "FailedDependency",
    UpgradeRequired = "UpgradeRequired",
    PreconditionRequired = "PreconditionRequired",
    TooManyRequests = "TooManyRequests",
    RequestHeaderFieldsTooLarge = "RequestHeaderFieldsTooLarge",
    UnavailableForLegalReasons = "UnavailableForLegalReasons",
    InternalServerError = "InternalServerError",
    NotImplemented = "NotImplemented",
    BadGateway = "BadGateway",
    ServiceUnavailable = "ServiceUnavailable",
    GatewayTimeout = "GatewayTimeout",
    HttpVersionNotSupported = "HttpVersionNotSupported",
    VariantAlsoNegotiates = "VariantAlsoNegotiates",
    InsufficientStorage = "InsufficientStorage",
    LoopDetected = "LoopDetected",
    NotExtended = "NotExtended",
    NetworkAuthenticationRequired = "NetworkAuthenticationRequired",
}

export enum ContestEntityStatus {
    Draft = "Draft",
    Moderation = "Moderation",
    Approved = "Approved",
    Open = "Open",
    Ended = "Ended",
    WinnerSelected = "WinnerSelected",
}

export enum ContractEntityStatus {
    PendingApproval = "PendingApproval",
    Active = "Active",
    Paused = "Paused",
    Completed = "Completed",
    Disputed = "Disputed",
    Cancelled = "Cancelled",
    Expired = "Expired",
    Closed = "Closed",
    PendingFinishApproval = "PendingFinishApproval",
}

export enum ContractEntityBudgetType {
    Hourly = "Hourly",
    Fixed = "Fixed",
}

export enum ContractEntityPaymentSchedule {
    Milestone = "Milestone",
    Weekly = "Weekly",
    Monthly = "Monthly",
    OnCompletion = "OnCompletion",
}

export enum CreateChatDtoType {
    Group = "Group",
    Direct = "Direct",
    Support = "Support",
}

export enum CreateClientProfileCommandEmployerType {
    Company = "Company",
    Indivdual = "Indivdual",
}

export enum CreateContractCommandBudgetType {
    Hourly = "Hourly",
    Fixed = "Fixed",
}

export enum CreateContractCommandPaymentSchedule {
    Milestone = "Milestone",
    Weekly = "Weekly",
    Monthly = "Monthly",
    OnCompletion = "OnCompletion",
}

export enum CreateJobCommandBudgetType {
    Hourly = "Hourly",
    Fixed = "Fixed",
}

export enum CreateJobCommandLevel {
    Beginner = "Beginner",
    Intermediate = "Intermediate",
    Expert = "Expert",
}

export enum CreateNotificationCommandRole {
    User = "User",
    Moderator = "Moderator",
    Admin = "Admin",
    Superadmin = "Superadmin",
}

export enum CreateNotificationCommandType {
    Freelancer = "Freelancer",
    Client = "Client",
    Other = "Other",
    NonUser = "NonUser",
    Staff = "Staff",
}

export enum FreelancerProfileEntityAvailability {
    Open = "Open",
    Busy = "Busy",
    Vacation = "Vacation",
}

export enum GatewayResultCommandCurrency {
    RUB = "RUB",
    USD = "USD",
    KZT = "KZT",
    EUR = "EUR",
}

export enum GetContractsListQueryStatus {
    PendingApproval = "PendingApproval",
    Active = "Active",
    Paused = "Paused",
    Completed = "Completed",
    Disputed = "Disputed",
    Cancelled = "Cancelled",
    Expired = "Expired",
    Closed = "Closed",
    PendingFinishApproval = "PendingFinishApproval",
}

export enum Levels {
    Beginner = "Beginner",
    Intermediate = "Intermediate",
    Expert = "Expert",
}

export enum GetJobsListQueryEmployerLocation {
    Kazakhstan = "Kazakhstan",
    Russia = "Russia",
    Belarus = "Belarus",
}

export enum Statuses {
    Open = "Open",
    Expired = "Expired",
    Closed = "Closed",
    Accepted = "Accepted",
    InContract = "InContract",
    Draft = "Draft",
    SentToModeration = "SentToModeration",
    Completed = "Completed",
    WaitingFreelancerApproval = "WaitingFreelancerApproval",
}

export enum GetJobsListQuerySortType {
    Ascending = "Ascending",
    Descending = "Descending",
    Default = "Default",
    Recommended = "Recommended",
}

export enum GetJobsListQuerySortOption {
    Date = "Date",
    Recomended = "Recomended",
}

export enum GetTransactionsListQueryOperation {
    Deposit = "Deposit",
    Withdrawal = "Withdrawal",
    Transfer = "Transfer",
    Refund = "Refund",
    SystemAdjustment = "SystemAdjustment",
    Bonus = "Bonus",
    Penalty = "Penalty",
}

export enum GetTransactionsListQueryFlow {
    Incoming = "Incoming",
    Outgoing = "Outgoing",
    Internal = "Internal",
}

export enum GetTransactionsListQueryStatus {
    Pending = "Pending",
    Processing = "Processing",
    Completed = "Completed",
    Failed = "Failed",
    Cancelled = "Cancelled",
    Expired = "Expired",
    Reversed = "Reversed",
}

export enum GetUsersListQueryRole {
    User = "User",
    Moderator = "Moderator",
    Admin = "Admin",
    Superadmin = "Superadmin",
}

export enum GetWorkSessionListQueryStatus {
    Pending = "Pending",
    Approved = "Approved",
    Rejected = "Rejected",
}

export enum JobDetailsStatus {
    Open = "Open",
    Expired = "Expired",
    Closed = "Closed",
    Accepted = "Accepted",
    InContract = "InContract",
    Draft = "Draft",
    SentToModeration = "SentToModeration",
    Completed = "Completed",
    WaitingFreelancerApproval = "WaitingFreelancerApproval",
}

export enum JobDetailsCurrency {
    RUB = "RUB",
    USD = "USD",
    KZT = "KZT",
    EUR = "EUR",
}

export enum JobEntityStatus {
    Open = "Open",
    Expired = "Expired",
    Closed = "Closed",
    Accepted = "Accepted",
    InContract = "InContract",
    Draft = "Draft",
    SentToModeration = "SentToModeration",
    Completed = "Completed",
    WaitingFreelancerApproval = "WaitingFreelancerApproval",
}

export enum JobEntityLevel {
    Beginner = "Beginner",
    Intermediate = "Intermediate",
    Expert = "Expert",
}

export enum JobEntityBudgetType {
    Hourly = "Hourly",
    Fixed = "Fixed",
}

export enum MoneyCurrency {
    RUB = "RUB",
    USD = "USD",
    KZT = "KZT",
    EUR = "EUR",
}

export enum NotificationEntityType {
    System = "System",
    Payment = "Payment",
    Other = "Other",
}

export enum ProposalEntityStatus {
    Pending = "Pending",
    Accepted = "Accepted",
    Rejected = "Rejected",
    Hidden = "Hidden",
}

export enum ReactToProposalCommandReaction {
    Pending = "Pending",
    Accepted = "Accepted",
    Rejected = "Rejected",
    Hidden = "Hidden",
}

export enum ReactToSentJobCommandReaction {
    Resubmit = "Resubmit",
    Approve = "Approve",
    Delete = "Delete",
}

export enum RegisterUserSchemaCountry {
    Kazakhstan = "Kazakhstan",
    Russia = "Russia",
    Belarus = "Belarus",
}

export enum RegisterUserSchemaType {
    Freelancer = "Freelancer",
    Client = "Client",
    Other = "Other",
    NonUser = "NonUser",
    Staff = "Staff",
}

export enum ResolveDisputeCommandStrategy {
    RefundClient = "RefundClient",
    PayFreelancer = "PayFreelancer",
    SplitPayment = "SplitPayment",
}

export enum StartPaymentFlowCommandFlow {
    Incoming = "Incoming",
    Outgoing = "Outgoing",
    Internal = "Internal",
}

export enum StartPaymentFlowCommandType {
    Deposit = "Deposit",
    Withdrawal = "Withdrawal",
    Transfer = "Transfer",
    Refund = "Refund",
    SystemAdjustment = "SystemAdjustment",
    Bonus = "Bonus",
    Penalty = "Penalty",
}

export enum TaxInformationLegalStatus {
    Individual = "Individual",
    SoleProprietor = "SoleProprietor",
    Entity = "Entity",
}

export enum TaxInformationTaxRegime {
    OSNO = "OSNO",
    USN_Income6 = "USN_Income6",
    USN_Profit15 = "USN_Profit15",
    Patent = "Patent",
    Simplified = "Simplified",
    General = "General",
}

export enum TicketEntityStatus {
    Open = "Open",
    Closed = "Closed",
    InProgress = "InProgress",
}

export enum TransactionEntityStatus {
    Pending = "Pending",
    Processing = "Processing",
    Completed = "Completed",
    Failed = "Failed",
    Cancelled = "Cancelled",
    Expired = "Expired",
    Reversed = "Reversed",
}

export enum TransactionEntityType {
    Deposit = "Deposit",
    Withdrawal = "Withdrawal",
    Transfer = "Transfer",
    Refund = "Refund",
    SystemAdjustment = "SystemAdjustment",
    Bonus = "Bonus",
    Penalty = "Penalty",
}

export enum TransactionEntityFlow {
    Incoming = "Incoming",
    Outgoing = "Outgoing",
    Internal = "Internal",
}

export enum UpdateClientProfileCommandEmployerType {
    Company = "Company",
    Indivdual = "Indivdual",
}

export enum UpdateFreelancerProfileCommandAvailability {
    Open = "Open",
    Busy = "Busy",
    Vacation = "Vacation",
}

export enum UpdateTaxSettingsCommandLegalStatus {
    Individual = "Individual",
    SoleProprietor = "SoleProprietor",
    Entity = "Entity",
}

export enum UpdateTaxSettingsCommandTaxRegime {
    OSNO = "OSNO",
    USN_Income6 = "USN_Income6",
    USN_Profit15 = "USN_Profit15",
    Patent = "Patent",
    Simplified = "Simplified",
    General = "General",
}

export enum UpdateUserCommandRole {
    User = "User",
    Moderator = "Moderator",
    Admin = "Admin",
    Superadmin = "Superadmin",
}

export enum UserEntityRole {
    User = "User",
    Moderator = "Moderator",
    Admin = "Admin",
    Superadmin = "Superadmin",
}

export enum UserEntityType {
    Freelancer = "Freelancer",
    Client = "Client",
    Other = "Other",
    NonUser = "NonUser",
    Staff = "Staff",
}

export enum UserEntityLocation {
    Kazakhstan = "Kazakhstan",
    Russia = "Russia",
    Belarus = "Belarus",
}

export enum WalletEntityCurrency {
    RUB = "RUB",
    USD = "USD",
    KZT = "KZT",
    EUR = "EUR",
}

export enum WalletEntityBlockReason {
    None = "None",
    FraudSuspicion = "FraudSuspicion",
    LegalIssue = "LegalIssue",
    UserRequest = "UserRequest",
}

export enum WorkSessionEntityStatus {
    Pending = "Pending",
    Approved = "Approved",
    Rejected = "Rejected",
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}